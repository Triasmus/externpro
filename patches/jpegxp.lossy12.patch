diff --git a/jconfig.doc b/jconfig.doc
deleted file mode 100644
index c18d1c0..0000000
--- a/jconfig.doc
+++ /dev/null
@@ -1,155 +0,0 @@
-/*
- * jconfig.doc
- *
- * Copyright (C) 1991-1994, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file documents the configuration options that are required to
- * customize the JPEG software for a particular system.
- *
- * The actual configuration options for a particular installation are stored
- * in jconfig.h.  On many machines, jconfig.h can be generated automatically
- * or copied from one of the "canned" jconfig files that we supply.  But if
- * you need to generate a jconfig.h file by hand, this file tells you how.
- *
- * DO NOT EDIT THIS FILE --- IT WON'T ACCOMPLISH ANYTHING.
- * EDIT A COPY NAMED JCONFIG.H.
- */
-
-
-/*
- * These symbols indicate the properties of your machine or compiler.
- * #define the symbol if yes, #undef it if no.
- */
-
-/* Does your compiler support function prototypes?
- * (If not, you also need to use ansi2knr, see install.doc)
- */
-#define HAVE_PROTOTYPES
-
-/* Does your compiler support the declaration "unsigned char" ?
- * How about "unsigned short" ?
- */
-#define HAVE_UNSIGNED_CHAR
-#define HAVE_UNSIGNED_SHORT
-
-/* Define "void" as "char" if your compiler doesn't know about type void.
- * NOTE: be sure to define void such that "void *" represents the most general
- * pointer type, e.g., that returned by malloc().
- */
-/* #define void char */
-
-/* Define "const" as empty if your compiler doesn't know the "const" keyword.
- */
-/* #define const */
-
-/* Define this if an ordinary "char" type is unsigned.
- * If you're not sure, leaving it undefined will work at some cost in speed.
- * If you defined HAVE_UNSIGNED_CHAR then the speed difference is minimal.
- */
-#undef CHAR_IS_UNSIGNED
-
-/* Define this if your system has an ANSI-conforming <stddef.h> file.
- */
-#define HAVE_STDDEF_H
-
-/* Define this if your system has an ANSI-conforming <stdlib.h> file.
- */
-#define HAVE_STDLIB_H
-
-/* Define this if your system does not have an ANSI/SysV <string.h>,
- * but does have a BSD-style <strings.h>.
- */
-#undef NEED_BSD_STRINGS
-
-/* Define this if your system does not provide typedef size_t in any of the
- * ANSI-standard places (stddef.h, stdlib.h, or stdio.h), but places it in
- * <sys/types.h> instead.
- */
-#undef NEED_SYS_TYPES_H
-
-/* For 80x86 machines, you need to define NEED_FAR_POINTERS,
- * unless you are using a large-data memory model or 80386 flat-memory mode.
- * On less brain-damaged CPUs this symbol must not be defined.
- * (Defining this symbol causes large data structures to be referenced through
- * "far" pointers and to be allocated with a special version of malloc.)
- */
-#undef NEED_FAR_POINTERS
-
-/* Define this if your linker needs global names to be unique in less
- * than the first 15 characters.
- */
-#undef NEED_SHORT_EXTERNAL_NAMES
-
-/* Although a real ANSI C compiler can deal perfectly well with pointers to
- * unspecified structures (see "incomplete types" in the spec), a few pre-ANSI
- * and pseudo-ANSI compilers get confused.  To keep one of these bozos happy,
- * define INCOMPLETE_TYPES_BROKEN.  This is not recommended unless you
- * actually get "missing structure definition" warnings or errors while
- * compiling the JPEG code.
- */
-#undef INCOMPLETE_TYPES_BROKEN
-
-
-/*
- * The following options affect code selection within the JPEG library,
- * but they don't need to be visible to applications using the library.
- * To minimize application namespace pollution, the symbols won't be
- * defined unless JPEG_INTERNALS has been defined.
- */
-
-#ifdef JPEG_INTERNALS
-
-/* Define this if your compiler implements ">>" on signed values as a logical
- * (unsigned) shift; leave it undefined if ">>" is a signed (arithmetic) shift,
- * which is the normal and rational definition.
- */
-#undef RIGHT_SHIFT_IS_UNSIGNED
-
-
-#endif /* JPEG_INTERNALS */
-
-
-/*
- * The remaining options do not affect the JPEG library proper,
- * but only the sample applications cjpeg/djpeg (see cjpeg.c, djpeg.c).
- * Other applications can ignore these.
- */
-
-#ifdef JPEG_CJPEG_DJPEG
-
-/* These defines indicate which image (non-JPEG) file formats are allowed. */
-
-#define BMP_SUPPORTED		/* BMP image file format */
-#define GIF_SUPPORTED		/* GIF image file format */
-#define PPM_SUPPORTED		/* PBMPLUS PPM/PGM image file format */
-#undef RLE_SUPPORTED		/* Utah RLE image file format */
-#define TARGA_SUPPORTED		/* Targa image file format */
-
-/* Define this if you want to name both input and output files on the command
- * line, rather than using stdout and optionally stdin.  You MUST do this if
- * your system can't cope with binary I/O to stdin/stdout.  See comments at
- * head of cjpeg.c or djpeg.c.
- */
-#undef TWO_FILE_COMMANDLINE
-
-/* Define this if your system needs explicit cleanup of temporary files.
- * This is crucial under MS-DOS, where the temporary "files" may be areas
- * of extended memory; on most other systems it's not as important.
- */
-#undef NEED_SIGNAL_CATCHER
-
-/* By default, we open image files with fopen(...,"rb") or fopen(...,"wb").
- * This is necessary on systems that distinguish text files from binary files,
- * and is harmless on most systems that don't.  If you have one of the rare
- * systems that complains about the "b" spec, define this symbol.
- */
-#undef DONT_USE_B_MODE
-
-/* Define this if you want percent-done progress reports from cjpeg/djpeg.
- */
-#undef PROGRESS_REPORT
-
-
-#endif /* JPEG_CJPEG_DJPEG */
diff --git a/jerror.c b/jerror.c
deleted file mode 100644
index 3da7be8..0000000
--- a/jerror.c
+++ /dev/null
@@ -1,252 +0,0 @@
-/*
- * jerror.c
- *
- * Copyright (C) 1991-1998, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file contains simple error-reporting and trace-message routines.
- * These are suitable for Unix-like systems and others where writing to
- * stderr is the right thing to do.  Many applications will want to replace
- * some or all of these routines.
- *
- * If you define USE_WINDOWS_MESSAGEBOX in jconfig.h or in the makefile,
- * you get a Windows-specific hack to display error messages in a dialog box.
- * It ain't much, but it beats dropping error messages into the bit bucket,
- * which is what happens to output to stderr under most Windows C compilers.
- *
- * These routines are used by both the compression and decompression code.
- */
-
-/* this is not a core library module, so it doesn't define JPEG_INTERNALS */
-#include "jinclude.h"
-#include "jpeglib.h"
-#include "jversion.h"
-#include "jerror.h"
-
-#ifdef USE_WINDOWS_MESSAGEBOX
-#include <windows.h>
-#endif
-
-#ifndef EXIT_FAILURE		/* define exit() codes if not provided */
-#define EXIT_FAILURE  1
-#endif
-
-
-/*
- * Create the message string table.
- * We do this from the master message list in jerror.h by re-reading
- * jerror.h with a suitable definition for macro JMESSAGE.
- * The message table is made an external symbol just in case any applications
- * want to refer to it directly.
- */
-
-#ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jpeg_std_message_table	jMsgTable
-#endif
-
-#define JMESSAGE(code,string)	string ,
-
-const char * const jpeg_std_message_table[] = {
-#include "jerror.h"
-  NULL
-};
-
-
-/*
- * Error exit handler: must not return to caller.
- *
- * Applications may override this if they want to get control back after
- * an error.  Typically one would longjmp somewhere instead of exiting.
- * The setjmp buffer can be made a private field within an expanded error
- * handler object.  Note that the info needed to generate an error message
- * is stored in the error object, so you can generate the message now or
- * later, at your convenience.
- * You should make sure that the JPEG object is cleaned up (with jpeg_abort
- * or jpeg_destroy) at some point.
- */
-
-METHODDEF(void)
-error_exit (j_common_ptr cinfo)
-{
-  /* Always display the message */
-  (*cinfo->err->output_message) (cinfo);
-
-  /* Let the memory manager delete any temp files before we die */
-  jpeg_destroy(cinfo);
-
-  exit(EXIT_FAILURE);
-}
-
-
-/*
- * Actual output of an error or trace message.
- * Applications may override this method to send JPEG messages somewhere
- * other than stderr.
- *
- * On Windows, printing to stderr is generally completely useless,
- * so we provide optional code to produce an error-dialog popup.
- * Most Windows applications will still prefer to override this routine,
- * but if they don't, it'll do something at least marginally useful.
- *
- * NOTE: to use the library in an environment that doesn't support the
- * C stdio library, you may have to delete the call to fprintf() entirely,
- * not just not use this routine.
- */
-
-METHODDEF(void)
-output_message (j_common_ptr cinfo)
-{
-  char buffer[JMSG_LENGTH_MAX];
-
-  /* Create the message */
-  (*cinfo->err->format_message) (cinfo, buffer);
-
-#ifdef USE_WINDOWS_MESSAGEBOX
-  /* Display it in a message dialog box */
-  MessageBox(GetActiveWindow(), buffer, "JPEG Library Error",
-	     MB_OK | MB_ICONERROR);
-#else
-  /* Send it to stderr, adding a newline */
-  fprintf(stderr, "%s\n", buffer);
-#endif
-}
-
-
-/*
- * Decide whether to emit a trace or warning message.
- * msg_level is one of:
- *   -1: recoverable corrupt-data warning, may want to abort.
- *    0: important advisory messages (always display to user).
- *    1: first level of tracing detail.
- *    2,3,...: successively more detailed tracing messages.
- * An application might override this method if it wanted to abort on warnings
- * or change the policy about which messages to display.
- */
-
-METHODDEF(void)
-emit_message (j_common_ptr cinfo, int msg_level)
-{
-  struct jpeg_error_mgr * err = cinfo->err;
-
-  if (msg_level < 0) {
-    /* It's a warning message.  Since corrupt files may generate many warnings,
-     * the policy implemented here is to show only the first warning,
-     * unless trace_level >= 3.
-     */
-    if (err->num_warnings == 0 || err->trace_level >= 3)
-      (*err->output_message) (cinfo);
-    /* Always count warnings in num_warnings. */
-    err->num_warnings++;
-  } else {
-    /* It's a trace message.  Show it if trace_level >= msg_level. */
-    if (err->trace_level >= msg_level)
-      (*err->output_message) (cinfo);
-  }
-}
-
-
-/*
- * Format a message string for the most recent JPEG error or message.
- * The message is stored into buffer, which should be at least JMSG_LENGTH_MAX
- * characters.  Note that no '\n' character is added to the string.
- * Few applications should need to override this method.
- */
-
-METHODDEF(void)
-format_message (j_common_ptr cinfo, char * buffer)
-{
-  struct jpeg_error_mgr * err = cinfo->err;
-  int msg_code = err->msg_code;
-  const char * msgtext = NULL;
-  const char * msgptr;
-  char ch;
-  boolean isstring;
-
-  /* Look up message string in proper table */
-  if (msg_code > 0 && msg_code <= err->last_jpeg_message) {
-    msgtext = err->jpeg_message_table[msg_code];
-  } else if (err->addon_message_table != NULL &&
-	     msg_code >= err->first_addon_message &&
-	     msg_code <= err->last_addon_message) {
-    msgtext = err->addon_message_table[msg_code - err->first_addon_message];
-  }
-
-  /* Defend against bogus message number */
-  if (msgtext == NULL) {
-    err->msg_parm.i[0] = msg_code;
-    msgtext = err->jpeg_message_table[0];
-  }
-
-  /* Check for string parameter, as indicated by %s in the message text */
-  isstring = FALSE;
-  msgptr = msgtext;
-  while ((ch = *msgptr++) != '\0') {
-    if (ch == '%') {
-      if (*msgptr == 's') isstring = TRUE;
-      break;
-    }
-  }
-
-  /* Format the message into the passed buffer */
-  if (isstring)
-    sprintf(buffer, msgtext, err->msg_parm.s);
-  else
-    sprintf(buffer, msgtext,
-	    err->msg_parm.i[0], err->msg_parm.i[1],
-	    err->msg_parm.i[2], err->msg_parm.i[3],
-	    err->msg_parm.i[4], err->msg_parm.i[5],
-	    err->msg_parm.i[6], err->msg_parm.i[7]);
-}
-
-
-/*
- * Reset error state variables at start of a new image.
- * This is called during compression startup to reset trace/error
- * processing to default state, without losing any application-specific
- * method pointers.  An application might possibly want to override
- * this method if it has additional error processing state.
- */
-
-METHODDEF(void)
-reset_error_mgr (j_common_ptr cinfo)
-{
-  cinfo->err->num_warnings = 0;
-  /* trace_level is not reset since it is an application-supplied parameter */
-  cinfo->err->msg_code = 0;	/* may be useful as a flag for "no error" */
-}
-
-
-/*
- * Fill in the standard error-handling methods in a jpeg_error_mgr object.
- * Typical call is:
- *	struct jpeg_compress_struct cinfo;
- *	struct jpeg_error_mgr err;
- *
- *	cinfo.err = jpeg_std_error(&err);
- * after which the application may override some of the methods.
- */
-
-GLOBAL(struct jpeg_error_mgr *)
-jpeg_std_error (struct jpeg_error_mgr * err)
-{
-  err->error_exit = error_exit;
-  err->emit_message = emit_message;
-  err->output_message = output_message;
-  err->format_message = format_message;
-  err->reset_error_mgr = reset_error_mgr;
-
-  err->trace_level = 0;		/* default = no tracing */
-  err->num_warnings = 0;	/* no warnings emitted yet */
-  err->msg_code = 0;		/* may be useful as a flag for "no error" */
-
-  /* Initialize message table pointers */
-  err->jpeg_message_table = jpeg_std_message_table;
-  err->last_jpeg_message = (int) JMSG_LASTMSGCODE - 1;
-
-  err->addon_message_table = NULL;
-  err->first_addon_message = 0;	/* for safety */
-  err->last_addon_message = 0;
-
-  return err;
-}
diff --git a/jerror.h b/jerror.h
deleted file mode 100644
index fc2fffe..0000000
--- a/jerror.h
+++ /dev/null
@@ -1,291 +0,0 @@
-/*
- * jerror.h
- *
- * Copyright (C) 1994-1997, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file defines the error and message codes for the JPEG library.
- * Edit this file to add new codes, or to translate the message strings to
- * some other language.
- * A set of error-reporting macros are defined too.  Some applications using
- * the JPEG library may wish to include this file to get the error codes
- * and/or the macros.
- */
-
-/*
- * To define the enum list of message codes, include this file without
- * defining macro JMESSAGE.  To create a message string table, include it
- * again with a suitable JMESSAGE definition (see jerror.c for an example).
- */
-#ifndef JMESSAGE
-#ifndef JERROR_H
-/* First time through, define the enum list */
-#define JMAKE_ENUM_LIST
-#else
-/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
-#define JMESSAGE(code,string)
-#endif /* JERROR_H */
-#endif /* JMESSAGE */
-
-#ifdef JMAKE_ENUM_LIST
-
-typedef enum {
-
-#define JMESSAGE(code,string)	code ,
-
-#endif /* JMAKE_ENUM_LIST */
-
-JMESSAGE(JMSG_NOMESSAGE, "Bogus message code %d") /* Must be first entry! */
-
-/* For maintenance convenience, list is alphabetical by message code name */
-JMESSAGE(JERR_ARITH_NOTIMPL,
-	 "Sorry, there are legal restrictions on arithmetic coding")
-JMESSAGE(JERR_BAD_ALIGN_TYPE, "ALIGN_TYPE is wrong, please fix")
-JMESSAGE(JERR_BAD_ALLOC_CHUNK, "MAX_ALLOC_CHUNK is wrong, please fix")
-JMESSAGE(JERR_BAD_BUFFER_MODE, "Bogus buffer control mode")
-JMESSAGE(JERR_BAD_COMPONENT_ID, "Invalid component ID %d in SOS")
-JMESSAGE(JERR_BAD_DCT_COEF, "DCT coefficient out of range")
-JMESSAGE(JERR_BAD_DCTSIZE, "IDCT output block size %d not supported")
-JMESSAGE(JERR_BAD_HUFF_TABLE, "Bogus Huffman table definition")
-JMESSAGE(JERR_BAD_IN_COLORSPACE, "Bogus input colorspace")
-JMESSAGE(JERR_BAD_J_COLORSPACE, "Bogus JPEG colorspace")
-JMESSAGE(JERR_BAD_LENGTH, "Bogus marker length")
-JMESSAGE(JERR_BAD_LIB_VERSION,
-	 "Wrong JPEG library version: library is %d, caller expects %d")
-JMESSAGE(JERR_BAD_MCU_SIZE, "Sampling factors too large for interleaved scan")
-JMESSAGE(JERR_BAD_POOL_ID, "Invalid memory pool code %d")
-JMESSAGE(JERR_BAD_PRECISION, "Unsupported JPEG data precision %d")
-JMESSAGE(JERR_BAD_PROGRESSION,
-	 "Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d")
-JMESSAGE(JERR_BAD_PROG_SCRIPT,
-	 "Invalid progressive parameters at scan script entry %d")
-JMESSAGE(JERR_BAD_SAMPLING, "Bogus sampling factors")
-JMESSAGE(JERR_BAD_SCAN_SCRIPT, "Invalid scan script at entry %d")
-JMESSAGE(JERR_BAD_STATE, "Improper call to JPEG library in state %d")
-JMESSAGE(JERR_BAD_STRUCT_SIZE,
-	 "JPEG parameter struct mismatch: library thinks size is %u, caller expects %u")
-JMESSAGE(JERR_BAD_VIRTUAL_ACCESS, "Bogus virtual array access")
-JMESSAGE(JERR_BUFFER_SIZE, "Buffer passed to JPEG library is too small")
-JMESSAGE(JERR_CANT_SUSPEND, "Suspension not allowed here")
-JMESSAGE(JERR_CCIR601_NOTIMPL, "CCIR601 sampling not implemented yet")
-JMESSAGE(JERR_COMPONENT_COUNT, "Too many color components: %d, max %d")
-JMESSAGE(JERR_CONVERSION_NOTIMPL, "Unsupported color conversion request")
-JMESSAGE(JERR_DAC_INDEX, "Bogus DAC index %d")
-JMESSAGE(JERR_DAC_VALUE, "Bogus DAC value 0x%x")
-JMESSAGE(JERR_DHT_INDEX, "Bogus DHT index %d")
-JMESSAGE(JERR_DQT_INDEX, "Bogus DQT index %d")
-JMESSAGE(JERR_EMPTY_IMAGE, "Empty JPEG image (DNL not supported)")
-JMESSAGE(JERR_EMS_READ, "Read from EMS failed")
-JMESSAGE(JERR_EMS_WRITE, "Write to EMS failed")
-JMESSAGE(JERR_EOI_EXPECTED, "Didn't expect more than one scan")
-JMESSAGE(JERR_FILE_READ, "Input file read error")
-JMESSAGE(JERR_FILE_WRITE, "Output file write error --- out of disk space?")
-JMESSAGE(JERR_FRACT_SAMPLE_NOTIMPL, "Fractional sampling not implemented yet")
-JMESSAGE(JERR_HUFF_CLEN_OVERFLOW, "Huffman code size table overflow")
-JMESSAGE(JERR_HUFF_MISSING_CODE, "Missing Huffman code table entry")
-JMESSAGE(JERR_IMAGE_TOO_BIG, "Maximum supported image dimension is %u pixels")
-JMESSAGE(JERR_INPUT_EMPTY, "Empty input file")
-JMESSAGE(JERR_INPUT_EOF, "Premature end of input file")
-JMESSAGE(JERR_MISMATCHED_QUANT_TABLE,
-	 "Cannot transcode due to multiple use of quantization table %d")
-JMESSAGE(JERR_MISSING_DATA, "Scan script does not transmit all data")
-JMESSAGE(JERR_MODE_CHANGE, "Invalid color quantization mode change")
-JMESSAGE(JERR_NOTIMPL, "Not implemented yet")
-JMESSAGE(JERR_NOT_COMPILED, "Requested feature was omitted at compile time")
-JMESSAGE(JERR_NO_BACKING_STORE, "Backing store not supported")
-JMESSAGE(JERR_NO_HUFF_TABLE, "Huffman table 0x%02x was not defined")
-JMESSAGE(JERR_NO_IMAGE, "JPEG datastream contains no image")
-JMESSAGE(JERR_NO_QUANT_TABLE, "Quantization table 0x%02x was not defined")
-JMESSAGE(JERR_NO_SOI, "Not a JPEG file: starts with 0x%02x 0x%02x")
-JMESSAGE(JERR_OUT_OF_MEMORY, "Insufficient memory (case %d)")
-JMESSAGE(JERR_QUANT_COMPONENTS,
-	 "Cannot quantize more than %d color components")
-JMESSAGE(JERR_QUANT_FEW_COLORS, "Cannot quantize to fewer than %d colors")
-JMESSAGE(JERR_QUANT_MANY_COLORS, "Cannot quantize to more than %d colors")
-JMESSAGE(JERR_SOF_DUPLICATE, "Invalid JPEG file structure: two SOF markers")
-JMESSAGE(JERR_SOF_NO_SOS, "Invalid JPEG file structure: missing SOS marker")
-JMESSAGE(JERR_SOF_UNSUPPORTED, "Unsupported JPEG process: SOF type 0x%02x")
-JMESSAGE(JERR_SOI_DUPLICATE, "Invalid JPEG file structure: two SOI markers")
-JMESSAGE(JERR_SOS_NO_SOF, "Invalid JPEG file structure: SOS before SOF")
-JMESSAGE(JERR_TFILE_CREATE, "Failed to create temporary file %s")
-JMESSAGE(JERR_TFILE_READ, "Read failed on temporary file")
-JMESSAGE(JERR_TFILE_SEEK, "Seek failed on temporary file")
-JMESSAGE(JERR_TFILE_WRITE,
-	 "Write failed on temporary file --- out of disk space?")
-JMESSAGE(JERR_TOO_LITTLE_DATA, "Application transferred too few scanlines")
-JMESSAGE(JERR_UNKNOWN_MARKER, "Unsupported marker type 0x%02x")
-JMESSAGE(JERR_VIRTUAL_BUG, "Virtual array controller messed up")
-JMESSAGE(JERR_WIDTH_OVERFLOW, "Image too wide for this implementation")
-JMESSAGE(JERR_XMS_READ, "Read from XMS failed")
-JMESSAGE(JERR_XMS_WRITE, "Write to XMS failed")
-JMESSAGE(JMSG_COPYRIGHT, JCOPYRIGHT)
-JMESSAGE(JMSG_VERSION, JVERSION)
-JMESSAGE(JTRC_16BIT_TABLES,
-	 "Caution: quantization tables are too coarse for baseline JPEG")
-JMESSAGE(JTRC_ADOBE,
-	 "Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d")
-JMESSAGE(JTRC_APP0, "Unknown APP0 marker (not JFIF), length %u")
-JMESSAGE(JTRC_APP14, "Unknown APP14 marker (not Adobe), length %u")
-JMESSAGE(JTRC_DAC, "Define Arithmetic Table 0x%02x: 0x%02x")
-JMESSAGE(JTRC_DHT, "Define Huffman Table 0x%02x")
-JMESSAGE(JTRC_DQT, "Define Quantization Table %d  precision %d")
-JMESSAGE(JTRC_DRI, "Define Restart Interval %u")
-JMESSAGE(JTRC_EMS_CLOSE, "Freed EMS handle %u")
-JMESSAGE(JTRC_EMS_OPEN, "Obtained EMS handle %u")
-JMESSAGE(JTRC_EOI, "End Of Image")
-JMESSAGE(JTRC_HUFFBITS, "        %3d %3d %3d %3d %3d %3d %3d %3d")
-JMESSAGE(JTRC_JFIF, "JFIF APP0 marker: version %d.%02d, density %dx%d  %d")
-JMESSAGE(JTRC_JFIF_BADTHUMBNAILSIZE,
-	 "Warning: thumbnail image size does not match data length %u")
-JMESSAGE(JTRC_JFIF_EXTENSION,
-	 "JFIF extension marker: type 0x%02x, length %u")
-JMESSAGE(JTRC_JFIF_THUMBNAIL, "    with %d x %d thumbnail image")
-JMESSAGE(JTRC_MISC_MARKER, "Miscellaneous marker 0x%02x, length %u")
-JMESSAGE(JTRC_PARMLESS_MARKER, "Unexpected marker 0x%02x")
-JMESSAGE(JTRC_QUANTVALS, "        %4u %4u %4u %4u %4u %4u %4u %4u")
-JMESSAGE(JTRC_QUANT_3_NCOLORS, "Quantizing to %d = %d*%d*%d colors")
-JMESSAGE(JTRC_QUANT_NCOLORS, "Quantizing to %d colors")
-JMESSAGE(JTRC_QUANT_SELECTED, "Selected %d colors for quantization")
-JMESSAGE(JTRC_RECOVERY_ACTION, "At marker 0x%02x, recovery action %d")
-JMESSAGE(JTRC_RST, "RST%d")
-JMESSAGE(JTRC_SMOOTH_NOTIMPL,
-	 "Smoothing not supported with nonstandard sampling ratios")
-JMESSAGE(JTRC_SOF, "Start Of Frame 0x%02x: width=%u, height=%u, components=%d")
-JMESSAGE(JTRC_SOF_COMPONENT, "    Component %d: %dhx%dv q=%d")
-JMESSAGE(JTRC_SOI, "Start of Image")
-JMESSAGE(JTRC_SOS, "Start Of Scan: %d components")
-JMESSAGE(JTRC_SOS_COMPONENT, "    Component %d: dc=%d ac=%d")
-JMESSAGE(JTRC_SOS_PARAMS, "  Ss=%d, Se=%d, Ah=%d, Al=%d")
-JMESSAGE(JTRC_TFILE_CLOSE, "Closed temporary file %s")
-JMESSAGE(JTRC_TFILE_OPEN, "Opened temporary file %s")
-JMESSAGE(JTRC_THUMB_JPEG,
-	 "JFIF extension marker: JPEG-compressed thumbnail image, length %u")
-JMESSAGE(JTRC_THUMB_PALETTE,
-	 "JFIF extension marker: palette thumbnail image, length %u")
-JMESSAGE(JTRC_THUMB_RGB,
-	 "JFIF extension marker: RGB thumbnail image, length %u")
-JMESSAGE(JTRC_UNKNOWN_IDS,
-	 "Unrecognized component IDs %d %d %d, assuming YCbCr")
-JMESSAGE(JTRC_XMS_CLOSE, "Freed XMS handle %u")
-JMESSAGE(JTRC_XMS_OPEN, "Obtained XMS handle %u")
-JMESSAGE(JWRN_ADOBE_XFORM, "Unknown Adobe color transform code %d")
-JMESSAGE(JWRN_BOGUS_PROGRESSION,
-	 "Inconsistent progression sequence for component %d coefficient %d")
-JMESSAGE(JWRN_EXTRANEOUS_DATA,
-	 "Corrupt JPEG data: %u extraneous bytes before marker 0x%02x")
-JMESSAGE(JWRN_HIT_MARKER, "Corrupt JPEG data: premature end of data segment")
-JMESSAGE(JWRN_HUFF_BAD_CODE, "Corrupt JPEG data: bad Huffman code")
-JMESSAGE(JWRN_JFIF_MAJOR, "Warning: unknown JFIF revision number %d.%02d")
-JMESSAGE(JWRN_JPEG_EOF, "Premature end of JPEG file")
-JMESSAGE(JWRN_MUST_RESYNC,
-	 "Corrupt JPEG data: found marker 0x%02x instead of RST%d")
-JMESSAGE(JWRN_NOT_SEQUENTIAL, "Invalid SOS parameters for sequential JPEG")
-JMESSAGE(JWRN_TOO_MUCH_DATA, "Application transferred too many scanlines")
-
-#ifdef JMAKE_ENUM_LIST
-
-  JMSG_LASTMSGCODE
-} J_MESSAGE_CODE;
-
-#undef JMAKE_ENUM_LIST
-#endif /* JMAKE_ENUM_LIST */
-
-/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
-#undef JMESSAGE
-
-
-#ifndef JERROR_H
-#define JERROR_H
-
-/* Macros to simplify using the error and trace message stuff */
-/* The first parameter is either type of cinfo pointer */
-
-/* Fatal errors (print message and exit) */
-#define ERREXIT(cinfo,code)  \
-  ((cinfo)->err->msg_code = (code), \
-   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
-#define ERREXIT1(cinfo,code,p1)  \
-  ((cinfo)->err->msg_code = (code), \
-   (cinfo)->err->msg_parm.i[0] = (p1), \
-   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
-#define ERREXIT2(cinfo,code,p1,p2)  \
-  ((cinfo)->err->msg_code = (code), \
-   (cinfo)->err->msg_parm.i[0] = (p1), \
-   (cinfo)->err->msg_parm.i[1] = (p2), \
-   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
-#define ERREXIT3(cinfo,code,p1,p2,p3)  \
-  ((cinfo)->err->msg_code = (code), \
-   (cinfo)->err->msg_parm.i[0] = (p1), \
-   (cinfo)->err->msg_parm.i[1] = (p2), \
-   (cinfo)->err->msg_parm.i[2] = (p3), \
-   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
-#define ERREXIT4(cinfo,code,p1,p2,p3,p4)  \
-  ((cinfo)->err->msg_code = (code), \
-   (cinfo)->err->msg_parm.i[0] = (p1), \
-   (cinfo)->err->msg_parm.i[1] = (p2), \
-   (cinfo)->err->msg_parm.i[2] = (p3), \
-   (cinfo)->err->msg_parm.i[3] = (p4), \
-   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
-#define ERREXITS(cinfo,code,str)  \
-  ((cinfo)->err->msg_code = (code), \
-   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
-   (*(cinfo)->err->error_exit) ((j_common_ptr) (cinfo)))
-
-#define MAKESTMT(stuff)		do { stuff } while (0)
-
-/* Nonfatal errors (we can keep going, but the data is probably corrupt) */
-#define WARNMS(cinfo,code)  \
-  ((cinfo)->err->msg_code = (code), \
-   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
-#define WARNMS1(cinfo,code,p1)  \
-  ((cinfo)->err->msg_code = (code), \
-   (cinfo)->err->msg_parm.i[0] = (p1), \
-   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
-#define WARNMS2(cinfo,code,p1,p2)  \
-  ((cinfo)->err->msg_code = (code), \
-   (cinfo)->err->msg_parm.i[0] = (p1), \
-   (cinfo)->err->msg_parm.i[1] = (p2), \
-   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), -1))
-
-/* Informational/debugging messages */
-#define TRACEMS(cinfo,lvl,code)  \
-  ((cinfo)->err->msg_code = (code), \
-   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
-#define TRACEMS1(cinfo,lvl,code,p1)  \
-  ((cinfo)->err->msg_code = (code), \
-   (cinfo)->err->msg_parm.i[0] = (p1), \
-   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
-#define TRACEMS2(cinfo,lvl,code,p1,p2)  \
-  ((cinfo)->err->msg_code = (code), \
-   (cinfo)->err->msg_parm.i[0] = (p1), \
-   (cinfo)->err->msg_parm.i[1] = (p2), \
-   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
-#define TRACEMS3(cinfo,lvl,code,p1,p2,p3)  \
-  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
-	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); \
-	   (cinfo)->err->msg_code = (code); \
-	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
-#define TRACEMS4(cinfo,lvl,code,p1,p2,p3,p4)  \
-  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
-	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
-	   (cinfo)->err->msg_code = (code); \
-	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
-#define TRACEMS5(cinfo,lvl,code,p1,p2,p3,p4,p5)  \
-  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
-	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
-	   _mp[4] = (p5); \
-	   (cinfo)->err->msg_code = (code); \
-	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
-#define TRACEMS8(cinfo,lvl,code,p1,p2,p3,p4,p5,p6,p7,p8)  \
-  MAKESTMT(int * _mp = (cinfo)->err->msg_parm.i; \
-	   _mp[0] = (p1); _mp[1] = (p2); _mp[2] = (p3); _mp[3] = (p4); \
-	   _mp[4] = (p5); _mp[5] = (p6); _mp[6] = (p7); _mp[7] = (p8); \
-	   (cinfo)->err->msg_code = (code); \
-	   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)); )
-#define TRACEMSS(cinfo,lvl,code,str)  \
-  ((cinfo)->err->msg_code = (code), \
-   strncpy((cinfo)->err->msg_parm.s, (str), JMSG_STR_PARM_MAX), \
-   (*(cinfo)->err->emit_message) ((j_common_ptr) (cinfo), (lvl)))
-
-#endif /* JERROR_H */
diff --git a/jinclude.h b/jinclude.h
deleted file mode 100644
index 0a4f151..0000000
--- a/jinclude.h
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * jinclude.h
- *
- * Copyright (C) 1991-1994, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file exists to provide a single place to fix any problems with
- * including the wrong system include files.  (Common problems are taken
- * care of by the standard jconfig symbols, but on really weird systems
- * you may have to edit this file.)
- *
- * NOTE: this file is NOT intended to be included by applications using the
- * JPEG library.  Most applications need only include jpeglib.h.
- */
-
-
-/* Include auto-config file to find out which system include files we need. */
-
-#include "jconfig.h"		/* auto configuration options */
-#define JCONFIG_INCLUDED	/* so that jpeglib.h doesn't do it again */
-
-/*
- * We need the NULL macro and size_t typedef.
- * On an ANSI-conforming system it is sufficient to include <stddef.h>.
- * Otherwise, we get them from <stdlib.h> or <stdio.h>; we may have to
- * pull in <sys/types.h> as well.
- * Note that the core JPEG library does not require <stdio.h>;
- * only the default error handler and data source/destination modules do.
- * But we must pull it in because of the references to FILE in jpeglib.h.
- * You can remove those references if you want to compile without <stdio.h>.
- */
-
-#ifdef HAVE_STDDEF_H
-#include <stddef.h>
-#endif
-
-#ifdef HAVE_STDLIB_H
-#include <stdlib.h>
-#endif
-
-#ifdef NEED_SYS_TYPES_H
-#include <sys/types.h>
-#endif
-
-#include <stdio.h>
-
-/*
- * We need memory copying and zeroing functions, plus strncpy().
- * ANSI and System V implementations declare these in <string.h>.
- * BSD doesn't have the mem() functions, but it does have bcopy()/bzero().
- * Some systems may declare memset and memcpy in <memory.h>.
- *
- * NOTE: we assume the size parameters to these functions are of type size_t.
- * Change the casts in these macros if not!
- */
-
-#ifdef NEED_BSD_STRINGS
-
-#include <strings.h>
-#define MEMZERO(target,size)	bzero((void *)(target), (size_t)(size))
-#define MEMCOPY(dest,src,size)	bcopy((const void *)(src), (void *)(dest), (size_t)(size))
-
-#else /* not BSD, assume ANSI/SysV string lib */
-
-#include <string.h>
-#define MEMZERO(target,size)	memset((void *)(target), 0, (size_t)(size))
-#define MEMCOPY(dest,src,size)	memcpy((void *)(dest), (const void *)(src), (size_t)(size))
-
-#endif
-
-/*
- * In ANSI C, and indeed any rational implementation, size_t is also the
- * type returned by sizeof().  However, it seems there are some irrational
- * implementations out there, in which sizeof() returns an int even though
- * size_t is defined as long or unsigned long.  To ensure consistent results
- * we always use this SIZEOF() macro in place of using sizeof() directly.
- */
-
-#define SIZEOF(object)	((size_t) sizeof(object))
-
-/*
- * The modules that use fread() and fwrite() always invoke them through
- * these macros.  On some systems you may need to twiddle the argument casts.
- * CAUTION: argument order is different from underlying functions!
- */
-
-#define JFREAD(file,buf,sizeofbuf)  \
-  ((size_t) fread((void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
-#define JFWRITE(file,buf,sizeofbuf)  \
-  ((size_t) fwrite((const void *) (buf), (size_t) 1, (size_t) (sizeofbuf), (file)))
diff --git a/jmemnobs.c b/jmemnobs.c
deleted file mode 100644
index eb8c337..0000000
--- a/jmemnobs.c
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * jmemnobs.c
- *
- * Copyright (C) 1992-1996, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file provides a really simple implementation of the system-
- * dependent portion of the JPEG memory manager.  This implementation
- * assumes that no backing-store files are needed: all required space
- * can be obtained from malloc().
- * This is very portable in the sense that it'll compile on almost anything,
- * but you'd better have lots of main memory (or virtual memory) if you want
- * to process big images.
- * Note that the max_memory_to_use option is ignored by this implementation.
- */
-
-#define JPEG_INTERNALS
-#include "jinclude.h"
-#include "jpeglib.h"
-#include "jmemsys.h"		/* import the system-dependent declarations */
-
-#ifndef HAVE_STDLIB_H		/* <stdlib.h> should declare malloc(),free() */
-extern void * malloc JPP((size_t size));
-extern void free JPP((void *ptr));
-#endif
-
-
-/*
- * Memory allocation and freeing are controlled by the regular library
- * routines malloc() and free().
- */
-
-GLOBAL(void *)
-jpeg_get_small (j_common_ptr cinfo, size_t sizeofobject)
-{
-  return (void *) malloc(sizeofobject);
-}
-
-GLOBAL(void)
-jpeg_free_small (j_common_ptr cinfo, void * object, size_t sizeofobject)
-{
-  free(object);
-}
-
-
-/*
- * "Large" objects are treated the same as "small" ones.
- * NB: although we include FAR keywords in the routine declarations,
- * this file won't actually work in 80x86 small/medium model; at least,
- * you probably won't be able to process useful-size images in only 64KB.
- */
-
-GLOBAL(void FAR *)
-jpeg_get_large (j_common_ptr cinfo, size_t sizeofobject)
-{
-  return (void FAR *) malloc(sizeofobject);
-}
-
-GLOBAL(void)
-jpeg_free_large (j_common_ptr cinfo, void FAR * object, size_t sizeofobject)
-{
-  free(object);
-}
-
-
-/*
- * This routine computes the total memory space available for allocation.
- * Here we always say, "we got all you want bud!"
- */
-
-GLOBAL(long)
-jpeg_mem_available (j_common_ptr cinfo, long min_bytes_needed,
-		    long max_bytes_needed, long already_allocated)
-{
-  return max_bytes_needed;
-}
-
-
-/*
- * Backing store (temporary file) management.
- * Since jpeg_mem_available always promised the moon,
- * this should never be called and we can just error out.
- */
-
-GLOBAL(void)
-jpeg_open_backing_store (j_common_ptr cinfo, backing_store_ptr info,
-			 long total_bytes_needed)
-{
-  ERREXIT(cinfo, JERR_NO_BACKING_STORE);
-}
-
-
-/*
- * These routines take care of any system-dependent initialization and
- * cleanup required.  Here, there isn't any.
- */
-
-GLOBAL(long)
-jpeg_mem_init (j_common_ptr cinfo)
-{
-  return 0;			/* just set max_memory_to_use to 0 */
-}
-
-GLOBAL(void)
-jpeg_mem_term (j_common_ptr cinfo)
-{
-  /* no work */
-}
diff --git a/jmemsys.h b/jmemsys.h
deleted file mode 100644
index 6c3c6d3..0000000
--- a/jmemsys.h
+++ /dev/null
@@ -1,198 +0,0 @@
-/*
- * jmemsys.h
- *
- * Copyright (C) 1992-1997, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This include file defines the interface between the system-independent
- * and system-dependent portions of the JPEG memory manager.  No other
- * modules need include it.  (The system-independent portion is jmemmgr.c;
- * there are several different versions of the system-dependent portion.)
- *
- * This file works as-is for the system-dependent memory managers supplied
- * in the IJG distribution.  You may need to modify it if you write a
- * custom memory manager.  If system-dependent changes are needed in
- * this file, the best method is to #ifdef them based on a configuration
- * symbol supplied in jconfig.h, as we have done with USE_MSDOS_MEMMGR
- * and USE_MAC_MEMMGR.
- */
-
-
-/* Short forms of external names for systems with brain-damaged linkers. */
-
-#ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jpeg_get_small		jGetSmall
-#define jpeg_free_small		jFreeSmall
-#define jpeg_get_large		jGetLarge
-#define jpeg_free_large		jFreeLarge
-#define jpeg_mem_available	jMemAvail
-#define jpeg_open_backing_store	jOpenBackStore
-#define jpeg_mem_init		jMemInit
-#define jpeg_mem_term		jMemTerm
-#endif /* NEED_SHORT_EXTERNAL_NAMES */
-
-
-/*
- * These two functions are used to allocate and release small chunks of
- * memory.  (Typically the total amount requested through jpeg_get_small is
- * no more than 20K or so; this will be requested in chunks of a few K each.)
- * Behavior should be the same as for the standard library functions malloc
- * and free; in particular, jpeg_get_small must return NULL on failure.
- * On most systems, these ARE malloc and free.  jpeg_free_small is passed the
- * size of the object being freed, just in case it's needed.
- * On an 80x86 machine using small-data memory model, these manage near heap.
- */
-
-EXTERN(void *) jpeg_get_small JPP((j_common_ptr cinfo, size_t sizeofobject));
-EXTERN(void) jpeg_free_small JPP((j_common_ptr cinfo, void * object,
-				  size_t sizeofobject));
-
-/*
- * These two functions are used to allocate and release large chunks of
- * memory (up to the total free space designated by jpeg_mem_available).
- * The interface is the same as above, except that on an 80x86 machine,
- * far pointers are used.  On most other machines these are identical to
- * the jpeg_get/free_small routines; but we keep them separate anyway,
- * in case a different allocation strategy is desirable for large chunks.
- */
-
-EXTERN(void FAR *) jpeg_get_large JPP((j_common_ptr cinfo,
-				       size_t sizeofobject));
-EXTERN(void) jpeg_free_large JPP((j_common_ptr cinfo, void FAR * object,
-				  size_t sizeofobject));
-
-/*
- * The macro MAX_ALLOC_CHUNK designates the maximum number of bytes that may
- * be requested in a single call to jpeg_get_large (and jpeg_get_small for that
- * matter, but that case should never come into play).  This macro is needed
- * to model the 64Kb-segment-size limit of far addressing on 80x86 machines.
- * On those machines, we expect that jconfig.h will provide a proper value.
- * On machines with 32-bit flat address spaces, any large constant may be used.
- *
- * NB: jmemmgr.c expects that MAX_ALLOC_CHUNK will be representable as type
- * size_t and will be a multiple of sizeof(align_type).
- */
-
-#ifndef MAX_ALLOC_CHUNK		/* may be overridden in jconfig.h */
-#define MAX_ALLOC_CHUNK  1000000000L
-#endif
-
-/*
- * This routine computes the total space still available for allocation by
- * jpeg_get_large.  If more space than this is needed, backing store will be
- * used.  NOTE: any memory already allocated must not be counted.
- *
- * There is a minimum space requirement, corresponding to the minimum
- * feasible buffer sizes; jmemmgr.c will request that much space even if
- * jpeg_mem_available returns zero.  The maximum space needed, enough to hold
- * all working storage in memory, is also passed in case it is useful.
- * Finally, the total space already allocated is passed.  If no better
- * method is available, cinfo->mem->max_memory_to_use - already_allocated
- * is often a suitable calculation.
- *
- * It is OK for jpeg_mem_available to underestimate the space available
- * (that'll just lead to more backing-store access than is really necessary).
- * However, an overestimate will lead to failure.  Hence it's wise to subtract
- * a slop factor from the true available space.  5% should be enough.
- *
- * On machines with lots of virtual memory, any large constant may be returned.
- * Conversely, zero may be returned to always use the minimum amount of memory.
- */
-
-EXTERN(long) jpeg_mem_available JPP((j_common_ptr cinfo,
-				     long min_bytes_needed,
-				     long max_bytes_needed,
-				     long already_allocated));
-
-
-/*
- * This structure holds whatever state is needed to access a single
- * backing-store object.  The read/write/close method pointers are called
- * by jmemmgr.c to manipulate the backing-store object; all other fields
- * are private to the system-dependent backing store routines.
- */
-
-#define TEMP_NAME_LENGTH   64	/* max length of a temporary file's name */
-
-
-#ifdef USE_MSDOS_MEMMGR		/* DOS-specific junk */
-
-typedef unsigned short XMSH;	/* type of extended-memory handles */
-typedef unsigned short EMSH;	/* type of expanded-memory handles */
-
-typedef union {
-  short file_handle;		/* DOS file handle if it's a temp file */
-  XMSH xms_handle;		/* handle if it's a chunk of XMS */
-  EMSH ems_handle;		/* handle if it's a chunk of EMS */
-} handle_union;
-
-#endif /* USE_MSDOS_MEMMGR */
-
-#ifdef USE_MAC_MEMMGR		/* Mac-specific junk */
-#include <Files.h>
-#endif /* USE_MAC_MEMMGR */
-
-
-typedef struct backing_store_struct * backing_store_ptr;
-
-typedef struct backing_store_struct {
-  /* Methods for reading/writing/closing this backing-store object */
-  JMETHOD(void, read_backing_store, (j_common_ptr cinfo,
-				     backing_store_ptr info,
-				     void FAR * buffer_address,
-				     long file_offset, long byte_count));
-  JMETHOD(void, write_backing_store, (j_common_ptr cinfo,
-				      backing_store_ptr info,
-				      void FAR * buffer_address,
-				      long file_offset, long byte_count));
-  JMETHOD(void, close_backing_store, (j_common_ptr cinfo,
-				      backing_store_ptr info));
-
-  /* Private fields for system-dependent backing-store management */
-#ifdef USE_MSDOS_MEMMGR
-  /* For the MS-DOS manager (jmemdos.c), we need: */
-  handle_union handle;		/* reference to backing-store storage object */
-  char temp_name[TEMP_NAME_LENGTH]; /* name if it's a file */
-#else
-#ifdef USE_MAC_MEMMGR
-  /* For the Mac manager (jmemmac.c), we need: */
-  short temp_file;		/* file reference number to temp file */
-  FSSpec tempSpec;		/* the FSSpec for the temp file */
-  char temp_name[TEMP_NAME_LENGTH]; /* name if it's a file */
-#else
-  /* For a typical implementation with temp files, we need: */
-  FILE * temp_file;		/* stdio reference to temp file */
-  char temp_name[TEMP_NAME_LENGTH]; /* name of temp file */
-#endif
-#endif
-} backing_store_info;
-
-
-/*
- * Initial opening of a backing-store object.  This must fill in the
- * read/write/close pointers in the object.  The read/write routines
- * may take an error exit if the specified maximum file size is exceeded.
- * (If jpeg_mem_available always returns a large value, this routine can
- * just take an error exit.)
- */
-
-EXTERN(void) jpeg_open_backing_store JPP((j_common_ptr cinfo,
-					  backing_store_ptr info,
-					  long total_bytes_needed));
-
-
-/*
- * These routines take care of any system-dependent initialization and
- * cleanup required.  jpeg_mem_init will be called before anything is
- * allocated (and, therefore, nothing in cinfo is of use except the error
- * manager pointer).  It should return a suitable default value for
- * max_memory_to_use; this may subsequently be overridden by the surrounding
- * application.  (Note that max_memory_to_use is only important if
- * jpeg_mem_available chooses to consult it ... no one else will.)
- * jpeg_mem_term may assume that all requested memory has been freed and that
- * all opened backing-store objects have been closed.
- */
-
-EXTERN(long) jpeg_mem_init JPP((j_common_ptr cinfo));
-EXTERN(void) jpeg_mem_term JPP((j_common_ptr cinfo));
diff --git a/jmorecfg.h b/jmorecfg.h
deleted file mode 100644
index 54a7d1c..0000000
--- a/jmorecfg.h
+++ /dev/null
@@ -1,363 +0,0 @@
-/*
- * jmorecfg.h
- *
- * Copyright (C) 1991-1997, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file contains additional configuration options that customize the
- * JPEG software for special applications or support machine-dependent
- * optimizations.  Most users will not need to touch this file.
- */
-
-
-/*
- * Define BITS_IN_JSAMPLE as either
- *   8   for 8-bit sample values (the usual setting)
- *   12  for 12-bit sample values
- * Only 8 and 12 are legal data precisions for lossy JPEG according to the
- * JPEG standard, and the IJG code does not support anything else!
- * We do not support run-time selection of data precision, sorry.
- */
-
-#define BITS_IN_JSAMPLE  8	/* use 8 or 12 */
-
-
-/*
- * Maximum number of components (color channels) allowed in JPEG image.
- * To meet the letter of the JPEG spec, set this to 255.  However, darn
- * few applications need more than 4 channels (maybe 5 for CMYK + alpha
- * mask).  We recommend 10 as a reasonable compromise; use 4 if you are
- * really short on memory.  (Each allowed component costs a hundred or so
- * bytes of storage, whether actually used in an image or not.)
- */
-
-#define MAX_COMPONENTS  10	/* maximum number of image components */
-
-
-/*
- * Basic data types.
- * You may need to change these if you have a machine with unusual data
- * type sizes; for example, "char" not 8 bits, "short" not 16 bits,
- * or "long" not 32 bits.  We don't care whether "int" is 16 or 32 bits,
- * but it had better be at least 16.
- */
-
-/* Representation of a single sample (pixel element value).
- * We frequently allocate large arrays of these, so it's important to keep
- * them small.  But if you have memory to burn and access to char or short
- * arrays is very slow on your hardware, you might want to change these.
- */
-
-#if BITS_IN_JSAMPLE == 8
-/* JSAMPLE should be the smallest type that will hold the values 0..255.
- * You can use a signed char by having GETJSAMPLE mask it with 0xFF.
- */
-
-#ifdef HAVE_UNSIGNED_CHAR
-
-typedef unsigned char JSAMPLE;
-#define GETJSAMPLE(value)  ((int) (value))
-
-#else /* not HAVE_UNSIGNED_CHAR */
-
-typedef char JSAMPLE;
-#ifdef CHAR_IS_UNSIGNED
-#define GETJSAMPLE(value)  ((int) (value))
-#else
-#define GETJSAMPLE(value)  ((int) (value) & 0xFF)
-#endif /* CHAR_IS_UNSIGNED */
-
-#endif /* HAVE_UNSIGNED_CHAR */
-
-#define MAXJSAMPLE	255
-#define CENTERJSAMPLE	128
-
-#endif /* BITS_IN_JSAMPLE == 8 */
-
-
-#if BITS_IN_JSAMPLE == 12
-/* JSAMPLE should be the smallest type that will hold the values 0..4095.
- * On nearly all machines "short" will do nicely.
- */
-
-typedef short JSAMPLE;
-#define GETJSAMPLE(value)  ((int) (value))
-
-#define MAXJSAMPLE	4095
-#define CENTERJSAMPLE	2048
-
-#endif /* BITS_IN_JSAMPLE == 12 */
-
-
-/* Representation of a DCT frequency coefficient.
- * This should be a signed value of at least 16 bits; "short" is usually OK.
- * Again, we allocate large arrays of these, but you can change to int
- * if you have memory to burn and "short" is really slow.
- */
-
-typedef short JCOEF;
-
-
-/* Compressed datastreams are represented as arrays of JOCTET.
- * These must be EXACTLY 8 bits wide, at least once they are written to
- * external storage.  Note that when using the stdio data source/destination
- * managers, this is also the data type passed to fread/fwrite.
- */
-
-#ifdef HAVE_UNSIGNED_CHAR
-
-typedef unsigned char JOCTET;
-#define GETJOCTET(value)  (value)
-
-#else /* not HAVE_UNSIGNED_CHAR */
-
-typedef char JOCTET;
-#ifdef CHAR_IS_UNSIGNED
-#define GETJOCTET(value)  (value)
-#else
-#define GETJOCTET(value)  ((value) & 0xFF)
-#endif /* CHAR_IS_UNSIGNED */
-
-#endif /* HAVE_UNSIGNED_CHAR */
-
-
-/* These typedefs are used for various table entries and so forth.
- * They must be at least as wide as specified; but making them too big
- * won't cost a huge amount of memory, so we don't provide special
- * extraction code like we did for JSAMPLE.  (In other words, these
- * typedefs live at a different point on the speed/space tradeoff curve.)
- */
-
-/* UINT8 must hold at least the values 0..255. */
-
-#ifdef HAVE_UNSIGNED_CHAR
-typedef unsigned char UINT8;
-#else /* not HAVE_UNSIGNED_CHAR */
-#ifdef CHAR_IS_UNSIGNED
-typedef char UINT8;
-#else /* not CHAR_IS_UNSIGNED */
-typedef short UINT8;
-#endif /* CHAR_IS_UNSIGNED */
-#endif /* HAVE_UNSIGNED_CHAR */
-
-/* UINT16 must hold at least the values 0..65535. */
-
-#ifdef HAVE_UNSIGNED_SHORT
-typedef unsigned short UINT16;
-#else /* not HAVE_UNSIGNED_SHORT */
-typedef unsigned int UINT16;
-#endif /* HAVE_UNSIGNED_SHORT */
-
-/* INT16 must hold at least the values -32768..32767. */
-
-#ifndef XMD_H			/* X11/xmd.h correctly defines INT16 */
-typedef short INT16;
-#endif
-
-/* INT32 must hold at least signed 32-bit values. */
-
-#ifndef XMD_H			/* X11/xmd.h correctly defines INT32 */
-typedef long INT32;
-#endif
-
-/* Datatype used for image dimensions.  The JPEG standard only supports
- * images up to 64K*64K due to 16-bit fields in SOF markers.  Therefore
- * "unsigned int" is sufficient on all machines.  However, if you need to
- * handle larger images and you don't mind deviating from the spec, you
- * can change this datatype.
- */
-
-typedef unsigned int JDIMENSION;
-
-#define JPEG_MAX_DIMENSION  65500L  /* a tad under 64K to prevent overflows */
-
-
-/* These macros are used in all function definitions and extern declarations.
- * You could modify them if you need to change function linkage conventions;
- * in particular, you'll need to do that to make the library a Windows DLL.
- * Another application is to make all functions global for use with debuggers
- * or code profilers that require it.
- */
-
-/* a function called through method pointers: */
-#define METHODDEF(type)		static type
-/* a function used only in its module: */
-#define LOCAL(type)		static type
-/* a function referenced thru EXTERNs: */
-#define GLOBAL(type)		type
-/* a reference to a GLOBAL function: */
-#define EXTERN(type)		extern type
-
-
-/* This macro is used to declare a "method", that is, a function pointer.
- * We want to supply prototype parameters if the compiler can cope.
- * Note that the arglist parameter must be parenthesized!
- * Again, you can customize this if you need special linkage keywords.
- */
-
-#ifdef HAVE_PROTOTYPES
-#define JMETHOD(type,methodname,arglist)  type (*methodname) arglist
-#else
-#define JMETHOD(type,methodname,arglist)  type (*methodname) ()
-#endif
-
-
-/* Here is the pseudo-keyword for declaring pointers that must be "far"
- * on 80x86 machines.  Most of the specialized coding for 80x86 is handled
- * by just saying "FAR *" where such a pointer is needed.  In a few places
- * explicit coding is needed; see uses of the NEED_FAR_POINTERS symbol.
- */
-
-#ifdef NEED_FAR_POINTERS
-#define FAR  far
-#else
-#define FAR
-#endif
-
-
-/*
- * On a few systems, type boolean and/or its values FALSE, TRUE may appear
- * in standard header files.  Or you may have conflicts with application-
- * specific header files that you want to include together with these files.
- * Defining HAVE_BOOLEAN before including jpeglib.h should make it work.
- */
-
-#ifndef HAVE_BOOLEAN
-typedef int boolean;
-#endif
-#ifndef FALSE			/* in case these macros already exist */
-#define FALSE	0		/* values of boolean */
-#endif
-#ifndef TRUE
-#define TRUE	1
-#endif
-
-
-/*
- * The remaining options affect code selection within the JPEG library,
- * but they don't need to be visible to most applications using the library.
- * To minimize application namespace pollution, the symbols won't be
- * defined unless JPEG_INTERNALS or JPEG_INTERNAL_OPTIONS has been defined.
- */
-
-#ifdef JPEG_INTERNALS
-#define JPEG_INTERNAL_OPTIONS
-#endif
-
-#ifdef JPEG_INTERNAL_OPTIONS
-
-
-/*
- * These defines indicate whether to include various optional functions.
- * Undefining some of these symbols will produce a smaller but less capable
- * library.  Note that you can leave certain source files out of the
- * compilation/linking process if you've #undef'd the corresponding symbols.
- * (You may HAVE to do that if your compiler doesn't like null source files.)
- */
-
-/* Arithmetic coding is unsupported for legal reasons.  Complaints to IBM. */
-
-/* Capability options common to encoder and decoder: */
-
-#define DCT_ISLOW_SUPPORTED	/* slow but accurate integer algorithm */
-#define DCT_IFAST_SUPPORTED	/* faster, less accurate integer method */
-#define DCT_FLOAT_SUPPORTED	/* floating-point: accurate, fast on fast HW */
-
-/* Encoder capability options: */
-
-#undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
-#define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
-#define C_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
-#define ENTROPY_OPT_SUPPORTED	    /* Optimization of entropy coding parms? */
-/* Note: if you selected 12-bit data precision, it is dangerous to turn off
- * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
- * precision, so jchuff.c normally uses entropy optimization to compute
- * usable tables for higher precision.  If you don't want to do optimization,
- * you'll have to supply different default Huffman tables.
- * The exact same statements apply for progressive JPEG: the default tables
- * don't work for progressive mode.  (This may get fixed, however.)
- */
-#define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */
-
-/* Decoder capability options: */
-
-#undef  D_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
-#define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
-#define D_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
-#define SAVE_MARKERS_SUPPORTED	    /* jpeg_save_markers() needed? */
-#define BLOCK_SMOOTHING_SUPPORTED   /* Block smoothing? (Progressive only) */
-#define IDCT_SCALING_SUPPORTED	    /* Output rescaling via IDCT? */
-#undef  UPSAMPLE_SCALING_SUPPORTED  /* Output rescaling at upsample stage? */
-#define UPSAMPLE_MERGING_SUPPORTED  /* Fast path for sloppy upsampling? */
-#define QUANT_1PASS_SUPPORTED	    /* 1-pass color quantization? */
-#define QUANT_2PASS_SUPPORTED	    /* 2-pass color quantization? */
-
-/* more capability options later, no doubt */
-
-
-/*
- * Ordering of RGB data in scanlines passed to or from the application.
- * If your application wants to deal with data in the order B,G,R, just
- * change these macros.  You can also deal with formats such as R,G,B,X
- * (one extra byte per pixel) by changing RGB_PIXELSIZE.  Note that changing
- * the offsets will also change the order in which colormap data is organized.
- * RESTRICTIONS:
- * 1. The sample applications cjpeg,djpeg do NOT support modified RGB formats.
- * 2. These macros only affect RGB<=>YCbCr color conversion, so they are not
- *    useful if you are using JPEG color spaces other than YCbCr or grayscale.
- * 3. The color quantizer modules will not behave desirably if RGB_PIXELSIZE
- *    is not 3 (they don't understand about dummy color components!).  So you
- *    can't use color quantization if you change that value.
- */
-
-#define RGB_RED		0	/* Offset of Red in an RGB scanline element */
-#define RGB_GREEN	1	/* Offset of Green */
-#define RGB_BLUE	2	/* Offset of Blue */
-#define RGB_PIXELSIZE	3	/* JSAMPLEs per RGB scanline element */
-
-
-/* Definitions for speed-related optimizations. */
-
-
-/* If your compiler supports inline functions, define INLINE
- * as the inline keyword; otherwise define it as empty.
- */
-
-#ifndef INLINE
-#ifdef __GNUC__			/* for instance, GNU C knows about inline */
-#define INLINE __inline__
-#endif
-#ifndef INLINE
-#define INLINE			/* default is to define it as empty */
-#endif
-#endif
-
-
-/* On some machines (notably 68000 series) "int" is 32 bits, but multiplying
- * two 16-bit shorts is faster than multiplying two ints.  Define MULTIPLIER
- * as short on such a machine.  MULTIPLIER must be at least 16 bits wide.
- */
-
-#ifndef MULTIPLIER
-#define MULTIPLIER  int		/* type for fastest integer multiply */
-#endif
-
-
-/* FAST_FLOAT should be either float or double, whichever is done faster
- * by your compiler.  (Note that this type is only used in the floating point
- * DCT routines, so it only matters if you've defined DCT_FLOAT_SUPPORTED.)
- * Typically, float is faster in ANSI C compilers, while double is faster in
- * pre-ANSI compilers (because they insist on converting to double anyway).
- * The code below therefore chooses float if we have ANSI-style prototypes.
- */
-
-#ifndef FAST_FLOAT
-#ifdef HAVE_PROTOTYPES
-#define FAST_FLOAT  float
-#else
-#define FAST_FLOAT  double
-#endif
-#endif
-
-#endif /* JPEG_INTERNAL_OPTIONS */
diff --git a/jpeglib.h b/jpeglib.h
deleted file mode 100644
index d1be8dd..0000000
--- a/jpeglib.h
+++ /dev/null
@@ -1,1096 +0,0 @@
-/*
- * jpeglib.h
- *
- * Copyright (C) 1991-1998, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file defines the application interface for the JPEG library.
- * Most applications using the library need only include this file,
- * and perhaps jerror.h if they want to know the exact error codes.
- */
-
-#ifndef JPEGLIB_H
-#define JPEGLIB_H
-
-/*
- * First we include the configuration files that record how this
- * installation of the JPEG library is set up.  jconfig.h can be
- * generated automatically for many systems.  jmorecfg.h contains
- * manual configuration options that most people need not worry about.
- */
-
-#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
-#include "jconfig.h"		/* widely used configuration options */
-#endif
-#include "jmorecfg.h"		/* seldom changed options */
-
-
-/* Version ID for the JPEG library.
- * Might be useful for tests like "#if JPEG_LIB_VERSION >= 60".
- */
-
-#define JPEG_LIB_VERSION  62	/* Version 6b */
-
-
-/* Various constants determining the sizes of things.
- * All of these are specified by the JPEG standard, so don't change them
- * if you want to be compatible.
- */
-
-#define DCTSIZE		    8	/* The basic DCT block is 8x8 samples */
-#define DCTSIZE2	    64	/* DCTSIZE squared; # of elements in a block */
-#define NUM_QUANT_TBLS      4	/* Quantization tables are numbered 0..3 */
-#define NUM_HUFF_TBLS       4	/* Huffman tables are numbered 0..3 */
-#define NUM_ARITH_TBLS      16	/* Arith-coding tables are numbered 0..15 */
-#define MAX_COMPS_IN_SCAN   4	/* JPEG limit on # of components in one scan */
-#define MAX_SAMP_FACTOR     4	/* JPEG limit on sampling factors */
-/* Unfortunately, some bozo at Adobe saw no reason to be bound by the standard;
- * the PostScript DCT filter can emit files with many more than 10 blocks/MCU.
- * If you happen to run across such a file, you can up D_MAX_BLOCKS_IN_MCU
- * to handle it.  We even let you do this from the jconfig.h file.  However,
- * we strongly discourage changing C_MAX_BLOCKS_IN_MCU; just because Adobe
- * sometimes emits noncompliant files doesn't mean you should too.
- */
-#define C_MAX_BLOCKS_IN_MCU   10 /* compressor's limit on blocks per MCU */
-#ifndef D_MAX_BLOCKS_IN_MCU
-#define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
-#endif
-
-
-/* Data structures for images (arrays of samples and of DCT coefficients).
- * On 80x86 machines, the image arrays are too big for near pointers,
- * but the pointer arrays can fit in near memory.
- */
-
-typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
-typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
-typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
-
-typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
-typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
-typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
-typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
-
-typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */
-
-
-/* Types for JPEG compression parameters and working tables. */
-
-
-/* DCT coefficient quantization tables. */
-
-typedef struct {
-  /* This array gives the coefficient quantizers in natural array order
-   * (not the zigzag order in which they are stored in a JPEG DQT marker).
-   * CAUTION: IJG versions prior to v6a kept this array in zigzag order.
-   */
-  UINT16 quantval[DCTSIZE2];	/* quantization step for each coefficient */
-  /* This field is used only during compression.  It's initialized FALSE when
-   * the table is created, and set TRUE when it's been output to the file.
-   * You could suppress output of a table by setting this to TRUE.
-   * (See jpeg_suppress_tables for an example.)
-   */
-  boolean sent_table;		/* TRUE when table has been output */
-} JQUANT_TBL;
-
-
-/* Huffman coding tables. */
-
-typedef struct {
-  /* These two fields directly represent the contents of a JPEG DHT marker */
-  UINT8 bits[17];		/* bits[k] = # of symbols with codes of */
-				/* length k bits; bits[0] is unused */
-  UINT8 huffval[256];		/* The symbols, in order of incr code length */
-  /* This field is used only during compression.  It's initialized FALSE when
-   * the table is created, and set TRUE when it's been output to the file.
-   * You could suppress output of a table by setting this to TRUE.
-   * (See jpeg_suppress_tables for an example.)
-   */
-  boolean sent_table;		/* TRUE when table has been output */
-} JHUFF_TBL;
-
-
-/* Basic info about one component (color channel). */
-
-typedef struct {
-  /* These values are fixed over the whole image. */
-  /* For compression, they must be supplied by parameter setup; */
-  /* for decompression, they are read from the SOF marker. */
-  int component_id;		/* identifier for this component (0..255) */
-  int component_index;		/* its index in SOF or cinfo->comp_info[] */
-  int h_samp_factor;		/* horizontal sampling factor (1..4) */
-  int v_samp_factor;		/* vertical sampling factor (1..4) */
-  int quant_tbl_no;		/* quantization table selector (0..3) */
-  /* These values may vary between scans. */
-  /* For compression, they must be supplied by parameter setup; */
-  /* for decompression, they are read from the SOS marker. */
-  /* The decompressor output side may not use these variables. */
-  int dc_tbl_no;		/* DC entropy table selector (0..3) */
-  int ac_tbl_no;		/* AC entropy table selector (0..3) */
-  
-  /* Remaining fields should be treated as private by applications. */
-  
-  /* These values are computed during compression or decompression startup: */
-  /* Component's size in DCT blocks.
-   * Any dummy blocks added to complete an MCU are not counted; therefore
-   * these values do not depend on whether a scan is interleaved or not.
-   */
-  JDIMENSION width_in_blocks;
-  JDIMENSION height_in_blocks;
-  /* Size of a DCT block in samples.  Always DCTSIZE for compression.
-   * For decompression this is the size of the output from one DCT block,
-   * reflecting any scaling we choose to apply during the IDCT step.
-   * Values of 1,2,4,8 are likely to be supported.  Note that different
-   * components may receive different IDCT scalings.
-   */
-  int DCT_scaled_size;
-  /* The downsampled dimensions are the component's actual, unpadded number
-   * of samples at the main buffer (preprocessing/compression interface), thus
-   * downsampled_width = ceil(image_width * Hi/Hmax)
-   * and similarly for height.  For decompression, IDCT scaling is included, so
-   * downsampled_width = ceil(image_width * Hi/Hmax * DCT_scaled_size/DCTSIZE)
-   */
-  JDIMENSION downsampled_width;	 /* actual width in samples */
-  JDIMENSION downsampled_height; /* actual height in samples */
-  /* This flag is used only for decompression.  In cases where some of the
-   * components will be ignored (eg grayscale output from YCbCr image),
-   * we can skip most computations for the unused components.
-   */
-  boolean component_needed;	/* do we need the value of this component? */
-
-  /* These values are computed before starting a scan of the component. */
-  /* The decompressor output side may not use these variables. */
-  int MCU_width;		/* number of blocks per MCU, horizontally */
-  int MCU_height;		/* number of blocks per MCU, vertically */
-  int MCU_blocks;		/* MCU_width * MCU_height */
-  int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
-  int last_col_width;		/* # of non-dummy blocks across in last MCU */
-  int last_row_height;		/* # of non-dummy blocks down in last MCU */
-
-  /* Saved quantization table for component; NULL if none yet saved.
-   * See jdinput.c comments about the need for this information.
-   * This field is currently used only for decompression.
-   */
-  JQUANT_TBL * quant_table;
-
-  /* Private per-component storage for DCT or IDCT subsystem. */
-  void * dct_table;
-} jpeg_component_info;
-
-
-/* The script for encoding a multiple-scan file is an array of these: */
-
-typedef struct {
-  int comps_in_scan;		/* number of components encoded in this scan */
-  int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
-  int Ss, Se;			/* progressive JPEG spectral selection parms */
-  int Ah, Al;			/* progressive JPEG successive approx. parms */
-} jpeg_scan_info;
-
-/* The decompressor can save APPn and COM markers in a list of these: */
-
-typedef struct jpeg_marker_struct FAR * jpeg_saved_marker_ptr;
-
-struct jpeg_marker_struct {
-  jpeg_saved_marker_ptr next;	/* next in list, or NULL */
-  UINT8 marker;			/* marker code: JPEG_COM, or JPEG_APP0+n */
-  unsigned int original_length;	/* # bytes of data in the file */
-  unsigned int data_length;	/* # bytes of data saved at data[] */
-  JOCTET FAR * data;		/* the data contained in the marker */
-  /* the marker length word is not counted in data_length or original_length */
-};
-
-/* Known color spaces. */
-
-typedef enum {
-	JCS_UNKNOWN,		/* error/unspecified */
-	JCS_GRAYSCALE,		/* monochrome */
-	JCS_RGB,		/* red/green/blue */
-	JCS_YCbCr,		/* Y/Cb/Cr (also known as YUV) */
-	JCS_CMYK,		/* C/M/Y/K */
-	JCS_YCCK		/* Y/Cb/Cr/K */
-} J_COLOR_SPACE;
-
-/* DCT/IDCT algorithm options. */
-
-typedef enum {
-	JDCT_ISLOW,		/* slow but accurate integer algorithm */
-	JDCT_IFAST,		/* faster, less accurate integer method */
-	JDCT_FLOAT		/* floating-point: accurate, fast on fast HW */
-} J_DCT_METHOD;
-
-#ifndef JDCT_DEFAULT		/* may be overridden in jconfig.h */
-#define JDCT_DEFAULT  JDCT_ISLOW
-#endif
-#ifndef JDCT_FASTEST		/* may be overridden in jconfig.h */
-#define JDCT_FASTEST  JDCT_IFAST
-#endif
-
-/* Dithering options for decompression. */
-
-typedef enum {
-	JDITHER_NONE,		/* no dithering */
-	JDITHER_ORDERED,	/* simple ordered dither */
-	JDITHER_FS		/* Floyd-Steinberg error diffusion dither */
-} J_DITHER_MODE;
-
-
-/* Common fields between JPEG compression and decompression master structs. */
-
-#define jpeg_common_fields \
-  struct jpeg_error_mgr * err;	/* Error handler module */\
-  struct jpeg_memory_mgr * mem;	/* Memory manager module */\
-  struct jpeg_progress_mgr * progress; /* Progress monitor, or NULL if none */\
-  void * client_data;		/* Available for use by application */\
-  boolean is_decompressor;	/* So common code can tell which is which */\
-  int global_state		/* For checking call sequence validity */
-
-/* Routines that are to be used by both halves of the library are declared
- * to receive a pointer to this structure.  There are no actual instances of
- * jpeg_common_struct, only of jpeg_compress_struct and jpeg_decompress_struct.
- */
-struct jpeg_common_struct {
-  jpeg_common_fields;		/* Fields common to both master struct types */
-  /* Additional fields follow in an actual jpeg_compress_struct or
-   * jpeg_decompress_struct.  All three structs must agree on these
-   * initial fields!  (This would be a lot cleaner in C++.)
-   */
-};
-
-typedef struct jpeg_common_struct * j_common_ptr;
-typedef struct jpeg_compress_struct * j_compress_ptr;
-typedef struct jpeg_decompress_struct * j_decompress_ptr;
-
-
-/* Master record for a compression instance */
-
-struct jpeg_compress_struct {
-  jpeg_common_fields;		/* Fields shared with jpeg_decompress_struct */
-
-  /* Destination for compressed data */
-  struct jpeg_destination_mgr * dest;
-
-  /* Description of source image --- these fields must be filled in by
-   * outer application before starting compression.  in_color_space must
-   * be correct before you can even call jpeg_set_defaults().
-   */
-
-  JDIMENSION image_width;	/* input image width */
-  JDIMENSION image_height;	/* input image height */
-  int input_components;		/* # of color components in input image */
-  J_COLOR_SPACE in_color_space;	/* colorspace of input image */
-
-  double input_gamma;		/* image gamma of input image */
-
-  /* Compression parameters --- these fields must be set before calling
-   * jpeg_start_compress().  We recommend calling jpeg_set_defaults() to
-   * initialize everything to reasonable defaults, then changing anything
-   * the application specifically wants to change.  That way you won't get
-   * burnt when new parameters are added.  Also note that there are several
-   * helper routines to simplify changing parameters.
-   */
-
-  int data_precision;		/* bits of precision in image data */
-
-  int num_components;		/* # of color components in JPEG image */
-  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
-
-  jpeg_component_info * comp_info;
-  /* comp_info[i] describes component that appears i'th in SOF */
-  
-  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
-  /* ptrs to coefficient quantization tables, or NULL if not defined */
-  
-  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
-  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
-  /* ptrs to Huffman coding tables, or NULL if not defined */
-  
-  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
-  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
-  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
-
-  int num_scans;		/* # of entries in scan_info array */
-  const jpeg_scan_info * scan_info; /* script for multi-scan file, or NULL */
-  /* The default value of scan_info is NULL, which causes a single-scan
-   * sequential JPEG file to be emitted.  To create a multi-scan file,
-   * set num_scans and scan_info to point to an array of scan definitions.
-   */
-
-  boolean raw_data_in;		/* TRUE=caller supplies downsampled data */
-  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
-  boolean optimize_coding;	/* TRUE=optimize entropy encoding parms */
-  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
-  int smoothing_factor;		/* 1..100, or 0 for no input smoothing */
-  J_DCT_METHOD dct_method;	/* DCT algorithm selector */
-
-  /* The restart interval can be specified in absolute MCUs by setting
-   * restart_interval, or in MCU rows by setting restart_in_rows
-   * (in which case the correct restart_interval will be figured
-   * for each scan).
-   */
-  unsigned int restart_interval; /* MCUs per restart, or 0 for no restart */
-  int restart_in_rows;		/* if > 0, MCU rows per restart interval */
-
-  /* Parameters controlling emission of special markers. */
-
-  boolean write_JFIF_header;	/* should a JFIF marker be written? */
-  UINT8 JFIF_major_version;	/* What to write for the JFIF version number */
-  UINT8 JFIF_minor_version;
-  /* These three values are not used by the JPEG code, merely copied */
-  /* into the JFIF APP0 marker.  density_unit can be 0 for unknown, */
-  /* 1 for dots/inch, or 2 for dots/cm.  Note that the pixel aspect */
-  /* ratio is defined by X_density/Y_density even when density_unit=0. */
-  UINT8 density_unit;		/* JFIF code for pixel size units */
-  UINT16 X_density;		/* Horizontal pixel density */
-  UINT16 Y_density;		/* Vertical pixel density */
-  boolean write_Adobe_marker;	/* should an Adobe marker be written? */
-  
-  /* State variable: index of next scanline to be written to
-   * jpeg_write_scanlines().  Application may use this to control its
-   * processing loop, e.g., "while (next_scanline < image_height)".
-   */
-
-  JDIMENSION next_scanline;	/* 0 .. image_height-1  */
-
-  /* Remaining fields are known throughout compressor, but generally
-   * should not be touched by a surrounding application.
-   */
-
-  /*
-   * These fields are computed during compression startup
-   */
-  boolean progressive_mode;	/* TRUE if scan script uses progressive mode */
-  int max_h_samp_factor;	/* largest h_samp_factor */
-  int max_v_samp_factor;	/* largest v_samp_factor */
-
-  JDIMENSION total_iMCU_rows;	/* # of iMCU rows to be input to coef ctlr */
-  /* The coefficient controller receives data in units of MCU rows as defined
-   * for fully interleaved scans (whether the JPEG file is interleaved or not).
-   * There are v_samp_factor * DCTSIZE sample rows of each component in an
-   * "iMCU" (interleaved MCU) row.
-   */
-  
-  /*
-   * These fields are valid during any one scan.
-   * They describe the components and MCUs actually appearing in the scan.
-   */
-  int comps_in_scan;		/* # of JPEG components in this scan */
-  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
-  /* *cur_comp_info[i] describes component that appears i'th in SOS */
-  
-  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
-  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
-  
-  int blocks_in_MCU;		/* # of DCT blocks per MCU */
-  int MCU_membership[C_MAX_BLOCKS_IN_MCU];
-  /* MCU_membership[i] is index in cur_comp_info of component owning */
-  /* i'th block in an MCU */
-
-  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
-
-  /*
-   * Links to compression subobjects (methods and private variables of modules)
-   */
-  struct jpeg_comp_master * master;
-  struct jpeg_c_main_controller * main;
-  struct jpeg_c_prep_controller * prep;
-  struct jpeg_c_coef_controller * coef;
-  struct jpeg_marker_writer * marker;
-  struct jpeg_color_converter * cconvert;
-  struct jpeg_downsampler * downsample;
-  struct jpeg_forward_dct * fdct;
-  struct jpeg_entropy_encoder * entropy;
-  jpeg_scan_info * script_space; /* workspace for jpeg_simple_progression */
-  int script_space_size;
-};
-
-
-/* Master record for a decompression instance */
-
-struct jpeg_decompress_struct {
-  jpeg_common_fields;		/* Fields shared with jpeg_compress_struct */
-
-  /* Source of compressed data */
-  struct jpeg_source_mgr * src;
-
-  /* Basic description of image --- filled in by jpeg_read_header(). */
-  /* Application may inspect these values to decide how to process image. */
-
-  JDIMENSION image_width;	/* nominal image width (from SOF marker) */
-  JDIMENSION image_height;	/* nominal image height */
-  int num_components;		/* # of color components in JPEG image */
-  J_COLOR_SPACE jpeg_color_space; /* colorspace of JPEG image */
-
-  /* Decompression processing parameters --- these fields must be set before
-   * calling jpeg_start_decompress().  Note that jpeg_read_header() initializes
-   * them to default values.
-   */
-
-  J_COLOR_SPACE out_color_space; /* colorspace for output */
-
-  unsigned int scale_num, scale_denom; /* fraction by which to scale image */
-
-  double output_gamma;		/* image gamma wanted in output */
-
-  boolean buffered_image;	/* TRUE=multiple output passes */
-  boolean raw_data_out;		/* TRUE=downsampled data wanted */
-
-  J_DCT_METHOD dct_method;	/* IDCT algorithm selector */
-  boolean do_fancy_upsampling;	/* TRUE=apply fancy upsampling */
-  boolean do_block_smoothing;	/* TRUE=apply interblock smoothing */
-
-  boolean quantize_colors;	/* TRUE=colormapped output wanted */
-  /* the following are ignored if not quantize_colors: */
-  J_DITHER_MODE dither_mode;	/* type of color dithering to use */
-  boolean two_pass_quantize;	/* TRUE=use two-pass color quantization */
-  int desired_number_of_colors;	/* max # colors to use in created colormap */
-  /* these are significant only in buffered-image mode: */
-  boolean enable_1pass_quant;	/* enable future use of 1-pass quantizer */
-  boolean enable_external_quant;/* enable future use of external colormap */
-  boolean enable_2pass_quant;	/* enable future use of 2-pass quantizer */
-
-  /* Description of actual output image that will be returned to application.
-   * These fields are computed by jpeg_start_decompress().
-   * You can also use jpeg_calc_output_dimensions() to determine these values
-   * in advance of calling jpeg_start_decompress().
-   */
-
-  JDIMENSION output_width;	/* scaled image width */
-  JDIMENSION output_height;	/* scaled image height */
-  int out_color_components;	/* # of color components in out_color_space */
-  int output_components;	/* # of color components returned */
-  /* output_components is 1 (a colormap index) when quantizing colors;
-   * otherwise it equals out_color_components.
-   */
-  int rec_outbuf_height;	/* min recommended height of scanline buffer */
-  /* If the buffer passed to jpeg_read_scanlines() is less than this many rows
-   * high, space and time will be wasted due to unnecessary data copying.
-   * Usually rec_outbuf_height will be 1 or 2, at most 4.
-   */
-
-  /* When quantizing colors, the output colormap is described by these fields.
-   * The application can supply a colormap by setting colormap non-NULL before
-   * calling jpeg_start_decompress; otherwise a colormap is created during
-   * jpeg_start_decompress or jpeg_start_output.
-   * The map has out_color_components rows and actual_number_of_colors columns.
-   */
-  int actual_number_of_colors;	/* number of entries in use */
-  JSAMPARRAY colormap;		/* The color map as a 2-D pixel array */
-
-  /* State variables: these variables indicate the progress of decompression.
-   * The application may examine these but must not modify them.
-   */
-
-  /* Row index of next scanline to be read from jpeg_read_scanlines().
-   * Application may use this to control its processing loop, e.g.,
-   * "while (output_scanline < output_height)".
-   */
-  JDIMENSION output_scanline;	/* 0 .. output_height-1  */
-
-  /* Current input scan number and number of iMCU rows completed in scan.
-   * These indicate the progress of the decompressor input side.
-   */
-  int input_scan_number;	/* Number of SOS markers seen so far */
-  JDIMENSION input_iMCU_row;	/* Number of iMCU rows completed */
-
-  /* The "output scan number" is the notional scan being displayed by the
-   * output side.  The decompressor will not allow output scan/row number
-   * to get ahead of input scan/row, but it can fall arbitrarily far behind.
-   */
-  int output_scan_number;	/* Nominal scan number being displayed */
-  JDIMENSION output_iMCU_row;	/* Number of iMCU rows read */
-
-  /* Current progression status.  coef_bits[c][i] indicates the precision
-   * with which component c's DCT coefficient i (in zigzag order) is known.
-   * It is -1 when no data has yet been received, otherwise it is the point
-   * transform (shift) value for the most recent scan of the coefficient
-   * (thus, 0 at completion of the progression).
-   * This pointer is NULL when reading a non-progressive file.
-   */
-  int (*coef_bits)[DCTSIZE2];	/* -1 or current Al value for each coef */
-
-  /* Internal JPEG parameters --- the application usually need not look at
-   * these fields.  Note that the decompressor output side may not use
-   * any parameters that can change between scans.
-   */
-
-  /* Quantization and Huffman tables are carried forward across input
-   * datastreams when processing abbreviated JPEG datastreams.
-   */
-
-  JQUANT_TBL * quant_tbl_ptrs[NUM_QUANT_TBLS];
-  /* ptrs to coefficient quantization tables, or NULL if not defined */
-
-  JHUFF_TBL * dc_huff_tbl_ptrs[NUM_HUFF_TBLS];
-  JHUFF_TBL * ac_huff_tbl_ptrs[NUM_HUFF_TBLS];
-  /* ptrs to Huffman coding tables, or NULL if not defined */
-
-  /* These parameters are never carried across datastreams, since they
-   * are given in SOF/SOS markers or defined to be reset by SOI.
-   */
-
-  int data_precision;		/* bits of precision in image data */
-
-  jpeg_component_info * comp_info;
-  /* comp_info[i] describes component that appears i'th in SOF */
-
-  boolean progressive_mode;	/* TRUE if SOFn specifies progressive mode */
-  boolean arith_code;		/* TRUE=arithmetic coding, FALSE=Huffman */
-
-  UINT8 arith_dc_L[NUM_ARITH_TBLS]; /* L values for DC arith-coding tables */
-  UINT8 arith_dc_U[NUM_ARITH_TBLS]; /* U values for DC arith-coding tables */
-  UINT8 arith_ac_K[NUM_ARITH_TBLS]; /* Kx values for AC arith-coding tables */
-
-  unsigned int restart_interval; /* MCUs per restart interval, or 0 for no restart */
-
-  /* These fields record data obtained from optional markers recognized by
-   * the JPEG library.
-   */
-  boolean saw_JFIF_marker;	/* TRUE iff a JFIF APP0 marker was found */
-  /* Data copied from JFIF marker; only valid if saw_JFIF_marker is TRUE: */
-  UINT8 JFIF_major_version;	/* JFIF version number */
-  UINT8 JFIF_minor_version;
-  UINT8 density_unit;		/* JFIF code for pixel size units */
-  UINT16 X_density;		/* Horizontal pixel density */
-  UINT16 Y_density;		/* Vertical pixel density */
-  boolean saw_Adobe_marker;	/* TRUE iff an Adobe APP14 marker was found */
-  UINT8 Adobe_transform;	/* Color transform code from Adobe marker */
-
-  boolean CCIR601_sampling;	/* TRUE=first samples are cosited */
-
-  /* Aside from the specific data retained from APPn markers known to the
-   * library, the uninterpreted contents of any or all APPn and COM markers
-   * can be saved in a list for examination by the application.
-   */
-  jpeg_saved_marker_ptr marker_list; /* Head of list of saved markers */
-
-  /* Remaining fields are known throughout decompressor, but generally
-   * should not be touched by a surrounding application.
-   */
-
-  /*
-   * These fields are computed during decompression startup
-   */
-  int max_h_samp_factor;	/* largest h_samp_factor */
-  int max_v_samp_factor;	/* largest v_samp_factor */
-
-  int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */
-
-  JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
-  /* The coefficient controller's input and output progress is measured in
-   * units of "iMCU" (interleaved MCU) rows.  These are the same as MCU rows
-   * in fully interleaved JPEG scans, but are used whether the scan is
-   * interleaved or not.  We define an iMCU row as v_samp_factor DCT block
-   * rows of each component.  Therefore, the IDCT output contains
-   * v_samp_factor*DCT_scaled_size sample rows of a component per iMCU row.
-   */
-
-  JSAMPLE * sample_range_limit; /* table for fast range-limiting */
-
-  /*
-   * These fields are valid during any one scan.
-   * They describe the components and MCUs actually appearing in the scan.
-   * Note that the decompressor output side must not use these fields.
-   */
-  int comps_in_scan;		/* # of JPEG components in this scan */
-  jpeg_component_info * cur_comp_info[MAX_COMPS_IN_SCAN];
-  /* *cur_comp_info[i] describes component that appears i'th in SOS */
-
-  JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
-  JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
-
-  int blocks_in_MCU;		/* # of DCT blocks per MCU */
-  int MCU_membership[D_MAX_BLOCKS_IN_MCU];
-  /* MCU_membership[i] is index in cur_comp_info of component owning */
-  /* i'th block in an MCU */
-
-  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
-
-  /* This field is shared between entropy decoder and marker parser.
-   * It is either zero or the code of a JPEG marker that has been
-   * read from the data source, but has not yet been processed.
-   */
-  int unread_marker;
-
-  /*
-   * Links to decompression subobjects (methods, private variables of modules)
-   */
-  struct jpeg_decomp_master * master;
-  struct jpeg_d_main_controller * main;
-  struct jpeg_d_coef_controller * coef;
-  struct jpeg_d_post_controller * post;
-  struct jpeg_input_controller * inputctl;
-  struct jpeg_marker_reader * marker;
-  struct jpeg_entropy_decoder * entropy;
-  struct jpeg_inverse_dct * idct;
-  struct jpeg_upsampler * upsample;
-  struct jpeg_color_deconverter * cconvert;
-  struct jpeg_color_quantizer * cquantize;
-};
-
-
-/* "Object" declarations for JPEG modules that may be supplied or called
- * directly by the surrounding application.
- * As with all objects in the JPEG library, these structs only define the
- * publicly visible methods and state variables of a module.  Additional
- * private fields may exist after the public ones.
- */
-
-
-/* Error handler object */
-
-struct jpeg_error_mgr {
-  /* Error exit handler: does not return to caller */
-  JMETHOD(void, error_exit, (j_common_ptr cinfo));
-  /* Conditionally emit a trace or warning message */
-  JMETHOD(void, emit_message, (j_common_ptr cinfo, int msg_level));
-  /* Routine that actually outputs a trace or error message */
-  JMETHOD(void, output_message, (j_common_ptr cinfo));
-  /* Format a message string for the most recent JPEG error or message */
-  JMETHOD(void, format_message, (j_common_ptr cinfo, char * buffer));
-#define JMSG_LENGTH_MAX  200	/* recommended size of format_message buffer */
-  /* Reset error state variables at start of a new image */
-  JMETHOD(void, reset_error_mgr, (j_common_ptr cinfo));
-  
-  /* The message ID code and any parameters are saved here.
-   * A message can have one string parameter or up to 8 int parameters.
-   */
-  int msg_code;
-#define JMSG_STR_PARM_MAX  80
-  union {
-    int i[8];
-    char s[JMSG_STR_PARM_MAX];
-  } msg_parm;
-  
-  /* Standard state variables for error facility */
-  
-  int trace_level;		/* max msg_level that will be displayed */
-  
-  /* For recoverable corrupt-data errors, we emit a warning message,
-   * but keep going unless emit_message chooses to abort.  emit_message
-   * should count warnings in num_warnings.  The surrounding application
-   * can check for bad data by seeing if num_warnings is nonzero at the
-   * end of processing.
-   */
-  long num_warnings;		/* number of corrupt-data warnings */
-
-  /* These fields point to the table(s) of error message strings.
-   * An application can change the table pointer to switch to a different
-   * message list (typically, to change the language in which errors are
-   * reported).  Some applications may wish to add additional error codes
-   * that will be handled by the JPEG library error mechanism; the second
-   * table pointer is used for this purpose.
-   *
-   * First table includes all errors generated by JPEG library itself.
-   * Error code 0 is reserved for a "no such error string" message.
-   */
-  const char * const * jpeg_message_table; /* Library errors */
-  int last_jpeg_message;    /* Table contains strings 0..last_jpeg_message */
-  /* Second table can be added by application (see cjpeg/djpeg for example).
-   * It contains strings numbered first_addon_message..last_addon_message.
-   */
-  const char * const * addon_message_table; /* Non-library errors */
-  int first_addon_message;	/* code for first string in addon table */
-  int last_addon_message;	/* code for last string in addon table */
-};
-
-
-/* Progress monitor object */
-
-struct jpeg_progress_mgr {
-  JMETHOD(void, progress_monitor, (j_common_ptr cinfo));
-
-  long pass_counter;		/* work units completed in this pass */
-  long pass_limit;		/* total number of work units in this pass */
-  int completed_passes;		/* passes completed so far */
-  int total_passes;		/* total number of passes expected */
-};
-
-
-/* Data destination object for compression */
-
-struct jpeg_destination_mgr {
-  JOCTET * next_output_byte;	/* => next byte to write in buffer */
-  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
-
-  JMETHOD(void, init_destination, (j_compress_ptr cinfo));
-  JMETHOD(boolean, empty_output_buffer, (j_compress_ptr cinfo));
-  JMETHOD(void, term_destination, (j_compress_ptr cinfo));
-};
-
-
-/* Data source object for decompression */
-
-struct jpeg_source_mgr {
-  const JOCTET * next_input_byte; /* => next byte to read from buffer */
-  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */
-
-  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
-  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
-  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
-  JMETHOD(boolean, resync_to_restart, (j_decompress_ptr cinfo, int desired));
-  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
-};
-
-
-/* Memory manager object.
- * Allocates "small" objects (a few K total), "large" objects (tens of K),
- * and "really big" objects (virtual arrays with backing store if needed).
- * The memory manager does not allow individual objects to be freed; rather,
- * each created object is assigned to a pool, and whole pools can be freed
- * at once.  This is faster and more convenient than remembering exactly what
- * to free, especially where malloc()/free() are not too speedy.
- * NB: alloc routines never return NULL.  They exit to error_exit if not
- * successful.
- */
-
-#define JPOOL_PERMANENT	0	/* lasts until master record is destroyed */
-#define JPOOL_IMAGE	1	/* lasts until done with image/datastream */
-#define JPOOL_NUMPOOLS	2
-
-typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
-typedef struct jvirt_barray_control * jvirt_barray_ptr;
-
-
-struct jpeg_memory_mgr {
-  /* Method pointers */
-  JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
-				size_t sizeofobject));
-  JMETHOD(void FAR *, alloc_large, (j_common_ptr cinfo, int pool_id,
-				     size_t sizeofobject));
-  JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
-				     JDIMENSION samplesperrow,
-				     JDIMENSION numrows));
-  JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
-				      JDIMENSION blocksperrow,
-				      JDIMENSION numrows));
-  JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
-						  int pool_id,
-						  boolean pre_zero,
-						  JDIMENSION samplesperrow,
-						  JDIMENSION numrows,
-						  JDIMENSION maxaccess));
-  JMETHOD(jvirt_barray_ptr, request_virt_barray, (j_common_ptr cinfo,
-						  int pool_id,
-						  boolean pre_zero,
-						  JDIMENSION blocksperrow,
-						  JDIMENSION numrows,
-						  JDIMENSION maxaccess));
-  JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
-  JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
-					   jvirt_sarray_ptr ptr,
-					   JDIMENSION start_row,
-					   JDIMENSION num_rows,
-					   boolean writable));
-  JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
-					    jvirt_barray_ptr ptr,
-					    JDIMENSION start_row,
-					    JDIMENSION num_rows,
-					    boolean writable));
-  JMETHOD(void, free_pool, (j_common_ptr cinfo, int pool_id));
-  JMETHOD(void, self_destruct, (j_common_ptr cinfo));
-
-  /* Limit on memory allocation for this JPEG object.  (Note that this is
-   * merely advisory, not a guaranteed maximum; it only affects the space
-   * used for virtual-array buffers.)  May be changed by outer application
-   * after creating the JPEG object.
-   */
-  long max_memory_to_use;
-
-  /* Maximum allocation request accepted by alloc_large. */
-  long max_alloc_chunk;
-};
-
-
-/* Routine signature for application-supplied marker processing methods.
- * Need not pass marker code since it is stored in cinfo->unread_marker.
- */
-typedef JMETHOD(boolean, jpeg_marker_parser_method, (j_decompress_ptr cinfo));
-
-
-/* Declarations for routines called by application.
- * The JPP macro hides prototype parameters from compilers that can't cope.
- * Note JPP requires double parentheses.
- */
-
-#ifdef HAVE_PROTOTYPES
-#define JPP(arglist)	arglist
-#else
-#define JPP(arglist)	()
-#endif
-
-
-/* Short forms of external names for systems with brain-damaged linkers.
- * We shorten external names to be unique in the first six letters, which
- * is good enough for all known systems.
- * (If your compiler itself needs names to be unique in less than 15 
- * characters, you are out of luck.  Get a better compiler.)
- */
-
-#ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jpeg_std_error		jStdError
-#define jpeg_CreateCompress	jCreaCompress
-#define jpeg_CreateDecompress	jCreaDecompress
-#define jpeg_destroy_compress	jDestCompress
-#define jpeg_destroy_decompress	jDestDecompress
-#define jpeg_stdio_dest		jStdDest
-#define jpeg_stdio_src		jStdSrc
-#define jpeg_set_defaults	jSetDefaults
-#define jpeg_set_colorspace	jSetColorspace
-#define jpeg_default_colorspace	jDefColorspace
-#define jpeg_set_quality	jSetQuality
-#define jpeg_set_linear_quality	jSetLQuality
-#define jpeg_add_quant_table	jAddQuantTable
-#define jpeg_quality_scaling	jQualityScaling
-#define jpeg_simple_progression	jSimProgress
-#define jpeg_suppress_tables	jSuppressTables
-#define jpeg_alloc_quant_table	jAlcQTable
-#define jpeg_alloc_huff_table	jAlcHTable
-#define jpeg_start_compress	jStrtCompress
-#define jpeg_write_scanlines	jWrtScanlines
-#define jpeg_finish_compress	jFinCompress
-#define jpeg_write_raw_data	jWrtRawData
-#define jpeg_write_marker	jWrtMarker
-#define jpeg_write_m_header	jWrtMHeader
-#define jpeg_write_m_byte	jWrtMByte
-#define jpeg_write_tables	jWrtTables
-#define jpeg_read_header	jReadHeader
-#define jpeg_start_decompress	jStrtDecompress
-#define jpeg_read_scanlines	jReadScanlines
-#define jpeg_finish_decompress	jFinDecompress
-#define jpeg_read_raw_data	jReadRawData
-#define jpeg_has_multiple_scans	jHasMultScn
-#define jpeg_start_output	jStrtOutput
-#define jpeg_finish_output	jFinOutput
-#define jpeg_input_complete	jInComplete
-#define jpeg_new_colormap	jNewCMap
-#define jpeg_consume_input	jConsumeInput
-#define jpeg_calc_output_dimensions	jCalcDimensions
-#define jpeg_save_markers	jSaveMarkers
-#define jpeg_set_marker_processor	jSetMarker
-#define jpeg_read_coefficients	jReadCoefs
-#define jpeg_write_coefficients	jWrtCoefs
-#define jpeg_copy_critical_parameters	jCopyCrit
-#define jpeg_abort_compress	jAbrtCompress
-#define jpeg_abort_decompress	jAbrtDecompress
-#define jpeg_abort		jAbort
-#define jpeg_destroy		jDestroy
-#define jpeg_resync_to_restart	jResyncRestart
-#endif /* NEED_SHORT_EXTERNAL_NAMES */
-
-
-/* Default error-management setup */
-EXTERN(struct jpeg_error_mgr *) jpeg_std_error
-	JPP((struct jpeg_error_mgr * err));
-
-/* Initialization of JPEG compression objects.
- * jpeg_create_compress() and jpeg_create_decompress() are the exported
- * names that applications should call.  These expand to calls on
- * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
- * passed for version mismatch checking.
- * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
- */
-#define jpeg_create_compress(cinfo) \
-    jpeg_CreateCompress((cinfo), JPEG_LIB_VERSION, \
-			(size_t) sizeof(struct jpeg_compress_struct))
-#define jpeg_create_decompress(cinfo) \
-    jpeg_CreateDecompress((cinfo), JPEG_LIB_VERSION, \
-			  (size_t) sizeof(struct jpeg_decompress_struct))
-EXTERN(void) jpeg_CreateCompress JPP((j_compress_ptr cinfo,
-				      int version, size_t structsize));
-EXTERN(void) jpeg_CreateDecompress JPP((j_decompress_ptr cinfo,
-					int version, size_t structsize));
-/* Destruction of JPEG compression objects */
-EXTERN(void) jpeg_destroy_compress JPP((j_compress_ptr cinfo));
-EXTERN(void) jpeg_destroy_decompress JPP((j_decompress_ptr cinfo));
-
-/* Standard data source and destination managers: stdio streams. */
-/* Caller is responsible for opening the file before and closing after. */
-EXTERN(void) jpeg_stdio_dest JPP((j_compress_ptr cinfo, FILE * outfile));
-EXTERN(void) jpeg_stdio_src JPP((j_decompress_ptr cinfo, FILE * infile));
-
-/* Default parameter setup for compression */
-EXTERN(void) jpeg_set_defaults JPP((j_compress_ptr cinfo));
-/* Compression parameter setup aids */
-EXTERN(void) jpeg_set_colorspace JPP((j_compress_ptr cinfo,
-				      J_COLOR_SPACE colorspace));
-EXTERN(void) jpeg_default_colorspace JPP((j_compress_ptr cinfo));
-EXTERN(void) jpeg_set_quality JPP((j_compress_ptr cinfo, int quality,
-				   boolean force_baseline));
-EXTERN(void) jpeg_set_linear_quality JPP((j_compress_ptr cinfo,
-					  int scale_factor,
-					  boolean force_baseline));
-EXTERN(void) jpeg_add_quant_table JPP((j_compress_ptr cinfo, int which_tbl,
-				       const unsigned int *basic_table,
-				       int scale_factor,
-				       boolean force_baseline));
-EXTERN(int) jpeg_quality_scaling JPP((int quality));
-EXTERN(void) jpeg_simple_progression JPP((j_compress_ptr cinfo));
-EXTERN(void) jpeg_suppress_tables JPP((j_compress_ptr cinfo,
-				       boolean suppress));
-EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table JPP((j_common_ptr cinfo));
-EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table JPP((j_common_ptr cinfo));
-
-/* Main entry points for compression */
-EXTERN(void) jpeg_start_compress JPP((j_compress_ptr cinfo,
-				      boolean write_all_tables));
-EXTERN(JDIMENSION) jpeg_write_scanlines JPP((j_compress_ptr cinfo,
-					     JSAMPARRAY scanlines,
-					     JDIMENSION num_lines));
-EXTERN(void) jpeg_finish_compress JPP((j_compress_ptr cinfo));
-
-/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
-EXTERN(JDIMENSION) jpeg_write_raw_data JPP((j_compress_ptr cinfo,
-					    JSAMPIMAGE data,
-					    JDIMENSION num_lines));
-
-/* Write a special marker.  See libjpeg.doc concerning safe usage. */
-EXTERN(void) jpeg_write_marker
-	JPP((j_compress_ptr cinfo, int marker,
-	     const JOCTET * dataptr, unsigned int datalen));
-/* Same, but piecemeal. */
-EXTERN(void) jpeg_write_m_header
-	JPP((j_compress_ptr cinfo, int marker, unsigned int datalen));
-EXTERN(void) jpeg_write_m_byte
-	JPP((j_compress_ptr cinfo, int val));
-
-/* Alternate compression function: just write an abbreviated table file */
-EXTERN(void) jpeg_write_tables JPP((j_compress_ptr cinfo));
-
-/* Decompression startup: read start of JPEG datastream to see what's there */
-EXTERN(int) jpeg_read_header JPP((j_decompress_ptr cinfo,
-				  boolean require_image));
-/* Return value is one of: */
-#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
-#define JPEG_HEADER_OK		1 /* Found valid image datastream */
-#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
-/* If you pass require_image = TRUE (normal case), you need not check for
- * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
- * JPEG_SUSPENDED is only possible if you use a data source module that can
- * give a suspension return (the stdio source module doesn't).
- */
-
-/* Main entry points for decompression */
-EXTERN(boolean) jpeg_start_decompress JPP((j_decompress_ptr cinfo));
-EXTERN(JDIMENSION) jpeg_read_scanlines JPP((j_decompress_ptr cinfo,
-					    JSAMPARRAY scanlines,
-					    JDIMENSION max_lines));
-EXTERN(boolean) jpeg_finish_decompress JPP((j_decompress_ptr cinfo));
-
-/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
-EXTERN(JDIMENSION) jpeg_read_raw_data JPP((j_decompress_ptr cinfo,
-					   JSAMPIMAGE data,
-					   JDIMENSION max_lines));
-
-/* Additional entry points for buffered-image mode. */
-EXTERN(boolean) jpeg_has_multiple_scans JPP((j_decompress_ptr cinfo));
-EXTERN(boolean) jpeg_start_output JPP((j_decompress_ptr cinfo,
-				       int scan_number));
-EXTERN(boolean) jpeg_finish_output JPP((j_decompress_ptr cinfo));
-EXTERN(boolean) jpeg_input_complete JPP((j_decompress_ptr cinfo));
-EXTERN(void) jpeg_new_colormap JPP((j_decompress_ptr cinfo));
-EXTERN(int) jpeg_consume_input JPP((j_decompress_ptr cinfo));
-/* Return value is one of: */
-/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
-#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
-#define JPEG_REACHED_EOI	2 /* Reached end of image */
-#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
-#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */
-
-/* Precalculate output dimensions for current decompression parameters. */
-EXTERN(void) jpeg_calc_output_dimensions JPP((j_decompress_ptr cinfo));
-
-/* Control saving of COM and APPn markers into marker_list. */
-EXTERN(void) jpeg_save_markers
-	JPP((j_decompress_ptr cinfo, int marker_code,
-	     unsigned int length_limit));
-
-/* Install a special processing method for COM or APPn markers. */
-EXTERN(void) jpeg_set_marker_processor
-	JPP((j_decompress_ptr cinfo, int marker_code,
-	     jpeg_marker_parser_method routine));
-
-/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
-EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients JPP((j_decompress_ptr cinfo));
-EXTERN(void) jpeg_write_coefficients JPP((j_compress_ptr cinfo,
-					  jvirt_barray_ptr * coef_arrays));
-EXTERN(void) jpeg_copy_critical_parameters JPP((j_decompress_ptr srcinfo,
-						j_compress_ptr dstinfo));
-
-/* If you choose to abort compression or decompression before completing
- * jpeg_finish_(de)compress, then you need to clean up to release memory,
- * temporary files, etc.  You can just call jpeg_destroy_(de)compress
- * if you're done with the JPEG object, but if you want to clean it up and
- * reuse it, call this:
- */
-EXTERN(void) jpeg_abort_compress JPP((j_compress_ptr cinfo));
-EXTERN(void) jpeg_abort_decompress JPP((j_decompress_ptr cinfo));
-
-/* Generic versions of jpeg_abort and jpeg_destroy that work on either
- * flavor of JPEG object.  These may be more convenient in some places.
- */
-EXTERN(void) jpeg_abort JPP((j_common_ptr cinfo));
-EXTERN(void) jpeg_destroy JPP((j_common_ptr cinfo));
-
-/* Default restart-marker-resync procedure for use by data source modules */
-EXTERN(boolean) jpeg_resync_to_restart JPP((j_decompress_ptr cinfo,
-					    int desired));
-
-
-/* These marker codes are exported since applications and data source modules
- * are likely to want to use them.
- */
-
-#define JPEG_RST0	0xD0	/* RST0 marker code */
-#define JPEG_EOI	0xD9	/* EOI marker code */
-#define JPEG_APP0	0xE0	/* APP0 marker code */
-#define JPEG_COM	0xFE	/* COM marker code */
-
-
-/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
- * for structure definitions that are never filled in, keep it quiet by
- * supplying dummy definitions for the various substructures.
- */
-
-#ifdef INCOMPLETE_TYPES_BROKEN
-#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
-struct jvirt_sarray_control { long dummy; };
-struct jvirt_barray_control { long dummy; };
-struct jpeg_comp_master { long dummy; };
-struct jpeg_c_main_controller { long dummy; };
-struct jpeg_c_prep_controller { long dummy; };
-struct jpeg_c_coef_controller { long dummy; };
-struct jpeg_marker_writer { long dummy; };
-struct jpeg_color_converter { long dummy; };
-struct jpeg_downsampler { long dummy; };
-struct jpeg_forward_dct { long dummy; };
-struct jpeg_entropy_encoder { long dummy; };
-struct jpeg_decomp_master { long dummy; };
-struct jpeg_d_main_controller { long dummy; };
-struct jpeg_d_coef_controller { long dummy; };
-struct jpeg_d_post_controller { long dummy; };
-struct jpeg_input_controller { long dummy; };
-struct jpeg_marker_reader { long dummy; };
-struct jpeg_entropy_decoder { long dummy; };
-struct jpeg_inverse_dct { long dummy; };
-struct jpeg_upsampler { long dummy; };
-struct jpeg_color_deconverter { long dummy; };
-struct jpeg_color_quantizer { long dummy; };
-#endif /* JPEG_INTERNALS */
-#endif /* INCOMPLETE_TYPES_BROKEN */
-
-
-/*
- * The JPEG library modules define JPEG_INTERNALS before including this file.
- * The internal structure declarations are read only when that is true.
- * Applications using the library should not include jpegint.h, but may wish
- * to include jerror.h.
- */
-
-#ifdef JPEG_INTERNALS
-#include "jpegint.h"		/* fetch private declarations */
-#include "jerror.h"		/* fetch error codes too */
-#endif
-
-#endif /* JPEGLIB_H */
diff --git a/jutils.c b/jutils.c
deleted file mode 100644
index d18a955..0000000
--- a/jutils.c
+++ /dev/null
@@ -1,179 +0,0 @@
-/*
- * jutils.c
- *
- * Copyright (C) 1991-1996, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file contains tables and miscellaneous utility routines needed
- * for both compression and decompression.
- * Note we prefix all global names with "j" to minimize conflicts with
- * a surrounding application.
- */
-
-#define JPEG_INTERNALS
-#include "jinclude.h"
-#include "jpeglib.h"
-
-
-/*
- * jpeg_zigzag_order[i] is the zigzag-order position of the i'th element
- * of a DCT block read in natural order (left to right, top to bottom).
- */
-
-#if 0				/* This table is not actually needed in v6a */
-
-const int jpeg_zigzag_order[DCTSIZE2] = {
-   0,  1,  5,  6, 14, 15, 27, 28,
-   2,  4,  7, 13, 16, 26, 29, 42,
-   3,  8, 12, 17, 25, 30, 41, 43,
-   9, 11, 18, 24, 31, 40, 44, 53,
-  10, 19, 23, 32, 39, 45, 52, 54,
-  20, 22, 33, 38, 46, 51, 55, 60,
-  21, 34, 37, 47, 50, 56, 59, 61,
-  35, 36, 48, 49, 57, 58, 62, 63
-};
-
-#endif
-
-/*
- * jpeg_natural_order[i] is the natural-order position of the i'th element
- * of zigzag order.
- *
- * When reading corrupted data, the Huffman decoders could attempt
- * to reference an entry beyond the end of this array (if the decoded
- * zero run length reaches past the end of the block).  To prevent
- * wild stores without adding an inner-loop test, we put some extra
- * "63"s after the real entries.  This will cause the extra coefficient
- * to be stored in location 63 of the block, not somewhere random.
- * The worst case would be a run-length of 15, which means we need 16
- * fake entries.
- */
-
-const int jpeg_natural_order[DCTSIZE2+16] = {
-  0,  1,  8, 16,  9,  2,  3, 10,
- 17, 24, 32, 25, 18, 11,  4,  5,
- 12, 19, 26, 33, 40, 48, 41, 34,
- 27, 20, 13,  6,  7, 14, 21, 28,
- 35, 42, 49, 56, 57, 50, 43, 36,
- 29, 22, 15, 23, 30, 37, 44, 51,
- 58, 59, 52, 45, 38, 31, 39, 46,
- 53, 60, 61, 54, 47, 55, 62, 63,
- 63, 63, 63, 63, 63, 63, 63, 63, /* extra entries for safety in decoder */
- 63, 63, 63, 63, 63, 63, 63, 63
-};
-
-
-/*
- * Arithmetic utilities
- */
-
-GLOBAL(long)
-jdiv_round_up (long a, long b)
-/* Compute a/b rounded up to next integer, ie, ceil(a/b) */
-/* Assumes a >= 0, b > 0 */
-{
-  return (a + b - 1L) / b;
-}
-
-
-GLOBAL(long)
-jround_up (long a, long b)
-/* Compute a rounded up to next multiple of b, ie, ceil(a/b)*b */
-/* Assumes a >= 0, b > 0 */
-{
-  a += b - 1L;
-  return a - (a % b);
-}
-
-
-/* On normal machines we can apply MEMCOPY() and MEMZERO() to sample arrays
- * and coefficient-block arrays.  This won't work on 80x86 because the arrays
- * are FAR and we're assuming a small-pointer memory model.  However, some
- * DOS compilers provide far-pointer versions of memcpy() and memset() even
- * in the small-model libraries.  These will be used if USE_FMEM is defined.
- * Otherwise, the routines below do it the hard way.  (The performance cost
- * is not all that great, because these routines aren't very heavily used.)
- */
-
-#ifndef NEED_FAR_POINTERS	/* normal case, same as regular macros */
-#define FMEMCOPY(dest,src,size)	MEMCOPY(dest,src,size)
-#define FMEMZERO(target,size)	MEMZERO(target,size)
-#else				/* 80x86 case, define if we can */
-#ifdef USE_FMEM
-#define FMEMCOPY(dest,src,size)	_fmemcpy((void FAR *)(dest), (const void FAR *)(src), (size_t)(size))
-#define FMEMZERO(target,size)	_fmemset((void FAR *)(target), 0, (size_t)(size))
-#endif
-#endif
-
-
-GLOBAL(void)
-jcopy_sample_rows (JSAMPARRAY input_array, int source_row,
-		   JSAMPARRAY output_array, int dest_row,
-		   int num_rows, JDIMENSION num_cols)
-/* Copy some rows of samples from one place to another.
- * num_rows rows are copied from input_array[source_row++]
- * to output_array[dest_row++]; these areas may overlap for duplication.
- * The source and destination arrays must be at least as wide as num_cols.
- */
-{
-  register JSAMPROW inptr, outptr;
-#ifdef FMEMCOPY
-  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLE));
-#else
-  register JDIMENSION count;
-#endif
-  register int row;
-
-  input_array += source_row;
-  output_array += dest_row;
-
-  for (row = num_rows; row > 0; row--) {
-    inptr = *input_array++;
-    outptr = *output_array++;
-#ifdef FMEMCOPY
-    FMEMCOPY(outptr, inptr, count);
-#else
-    for (count = num_cols; count > 0; count--)
-      *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
-#endif
-  }
-}
-
-
-GLOBAL(void)
-jcopy_block_row (JBLOCKROW input_row, JBLOCKROW output_row,
-		 JDIMENSION num_blocks)
-/* Copy a row of coefficient blocks from one place to another. */
-{
-#ifdef FMEMCOPY
-  FMEMCOPY(output_row, input_row, num_blocks * (DCTSIZE2 * SIZEOF(JCOEF)));
-#else
-  register JCOEFPTR inptr, outptr;
-  register long count;
-
-  inptr = (JCOEFPTR) input_row;
-  outptr = (JCOEFPTR) output_row;
-  for (count = (long) num_blocks * DCTSIZE2; count > 0; count--) {
-    *outptr++ = *inptr++;
-  }
-#endif
-}
-
-
-GLOBAL(void)
-jzero_far (void FAR * target, size_t bytestozero)
-/* Zero out a chunk of FAR memory. */
-/* This might be sample-array data, block-array data, or alloc_large data. */
-{
-#ifdef FMEMZERO
-  FMEMZERO(target, bytestozero);
-#else
-  register char FAR * ptr = (char FAR *) target;
-  register size_t count;
-
-  for (count = bytestozero; count > 0; count--) {
-    *ptr++ = 0;
-  }
-#endif
-}
diff --git a/jversion.h b/jversion.h
deleted file mode 100644
index 6472c58..0000000
--- a/jversion.h
+++ /dev/null
@@ -1,14 +0,0 @@
-/*
- * jversion.h
- *
- * Copyright (C) 1991-1998, Thomas G. Lane.
- * This file is part of the Independent JPEG Group's software.
- * For conditions of distribution and use, see the accompanying README file.
- *
- * This file contains software version identification.
- */
-
-
-#define JVERSION	"6b  27-Mar-1998"
-
-#define JCOPYRIGHT	"Copyright (C) 1998, Thomas G. Lane"
diff --git a/jcapimin.c b/xjcapimin.c
similarity index 76%
rename from jcapimin.c
rename to xjcapimin.c
index 54fb8c5..48e0673 100644
--- a/jcapimin.c
+++ b/xjcapimin.c
@@ -1,5 +1,5 @@
 /*
- * jcapimin.c
+ * xjcapimin.c
  *
  * Copyright (C) 1994-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -18,7 +18,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /*
@@ -27,9 +27,10 @@
  */
 
 GLOBAL(void)
-jpeg_CreateCompress (j_compress_ptr cinfo, int version, size_t structsize)
+jpeg_CreateCompress_xp (j_compress_ptr cinfo, int version, size_t structsize)
 {
   int i;
+  j_compress_ptr_xp xinfo;
 
   /* Guard against version mismatches between library and caller. */
   cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
@@ -55,11 +56,16 @@ jpeg_CreateCompress (j_compress_ptr cinfo, int version, size_t structsize)
   cinfo->is_decompressor = FALSE;
 
   /* Initialize a memory manager instance for this object */
-  jinit_memory_mgr((j_common_ptr) cinfo);
+  jinit_memory_mgr_xp((j_common_ptr) cinfo);
+
+  xinfo = (j_compress_ptr_xp)
+    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+        SIZEOF(jpeg_compress_struct_xp));
+  cinfo->client_data = (void*) xinfo;
 
   /* Zero out pointers to permanent structures. */
   cinfo->progress = NULL;
-  cinfo->dest = NULL;
+  xinfo->dest_xp = NULL;
 
   cinfo->comp_info = NULL;
 
@@ -85,9 +91,9 @@ jpeg_CreateCompress (j_compress_ptr cinfo, int version, size_t structsize)
  */
 
 GLOBAL(void)
-jpeg_destroy_compress (j_compress_ptr cinfo)
+jpeg_destroy_compress_xp (j_compress_ptr cinfo)
 {
-  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
+  jpeg_destroy_xp((j_common_ptr) cinfo); /* use common routine */
 }
 
 
@@ -97,9 +103,9 @@ jpeg_destroy_compress (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_abort_compress (j_compress_ptr cinfo)
+jpeg_abort_compress_xp (j_compress_ptr cinfo)
 {
-  jpeg_abort((j_common_ptr) cinfo); /* use common routine */
+  jpeg_abort_xp((j_common_ptr) cinfo); /* use common routine */
 }
 
 
@@ -116,7 +122,7 @@ jpeg_abort_compress (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress)
+jpeg_suppress_tables_xp (j_compress_ptr cinfo, boolean suppress)
 {
   int i;
   JQUANT_TBL * qtbl;
@@ -144,8 +150,9 @@ jpeg_suppress_tables (j_compress_ptr cinfo, boolean suppress)
  */
 
 GLOBAL(void)
-jpeg_finish_compress (j_compress_ptr cinfo)
+jpeg_finish_compress_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   JDIMENSION iMCU_row;
 
   if (cinfo->global_state == CSTATE_SCANNING ||
@@ -153,12 +160,12 @@ jpeg_finish_compress (j_compress_ptr cinfo)
     /* Terminate first pass */
     if (cinfo->next_scanline < cinfo->image_height)
       ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
-    (*cinfo->master->finish_pass) (cinfo);
+    (*xinfo->master_xp->finish_pass_xp) (cinfo);
   } else if (cinfo->global_state != CSTATE_WRCOEFS)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   /* Perform any remaining passes */
-  while (! cinfo->master->is_last_pass) {
-    (*cinfo->master->prepare_for_pass) (cinfo);
+  while (! xinfo->master_xp->is_last_pass) {
+    (*xinfo->master_xp->prepare_for_pass_xp) (cinfo);
     for (iMCU_row = 0; iMCU_row < cinfo->total_iMCU_rows; iMCU_row++) {
       if (cinfo->progress != NULL) {
 	cinfo->progress->pass_counter = (long) iMCU_row;
@@ -168,16 +175,16 @@ jpeg_finish_compress (j_compress_ptr cinfo)
       /* We bypass the main controller and invoke coef controller directly;
        * all work is being done from the coefficient buffer.
        */
-      if (! (*cinfo->coef->compress_data) (cinfo, (JSAMPIMAGE) NULL))
+      if (! (*xinfo->coef_xp->compress_data_xp) (cinfo, (JSAMPIMAGEXP) NULL))
 	ERREXIT(cinfo, JERR_CANT_SUSPEND);
     }
-    (*cinfo->master->finish_pass) (cinfo);
+    (*xinfo->master_xp->finish_pass_xp) (cinfo);
   }
   /* Write EOI, do final cleanup */
-  (*cinfo->marker->write_file_trailer) (cinfo);
-  (*cinfo->dest->term_destination) (cinfo);
+  (*xinfo->marker_xp->write_file_trailer_xp) (cinfo);
+  (*xinfo->dest_xp->term_destination_xp) (cinfo);
   /* We can use jpeg_abort to release memory and reset global_state */
-  jpeg_abort((j_common_ptr) cinfo);
+  jpeg_abort_xp((j_common_ptr) cinfo);
 }
 
 
@@ -189,10 +196,11 @@ jpeg_finish_compress (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_write_marker (j_compress_ptr cinfo, int marker,
+jpeg_write_marker_xp (j_compress_ptr cinfo, int marker,
 		   const JOCTET *dataptr, unsigned int datalen)
 {
-  JMETHOD(void, write_marker_byte, (j_compress_ptr info, int val));
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  JMETHOD(void, write_marker_byte_xp, (j_compress_ptr info, int val));
 
   if (cinfo->next_scanline != 0 ||
       (cinfo->global_state != CSTATE_SCANNING &&
@@ -200,10 +208,10 @@ jpeg_write_marker (j_compress_ptr cinfo, int marker,
        cinfo->global_state != CSTATE_WRCOEFS))
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
-  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);
-  write_marker_byte = cinfo->marker->write_marker_byte;	/* copy for speed */
+  (*xinfo->marker_xp->write_marker_header_xp) (cinfo, marker, datalen);
+  write_marker_byte_xp = xinfo->marker_xp->write_marker_byte_xp;	/* copy for speed */
   while (datalen--) {
-    (*write_marker_byte) (cinfo, *dataptr);
+    (*write_marker_byte_xp) (cinfo, *dataptr);
     dataptr++;
   }
 }
@@ -211,21 +219,23 @@ jpeg_write_marker (j_compress_ptr cinfo, int marker,
 /* Same, but piecemeal. */
 
 GLOBAL(void)
-jpeg_write_m_header (j_compress_ptr cinfo, int marker, unsigned int datalen)
+jpeg_write_m_header_xp (j_compress_ptr cinfo, int marker, unsigned int datalen)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   if (cinfo->next_scanline != 0 ||
       (cinfo->global_state != CSTATE_SCANNING &&
        cinfo->global_state != CSTATE_RAW_OK &&
        cinfo->global_state != CSTATE_WRCOEFS))
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
-  (*cinfo->marker->write_marker_header) (cinfo, marker, datalen);
+  (*xinfo->marker_xp->write_marker_header_xp) (cinfo, marker, datalen);
 }
 
 GLOBAL(void)
-jpeg_write_m_byte (j_compress_ptr cinfo, int val)
+jpeg_write_m_byte_xp (j_compress_ptr cinfo, int val)
 {
-  (*cinfo->marker->write_marker_byte) (cinfo, val);
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  (*xinfo->marker_xp->write_marker_byte_xp) (cinfo, val);
 }
 
 
@@ -251,20 +261,21 @@ jpeg_write_m_byte (j_compress_ptr cinfo, int val)
  */
 
 GLOBAL(void)
-jpeg_write_tables (j_compress_ptr cinfo)
+jpeg_write_tables_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   if (cinfo->global_state != CSTATE_START)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
   /* (Re)initialize error mgr and destination modules */
   (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
-  (*cinfo->dest->init_destination) (cinfo);
+  (*xinfo->dest_xp->init_destination_xp) (cinfo);
   /* Initialize the marker writer ... bit of a crock to do it here. */
-  jinit_marker_writer(cinfo);
+  jinit_marker_writer_xp(cinfo);
   /* Write them tables! */
-  (*cinfo->marker->write_tables_only) (cinfo);
+  (*xinfo->marker_xp->write_tables_only_xp) (cinfo);
   /* And clean up. */
-  (*cinfo->dest->term_destination) (cinfo);
+  (*xinfo->dest_xp->term_destination_xp) (cinfo);
   /*
    * In library releases up through v6a, we called jpeg_abort() here to free
    * any working memory allocated by the destination manager and marker
diff --git a/jcapistd.c b/xjcapistd.c
similarity index 83%
rename from jcapistd.c
rename to xjcapistd.c
index c0320b1..3f37a69 100644
--- a/jcapistd.c
+++ b/xjcapistd.c
@@ -1,5 +1,5 @@
 /*
- * jcapistd.c
+ * xjcapistd.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,7 +16,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /*
@@ -35,21 +35,22 @@
  */
 
 GLOBAL(void)
-jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables)
+jpeg_start_compress_xp (j_compress_ptr cinfo, boolean write_all_tables)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   if (cinfo->global_state != CSTATE_START)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
   if (write_all_tables)
-    jpeg_suppress_tables(cinfo, FALSE);	/* mark all tables to be written */
+    jpeg_suppress_tables_xp(cinfo, FALSE);	/* mark all tables to be written */
 
   /* (Re)initialize error mgr and destination modules */
   (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
-  (*cinfo->dest->init_destination) (cinfo);
+  (*xinfo->dest_xp->init_destination_xp) (cinfo);
   /* Perform master selection of active modules */
-  jinit_compress_master(cinfo);
+  jinit_compress_master_xp(cinfo);
   /* Set up for the first pass */
-  (*cinfo->master->prepare_for_pass) (cinfo);
+  (*xinfo->master_xp->prepare_for_pass_xp) (cinfo);
   /* Ready for application to drive first pass through jpeg_write_scanlines
    * or jpeg_write_raw_data.
    */
@@ -74,9 +75,10 @@ jpeg_start_compress (j_compress_ptr cinfo, boolean write_all_tables)
  */
 
 GLOBAL(JDIMENSION)
-jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines,
+jpeg_write_scanlines_xp (j_compress_ptr cinfo, JSAMPARRAYXP scanlines,
 		      JDIMENSION num_lines)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   JDIMENSION row_ctr, rows_left;
 
   if (cinfo->global_state != CSTATE_SCANNING)
@@ -96,8 +98,8 @@ jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines,
    * delayed so that application can write COM, etc, markers between
    * jpeg_start_compress and jpeg_write_scanlines.
    */
-  if (cinfo->master->call_pass_startup)
-    (*cinfo->master->pass_startup) (cinfo);
+  if (xinfo->master_xp->call_pass_startup)
+    (*xinfo->master_xp->pass_startup_xp) (cinfo);
 
   /* Ignore any extra scanlines at bottom of image. */
   rows_left = cinfo->image_height - cinfo->next_scanline;
@@ -105,7 +107,7 @@ jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines,
     num_lines = rows_left;
 
   row_ctr = 0;
-  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, num_lines);
+  (*xinfo->main_xp->process_data_xp) (cinfo, scanlines, &row_ctr, num_lines);
   cinfo->next_scanline += row_ctr;
   return row_ctr;
 }
@@ -117,9 +119,10 @@ jpeg_write_scanlines (j_compress_ptr cinfo, JSAMPARRAY scanlines,
  */
 
 GLOBAL(JDIMENSION)
-jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data,
+jpeg_write_raw_data_xp (j_compress_ptr cinfo, JSAMPIMAGEXP data,
 		     JDIMENSION num_lines)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   JDIMENSION lines_per_iMCU_row;
 
   if (cinfo->global_state != CSTATE_RAW_OK)
@@ -141,8 +144,8 @@ jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data,
    * delayed so that application can write COM, etc, markers between
    * jpeg_start_compress and jpeg_write_raw_data.
    */
-  if (cinfo->master->call_pass_startup)
-    (*cinfo->master->pass_startup) (cinfo);
+  if (xinfo->master_xp->call_pass_startup)
+    (*xinfo->master_xp->pass_startup_xp) (cinfo);
 
   /* Verify that at least one iMCU row has been passed. */
   lines_per_iMCU_row = cinfo->max_v_samp_factor * DCTSIZE;
@@ -150,7 +153,7 @@ jpeg_write_raw_data (j_compress_ptr cinfo, JSAMPIMAGE data,
     ERREXIT(cinfo, JERR_BUFFER_SIZE);
 
   /* Directly compress the row. */
-  if (! (*cinfo->coef->compress_data) (cinfo, data)) {
+  if (! (*xinfo->coef_xp->compress_data_xp) (cinfo, data)) {
     /* If compressor did not consume the whole row, suspend processing. */
     return 0;
   }
diff --git a/jccoefct.c b/xjccoefct.c
similarity index 86%
rename from jccoefct.c
rename to xjccoefct.c
index 1963ddb..b634239 100644
--- a/jccoefct.c
+++ b/xjccoefct.c
@@ -1,5 +1,5 @@
 /*
- * jccoefct.c
+ * xjccoefct.c
  *
  * Copyright (C) 1994-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -12,7 +12,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* We use a full-image coefficient buffer when doing Huffman optimization,
@@ -32,7 +32,7 @@
 /* Private buffer controller object */
 
 typedef struct {
-  struct jpeg_c_coef_controller pub; /* public fields */
+  struct jpeg_c_coef_controller_xp pub; /* public fields */
 
   JDIMENSION iMCU_row_num;	/* iMCU row # within image */
   JDIMENSION mcu_ctr;		/* counts MCUs processed in current row */
@@ -52,27 +52,28 @@ typedef struct {
 
   /* In multi-pass modes, we need a virtual block array for each component. */
   jvirt_barray_ptr whole_image[MAX_COMPONENTS];
-} my_coef_controller;
+} my_coef_controller_xp;
 
-typedef my_coef_controller * my_coef_ptr;
+typedef my_coef_controller_xp * my_coef_ptr;
 
 
 /* Forward declarations */
-METHODDEF(boolean) compress_data
-    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
+METHODDEF(boolean) compress_data_xp
+    JPP((j_compress_ptr cinfo, JSAMPIMAGEXP input_buf));
 #ifdef FULL_COEF_BUFFER_SUPPORTED
-METHODDEF(boolean) compress_first_pass
-    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
-METHODDEF(boolean) compress_output
-    JPP((j_compress_ptr cinfo, JSAMPIMAGE input_buf));
+METHODDEF(boolean) compress_first_pass_xp
+    JPP((j_compress_ptr cinfo, JSAMPIMAGEXP input_buf));
+METHODDEF(boolean) compress_output_xp
+    JPP((j_compress_ptr cinfo, JSAMPIMAGEXP input_buf));
 #endif
 
 
 LOCAL(void)
-start_iMCU_row (j_compress_ptr cinfo)
+start_iMCU_row_xp (j_compress_ptr cinfo)
 /* Reset within-iMCU-row counters for a new row */
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
 
   /* In an interleaved scan, an MCU row is the same as an iMCU row.
    * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
@@ -97,29 +98,30 @@ start_iMCU_row (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
+start_pass_coef_xp (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
 
   coef->iMCU_row_num = 0;
-  start_iMCU_row(cinfo);
+  start_iMCU_row_xp(cinfo);
 
   switch (pass_mode) {
   case JBUF_PASS_THRU:
     if (coef->whole_image[0] != NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
-    coef->pub.compress_data = compress_data;
+    coef->pub.compress_data_xp = compress_data_xp;
     break;
 #ifdef FULL_COEF_BUFFER_SUPPORTED
   case JBUF_SAVE_AND_PASS:
     if (coef->whole_image[0] == NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
-    coef->pub.compress_data = compress_first_pass;
+    coef->pub.compress_data_xp = compress_first_pass_xp;
     break;
   case JBUF_CRANK_DEST:
     if (coef->whole_image[0] == NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
-    coef->pub.compress_data = compress_output;
+    coef->pub.compress_data_xp = compress_output_xp;
     break;
 #endif
   default:
@@ -140,9 +142,10 @@ start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
  */
 
 METHODDEF(boolean)
-compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
+compress_data_xp (j_compress_ptr cinfo, JSAMPIMAGEXP input_buf)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
   JDIMENSION MCU_col_num;	/* index of current MCU within row */
   JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
@@ -174,7 +177,7 @@ compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
 	for (yindex = 0; yindex < compptr->MCU_height; yindex++) {
 	  if (coef->iMCU_row_num < last_iMCU_row ||
 	      yoffset+yindex < compptr->last_row_height) {
-	    (*cinfo->fdct->forward_DCT) (cinfo, compptr,
+	    (*xinfo->fdct_xp->forward_DCT_xp) (cinfo, compptr,
 					 input_buf[compptr->component_index],
 					 coef->MCU_buffer[blkn],
 					 ypos, xpos, (JDIMENSION) blockcnt);
@@ -201,7 +204,7 @@ compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
       /* Try to write the MCU.  In event of a suspension failure, we will
        * re-DCT the MCU on restart (a bit inefficient, could be fixed...)
        */
-      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
+      if (! (*xinfo->entropy_xp->encode_mcu_xp) (cinfo, coef->MCU_buffer)) {
 	/* Suspension forced; update state counters and exit */
 	coef->MCU_vert_offset = yoffset;
 	coef->mcu_ctr = MCU_col_num;
@@ -213,7 +216,7 @@ compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
   }
   /* Completed the iMCU row, advance counters for next one */
   coef->iMCU_row_num++;
-  start_iMCU_row(cinfo);
+  start_iMCU_row_xp(cinfo);
   return TRUE;
 }
 
@@ -242,9 +245,10 @@ compress_data (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  */
 
 METHODDEF(boolean)
-compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
+compress_first_pass_xp (j_compress_ptr cinfo, JSAMPIMAGEXP input_buf)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
   JDIMENSION blocks_across, MCUs_across, MCUindex;
   int bi, ci, h_samp_factor, block_row, block_rows, ndummy;
@@ -279,7 +283,7 @@ compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
      */
     for (block_row = 0; block_row < block_rows; block_row++) {
       thisblockrow = buffer[block_row];
-      (*cinfo->fdct->forward_DCT) (cinfo, compptr,
+      (*xinfo->fdct_xp->forward_DCT_xp) (cinfo, compptr,
 				   input_buf[ci], thisblockrow,
 				   (JDIMENSION) (block_row * DCTSIZE),
 				   (JDIMENSION) 0, blocks_across);
@@ -323,7 +327,7 @@ compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
    */
 
   /* Emit data to the entropy encoder, sharing code with subsequent passes */
-  return compress_output(cinfo, input_buf);
+  return compress_output_xp(cinfo, input_buf);
 }
 
 
@@ -338,9 +342,10 @@ compress_first_pass (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  */
 
 METHODDEF(boolean)
-compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
+compress_output_xp (j_compress_ptr cinfo, JSAMPIMAGEXP input_buf)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
   JDIMENSION MCU_col_num;	/* index of current MCU within row */
   int blkn, ci, xindex, yindex, yoffset;
   JDIMENSION start_col;
@@ -378,7 +383,7 @@ compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
 	}
       }
       /* Try to write the MCU. */
-      if (! (*cinfo->entropy->encode_mcu) (cinfo, coef->MCU_buffer)) {
+      if (! (*xinfo->entropy_xp->encode_mcu_xp) (cinfo, coef->MCU_buffer)) {
 	/* Suspension forced; update state counters and exit */
 	coef->MCU_vert_offset = yoffset;
 	coef->mcu_ctr = MCU_col_num;
@@ -390,7 +395,7 @@ compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
   }
   /* Completed the iMCU row, advance counters for next one */
   coef->iMCU_row_num++;
-  start_iMCU_row(cinfo);
+  start_iMCU_row_xp(cinfo);
   return TRUE;
 }
 
@@ -402,15 +407,16 @@ compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  */
 
 GLOBAL(void)
-jinit_c_coef_controller (j_compress_ptr cinfo, boolean need_full_buffer)
+jinit_c_coef_controller_xp (j_compress_ptr cinfo, boolean need_full_buffer)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_coef_ptr coef;
 
   coef = (my_coef_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				SIZEOF(my_coef_controller));
-  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
-  coef->pub.start_pass = start_pass_coef;
+				SIZEOF(my_coef_controller_xp));
+  xinfo->coef_xp = (struct jpeg_c_coef_controller_xp *) coef;
+  coef->pub.start_pass_xp = start_pass_coef_xp;
 
   /* Create the coefficient buffer. */
   if (need_full_buffer) {
diff --git a/jccolor.c b/xjccolor.c
similarity index 77%
rename from jccolor.c
rename to xjccolor.c
index 0a8a4b5..37bf816 100644
--- a/jccolor.c
+++ b/xjccolor.c
@@ -1,5 +1,5 @@
 /*
- * jccolor.c
+ * xjccolor.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -10,19 +10,19 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Private subobject */
 
 typedef struct {
-  struct jpeg_color_converter pub; /* public fields */
+  struct jpeg_color_converter_xp pub; /* public fields */
 
   /* Private state for RGB->YCC conversion */
   INT32 * rgb_ycc_tab;		/* => table for RGB to YCbCr conversion */
-} my_color_converter;
+} my_color_converter_xp;
 
-typedef my_color_converter * my_cconvert_ptr;
+typedef my_color_converter_xp * my_cconvert_ptr;
 
 
 /**************** RGB -> YCbCr conversion: most common case **************/
@@ -56,7 +56,7 @@ typedef my_color_converter * my_cconvert_ptr;
  */
 
 #define SCALEBITS	16	/* speediest right-shift on some machines */
-#define CBCR_OFFSET	((INT32) CENTERJSAMPLE << SCALEBITS)
+#define CBCR_OFFSET_12BIT  ((INT32) CENTERJSAMPLE12 << SCALEBITS)
 #define ONE_HALF	((INT32) 1 << (SCALEBITS-1))
 #define FIX(x)		((INT32) ((x) * (1L<<SCALEBITS) + 0.5))
 
@@ -67,15 +67,15 @@ typedef my_color_converter * my_cconvert_ptr;
  */
 
 #define R_Y_OFF		0			/* offset to R => Y section */
-#define G_Y_OFF		(1*(MAXJSAMPLE+1))	/* offset to G => Y section */
-#define B_Y_OFF		(2*(MAXJSAMPLE+1))	/* etc. */
-#define R_CB_OFF	(3*(MAXJSAMPLE+1))
-#define G_CB_OFF	(4*(MAXJSAMPLE+1))
-#define B_CB_OFF	(5*(MAXJSAMPLE+1))
+#define G_Y_OFF	(1*(MAXJSAMPLE12+1))	/* offset to G => Y section */
+#define B_Y_OFF	(2*(MAXJSAMPLE12+1))	/* etc. */
+#define R_CB_OFF	(3*(MAXJSAMPLE12+1))
+#define G_CB_OFF	(4*(MAXJSAMPLE12+1))
+#define B_CB_OFF	(5*(MAXJSAMPLE12+1))
 #define R_CR_OFF	B_CB_OFF		/* B=>Cb, R=>Cr are the same */
-#define G_CR_OFF	(6*(MAXJSAMPLE+1))
-#define B_CR_OFF	(7*(MAXJSAMPLE+1))
-#define TABLE_SIZE	(8*(MAXJSAMPLE+1))
+#define G_CR_OFF	(6*(MAXJSAMPLE12+1))
+#define B_CR_OFF	(7*(MAXJSAMPLE12+1))
+#define TABLE_SIZE	(8*(MAXJSAMPLE12+1))
 
 
 /*
@@ -83,9 +83,10 @@ typedef my_color_converter * my_cconvert_ptr;
  */
 
 METHODDEF(void)
-rgb_ycc_start (j_compress_ptr cinfo)
+rgb_ycc_start_xp (j_compress_ptr cinfo)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) xinfo->cconvert_xp;
   INT32 * rgb_ycc_tab;
   INT32 i;
 
@@ -94,7 +95,7 @@ rgb_ycc_start (j_compress_ptr cinfo)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				(TABLE_SIZE * SIZEOF(INT32)));
 
-  for (i = 0; i <= MAXJSAMPLE; i++) {
+  for (i = 0; i <= MAXJSAMPLE12; i++) {
     rgb_ycc_tab[i+R_Y_OFF] = FIX(0.29900) * i;
     rgb_ycc_tab[i+G_Y_OFF] = FIX(0.58700) * i;
     rgb_ycc_tab[i+B_Y_OFF] = FIX(0.11400) * i     + ONE_HALF;
@@ -104,7 +105,7 @@ rgb_ycc_start (j_compress_ptr cinfo)
      * This ensures that the maximum output will round to MAXJSAMPLE
      * not MAXJSAMPLE+1, and thus that we don't have to range-limit.
      */
-    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
+    rgb_ycc_tab[i+B_CB_OFF] = FIX(0.50000) * i    + CBCR_OFFSET_12BIT + ONE_HALF-1;
 /*  B=>Cb and R=>Cr tables are the same
     rgb_ycc_tab[i+R_CR_OFF] = FIX(0.50000) * i    + CBCR_OFFSET + ONE_HALF-1;
 */
@@ -127,15 +128,16 @@ rgb_ycc_start (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-rgb_ycc_convert (j_compress_ptr cinfo,
-		 JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+rgb_ycc_convert_xp (j_compress_ptr cinfo,
+		 JSAMPARRAYXP input_buf, JSAMPIMAGEXP output_buf,
 		 JDIMENSION output_row, int num_rows)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) xinfo->cconvert_xp;
   register int r, g, b;
   register INT32 * ctab = cconvert->rgb_ycc_tab;
-  register JSAMPROW inptr;
-  register JSAMPROW outptr0, outptr1, outptr2;
+  register JSAMPROWXP inptr;
+  register JSAMPROWXP outptr0, outptr1, outptr2;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->image_width;
 
@@ -156,15 +158,15 @@ rgb_ycc_convert (j_compress_ptr cinfo,
        * need the general RIGHT_SHIFT macro.
        */
       /* Y */
-      outptr0[col] = (JSAMPLE)
+      outptr0[col] = (JSAMPLEXP)
 		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
 		 >> SCALEBITS);
       /* Cb */
-      outptr1[col] = (JSAMPLE)
+      outptr1[col] = (JSAMPLEXP)
 		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
 		 >> SCALEBITS);
       /* Cr */
-      outptr2[col] = (JSAMPLE)
+      outptr2[col] = (JSAMPLEXP)
 		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
 		 >> SCALEBITS);
     }
@@ -183,15 +185,16 @@ rgb_ycc_convert (j_compress_ptr cinfo,
  */
 
 METHODDEF(void)
-rgb_gray_convert (j_compress_ptr cinfo,
-		  JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+rgb_gray_convert_xp (j_compress_ptr cinfo,
+		  JSAMPARRAYXP input_buf, JSAMPIMAGEXP output_buf,
 		  JDIMENSION output_row, int num_rows)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) xinfo->cconvert_xp;
   register int r, g, b;
   register INT32 * ctab = cconvert->rgb_ycc_tab;
-  register JSAMPROW inptr;
-  register JSAMPROW outptr;
+  register JSAMPROWXP inptr;
+  register JSAMPROWXP outptr;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->image_width;
 
@@ -205,7 +208,7 @@ rgb_gray_convert (j_compress_ptr cinfo,
       b = GETJSAMPLE(inptr[RGB_BLUE]);
       inptr += RGB_PIXELSIZE;
       /* Y */
-      outptr[col] = (JSAMPLE)
+      outptr[col] = (JSAMPLEXP)
 		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
 		 >> SCALEBITS);
     }
@@ -222,15 +225,16 @@ rgb_gray_convert (j_compress_ptr cinfo,
  */
 
 METHODDEF(void)
-cmyk_ycck_convert (j_compress_ptr cinfo,
-		   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+cmyk_ycck_convert_xp (j_compress_ptr cinfo,
+		   JSAMPARRAYXP input_buf, JSAMPIMAGEXP output_buf,
 		   JDIMENSION output_row, int num_rows)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) xinfo->cconvert_xp;
   register int r, g, b;
   register INT32 * ctab = cconvert->rgb_ycc_tab;
-  register JSAMPROW inptr;
-  register JSAMPROW outptr0, outptr1, outptr2, outptr3;
+  register JSAMPROWXP inptr;
+  register JSAMPROWXP outptr0, outptr1, outptr2, outptr3;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->image_width;
 
@@ -242,9 +246,9 @@ cmyk_ycck_convert (j_compress_ptr cinfo,
     outptr3 = output_buf[3][output_row];
     output_row++;
     for (col = 0; col < num_cols; col++) {
-      r = MAXJSAMPLE - GETJSAMPLE(inptr[0]);
-      g = MAXJSAMPLE - GETJSAMPLE(inptr[1]);
-      b = MAXJSAMPLE - GETJSAMPLE(inptr[2]);
+      r = MAXJSAMPLE12 - GETJSAMPLE(inptr[0]);
+      g = MAXJSAMPLE12 - GETJSAMPLE(inptr[1]);
+      b = MAXJSAMPLE12 - GETJSAMPLE(inptr[2]);
       /* K passes through as-is */
       outptr3[col] = inptr[3];	/* don't need GETJSAMPLE here */
       inptr += 4;
@@ -254,15 +258,15 @@ cmyk_ycck_convert (j_compress_ptr cinfo,
        * need the general RIGHT_SHIFT macro.
        */
       /* Y */
-      outptr0[col] = (JSAMPLE)
+      outptr0[col] = (JSAMPLEXP)
 		((ctab[r+R_Y_OFF] + ctab[g+G_Y_OFF] + ctab[b+B_Y_OFF])
 		 >> SCALEBITS);
       /* Cb */
-      outptr1[col] = (JSAMPLE)
+      outptr1[col] = (JSAMPLEXP)
 		((ctab[r+R_CB_OFF] + ctab[g+G_CB_OFF] + ctab[b+B_CB_OFF])
 		 >> SCALEBITS);
       /* Cr */
-      outptr2[col] = (JSAMPLE)
+      outptr2[col] = (JSAMPLEXP)
 		((ctab[r+R_CR_OFF] + ctab[g+G_CR_OFF] + ctab[b+B_CR_OFF])
 		 >> SCALEBITS);
     }
@@ -277,12 +281,12 @@ cmyk_ycck_convert (j_compress_ptr cinfo,
  */
 
 METHODDEF(void)
-grayscale_convert (j_compress_ptr cinfo,
-		   JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+grayscale_convert_xp (j_compress_ptr cinfo,
+		   JSAMPARRAYXP input_buf, JSAMPIMAGEXP output_buf,
 		   JDIMENSION output_row, int num_rows)
 {
-  register JSAMPROW inptr;
-  register JSAMPROW outptr;
+  register JSAMPROWXP inptr;
+  register JSAMPROWXP outptr;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->image_width;
   int instride = cinfo->input_components;
@@ -306,12 +310,12 @@ grayscale_convert (j_compress_ptr cinfo,
  */
 
 METHODDEF(void)
-null_convert (j_compress_ptr cinfo,
-	      JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+null_convert_xp (j_compress_ptr cinfo,
+	      JSAMPARRAYXP input_buf, JSAMPIMAGEXP output_buf,
 	      JDIMENSION output_row, int num_rows)
 {
-  register JSAMPROW inptr;
-  register JSAMPROW outptr;
+  register JSAMPROWXP inptr;
+  register JSAMPROWXP outptr;
   register JDIMENSION col;
   register int ci;
   int nc = cinfo->num_components;
@@ -338,7 +342,7 @@ null_convert (j_compress_ptr cinfo,
  */
 
 METHODDEF(void)
-null_method (j_compress_ptr cinfo)
+null_method_xp (j_compress_ptr cinfo)
 {
   /* no work needed */
 }
@@ -349,16 +353,17 @@ null_method (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_color_converter (j_compress_ptr cinfo)
+jinit_color_converter_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_cconvert_ptr cconvert;
 
   cconvert = (my_cconvert_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				SIZEOF(my_color_converter));
-  cinfo->cconvert = (struct jpeg_color_converter *) cconvert;
+				SIZEOF(my_color_converter_xp));
+  xinfo->cconvert_xp = (struct jpeg_color_converter_xp *) cconvert;
   /* set start_pass to null method until we find out differently */
-  cconvert->pub.start_pass = null_method;
+  cconvert->pub.start_pass_xp = null_method_xp;
 
   /* Make sure input_components agrees with in_color_space */
   switch (cinfo->in_color_space) {
@@ -397,12 +402,12 @@ jinit_color_converter (j_compress_ptr cinfo)
     if (cinfo->num_components != 1)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
     if (cinfo->in_color_space == JCS_GRAYSCALE)
-      cconvert->pub.color_convert = grayscale_convert;
+      cconvert->pub.color_convert_xp = grayscale_convert_xp;
     else if (cinfo->in_color_space == JCS_RGB) {
-      cconvert->pub.start_pass = rgb_ycc_start;
-      cconvert->pub.color_convert = rgb_gray_convert;
+      cconvert->pub.start_pass_xp = rgb_ycc_start_xp;
+      cconvert->pub.color_convert_xp = rgb_gray_convert_xp;
     } else if (cinfo->in_color_space == JCS_YCbCr)
-      cconvert->pub.color_convert = grayscale_convert;
+      cconvert->pub.color_convert_xp = grayscale_convert_xp;
     else
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     break;
@@ -411,7 +416,7 @@ jinit_color_converter (j_compress_ptr cinfo)
     if (cinfo->num_components != 3)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
     if (cinfo->in_color_space == JCS_RGB && RGB_PIXELSIZE == 3)
-      cconvert->pub.color_convert = null_convert;
+      cconvert->pub.color_convert_xp = null_convert_xp;
     else
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     break;
@@ -420,10 +425,10 @@ jinit_color_converter (j_compress_ptr cinfo)
     if (cinfo->num_components != 3)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
     if (cinfo->in_color_space == JCS_RGB) {
-      cconvert->pub.start_pass = rgb_ycc_start;
-      cconvert->pub.color_convert = rgb_ycc_convert;
+      cconvert->pub.start_pass_xp = rgb_ycc_start_xp;
+      cconvert->pub.color_convert_xp = rgb_ycc_convert_xp;
     } else if (cinfo->in_color_space == JCS_YCbCr)
-      cconvert->pub.color_convert = null_convert;
+      cconvert->pub.color_convert_xp = null_convert_xp;
     else
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     break;
@@ -432,7 +437,7 @@ jinit_color_converter (j_compress_ptr cinfo)
     if (cinfo->num_components != 4)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
     if (cinfo->in_color_space == JCS_CMYK)
-      cconvert->pub.color_convert = null_convert;
+      cconvert->pub.color_convert_xp = null_convert_xp;
     else
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     break;
@@ -441,10 +446,10 @@ jinit_color_converter (j_compress_ptr cinfo)
     if (cinfo->num_components != 4)
       ERREXIT(cinfo, JERR_BAD_J_COLORSPACE);
     if (cinfo->in_color_space == JCS_CMYK) {
-      cconvert->pub.start_pass = rgb_ycc_start;
-      cconvert->pub.color_convert = cmyk_ycck_convert;
+      cconvert->pub.start_pass_xp = rgb_ycc_start_xp;
+      cconvert->pub.color_convert_xp = cmyk_ycck_convert_xp;
     } else if (cinfo->in_color_space == JCS_YCCK)
-      cconvert->pub.color_convert = null_convert;
+      cconvert->pub.color_convert_xp = null_convert_xp;
     else
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     break;
@@ -453,7 +458,7 @@ jinit_color_converter (j_compress_ptr cinfo)
     if (cinfo->jpeg_color_space != cinfo->in_color_space ||
 	cinfo->num_components != cinfo->input_components)
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
-    cconvert->pub.color_convert = null_convert;
+    cconvert->pub.color_convert_xp = null_convert_xp;
     break;
   }
 }
diff --git a/jcdctmgr.c b/xjcdctmgr.c
similarity index 83%
rename from jcdctmgr.c
rename to xjcdctmgr.c
index 61fa79b..a3e1f7f 100644
--- a/jcdctmgr.c
+++ b/xjcdctmgr.c
@@ -1,5 +1,5 @@
 /*
- * jcdctmgr.c
+ * xjcdctmgr.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -13,14 +13,14 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 
 /* Private subobject for this module */
 
 typedef struct {
-  struct jpeg_forward_dct pub;	/* public fields */
+  struct jpeg_forward_dct_xp pub;	/* public fields */
 
   /* Pointer to the DCT routine actually in use */
   forward_DCT_method_ptr do_dct;
@@ -51,9 +51,10 @@ typedef my_fdct_controller * my_fdct_ptr;
  */
 
 METHODDEF(void)
-start_pass_fdctmgr (j_compress_ptr cinfo)
+start_pass_fdctmgr_xp (j_compress_ptr cinfo)
 {
-  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_fdct_ptr fdct = (my_fdct_ptr) xinfo->fdct_xp;
   int ci, qtblno, i;
   jpeg_component_info *compptr;
   JQUANT_TBL * qtbl;
@@ -177,14 +178,15 @@ start_pass_fdctmgr (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-forward_DCT (j_compress_ptr cinfo, jpeg_component_info * compptr,
-	     JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
-	     JDIMENSION start_row, JDIMENSION start_col,
-	     JDIMENSION num_blocks)
+forward_DCT_xp (j_compress_ptr cinfo, jpeg_component_info * compptr,
+                   JSAMPARRAYXP sample_data, JBLOCKROW coef_blocks,
+                   JDIMENSION start_row, JDIMENSION start_col,
+                   JDIMENSION num_blocks)
 /* This version is used for integer DCT implementations. */
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   /* This routine is heavily used, so it's worth coding it tightly. */
-  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
+  my_fdct_ptr fdct = (my_fdct_ptr) xinfo->fdct_xp;
   forward_DCT_method_ptr do_dct = fdct->do_dct;
   DCTELEM * divisors = fdct->divisors[compptr->quant_tbl_no];
   DCTELEM workspace[DCTSIZE2];	/* work area for FDCT subroutine */
@@ -195,25 +197,25 @@ forward_DCT (j_compress_ptr cinfo, jpeg_component_info * compptr,
   for (bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE) {
     /* Load data into workspace, applying unsigned->signed conversion */
     { register DCTELEM *workspaceptr;
-      register JSAMPROW elemptr;
+      register JSAMPROWXP elemptr;
       register int elemr;
 
       workspaceptr = workspace;
       for (elemr = 0; elemr < DCTSIZE; elemr++) {
 	elemptr = sample_data[elemr] + start_col;
 #if DCTSIZE == 8		/* unroll the inner loop */
-	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
-	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
-	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
-	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
-	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
-	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
-	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
-	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
+	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
+	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
+	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
+	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
+	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
+	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
+	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
+	*workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
 #else
 	{ register int elemc;
 	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
-	    *workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE;
+	    *workspaceptr++ = GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12;
 	  }
 	}
 #endif
@@ -267,14 +269,15 @@ forward_DCT (j_compress_ptr cinfo, jpeg_component_info * compptr,
 #ifdef DCT_FLOAT_SUPPORTED
 
 METHODDEF(void)
-forward_DCT_float (j_compress_ptr cinfo, jpeg_component_info * compptr,
-		   JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
+forward_DCT_float_xp (j_compress_ptr cinfo, jpeg_component_info * compptr,
+		   JSAMPARRAYXP sample_data, JBLOCKROW coef_blocks,
 		   JDIMENSION start_row, JDIMENSION start_col,
 		   JDIMENSION num_blocks)
 /* This version is used for floating-point DCT implementations. */
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   /* This routine is heavily used, so it's worth coding it tightly. */
-  my_fdct_ptr fdct = (my_fdct_ptr) cinfo->fdct;
+  my_fdct_ptr fdct = (my_fdct_ptr) xinfo->fdct_xp;
   float_DCT_method_ptr do_dct = fdct->do_float_dct;
   FAST_FLOAT * divisors = fdct->float_divisors[compptr->quant_tbl_no];
   FAST_FLOAT workspace[DCTSIZE2]; /* work area for FDCT subroutine */
@@ -285,26 +288,26 @@ forward_DCT_float (j_compress_ptr cinfo, jpeg_component_info * compptr,
   for (bi = 0; bi < num_blocks; bi++, start_col += DCTSIZE) {
     /* Load data into workspace, applying unsigned->signed conversion */
     { register FAST_FLOAT *workspaceptr;
-      register JSAMPROW elemptr;
+      register JSAMPROWXP elemptr;
       register int elemr;
 
       workspaceptr = workspace;
       for (elemr = 0; elemr < DCTSIZE; elemr++) {
 	elemptr = sample_data[elemr] + start_col;
 #if DCTSIZE == 8		/* unroll the inner loop */
-	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
-	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
-	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
-	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
-	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
-	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
-	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
-	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
+	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
+	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
+	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
+	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
+	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
+	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
+	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
+	*workspaceptr++ = (FAST_FLOAT)(GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
 #else
 	{ register int elemc;
 	  for (elemc = DCTSIZE; elemc > 0; elemc--) {
 	    *workspaceptr++ = (FAST_FLOAT)
-	      (GETJSAMPLE(*elemptr++) - CENTERJSAMPLE);
+	      (GETJSAMPLE(*elemptr++) - CENTERJSAMPLE12);
 	  }
 	}
 #endif
@@ -342,34 +345,35 @@ forward_DCT_float (j_compress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 GLOBAL(void)
-jinit_forward_dct (j_compress_ptr cinfo)
+jinit_forward_dct_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_fdct_ptr fdct;
   int i;
 
   fdct = (my_fdct_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_fdct_controller));
-  cinfo->fdct = (struct jpeg_forward_dct *) fdct;
-  fdct->pub.start_pass = start_pass_fdctmgr;
+  xinfo->fdct_xp = (struct jpeg_forward_dct_xp *) fdct;
+  fdct->pub.start_pass_xp = start_pass_fdctmgr_xp;
 
   switch (cinfo->dct_method) {
 #ifdef DCT_ISLOW_SUPPORTED
   case JDCT_ISLOW:
-    fdct->pub.forward_DCT = forward_DCT;
-    fdct->do_dct = jpeg_fdct_islow;
+    fdct->pub.forward_DCT_xp = forward_DCT_xp;
+    fdct->do_dct = jpeg_fdct_islow_xp;
     break;
 #endif
 #ifdef DCT_IFAST_SUPPORTED
   case JDCT_IFAST:
-    fdct->pub.forward_DCT = forward_DCT;
-    fdct->do_dct = jpeg_fdct_ifast;
+    fdct->pub.forward_DCT_xp = forward_DCT_xp;
+    fdct->do_dct = jpeg_fdct_ifast_xp;
     break;
 #endif
 #ifdef DCT_FLOAT_SUPPORTED
   case JDCT_FLOAT:
-    fdct->pub.forward_DCT = forward_DCT_float;
-    fdct->do_float_dct = jpeg_fdct_float;
+    fdct->pub.forward_DCT_xp = forward_DCT_float_xp;
+    fdct->do_float_dct = jpeg_fdct_float_xp;
     break;
 #endif
   default:
diff --git a/jchuff.c b/xjchuff.c
similarity index 86%
rename from jchuff.c
rename to xjchuff.c
index f235250..d77da0f 100644
--- a/jchuff.c
+++ b/xjchuff.c
@@ -1,5 +1,5 @@
 /*
- * jchuff.c
+ * xjchuff.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,8 +16,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jchuff.h"		/* Declarations shared with jcphuff.c */
+#include "xjpeglib.h"
+#include "xjchuff.h"		/* Declarations shared with jcphuff.c */
 
 
 /* Expanded entropy encoder object for Huffman encoding.
@@ -53,7 +53,7 @@ typedef struct {
 
 
 typedef struct {
-  struct jpeg_entropy_encoder pub; /* public fields */
+  struct jpeg_entropy_encoder_xp pub; /* public fields */
 
   savable_state saved;		/* Bit buffer & DC state at start of MCU */
 
@@ -82,17 +82,17 @@ typedef struct {
   size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
   savable_state cur;		/* Current bit buffer & DC state */
   j_compress_ptr cinfo;		/* dump_buffer needs access to this */
-} working_state;
+} working_state_xp;
 
 
 /* Forward declarations */
-METHODDEF(boolean) encode_mcu_huff JPP((j_compress_ptr cinfo,
+METHODDEF(boolean) encode_mcu_huff_xp JPP((j_compress_ptr cinfo,
 					JBLOCKROW *MCU_data));
-METHODDEF(void) finish_pass_huff JPP((j_compress_ptr cinfo));
+METHODDEF(void) finish_pass_huff_xp JPP((j_compress_ptr cinfo));
 #ifdef ENTROPY_OPT_SUPPORTED
-METHODDEF(boolean) encode_mcu_gather JPP((j_compress_ptr cinfo,
+METHODDEF(boolean) encode_mcu_gather_xp JPP((j_compress_ptr cinfo,
 					  JBLOCKROW *MCU_data));
-METHODDEF(void) finish_pass_gather JPP((j_compress_ptr cinfo));
+METHODDEF(void) finish_pass_gather_xp JPP((j_compress_ptr cinfo));
 #endif
 
 
@@ -103,22 +103,23 @@ METHODDEF(void) finish_pass_gather JPP((j_compress_ptr cinfo));
  */
 
 METHODDEF(void)
-start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
+start_pass_huff_xp (j_compress_ptr cinfo, boolean gather_statistics)
 {
-  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
+  huff_entropy_ptr entropy =
+    (huff_entropy_ptr) ((j_compress_ptr_xp) cinfo->client_data)->entropy_xp;
   int ci, dctbl, actbl;
   jpeg_component_info * compptr;
 
   if (gather_statistics) {
 #ifdef ENTROPY_OPT_SUPPORTED
-    entropy->pub.encode_mcu = encode_mcu_gather;
-    entropy->pub.finish_pass = finish_pass_gather;
+    entropy->pub.encode_mcu_xp = encode_mcu_gather_xp;
+    entropy->pub.finish_pass_xp = finish_pass_gather_xp;
 #else
     ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
   } else {
-    entropy->pub.encode_mcu = encode_mcu_huff;
-    entropy->pub.finish_pass = finish_pass_huff;
+    entropy->pub.encode_mcu_xp = encode_mcu_huff_xp;
+    entropy->pub.finish_pass_xp = finish_pass_huff_xp;
   }
 
   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
@@ -149,9 +150,9 @@ start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
     } else {
       /* Compute derived values for Huffman tables */
       /* We may do this more than once for a table, but it's not expensive */
-      jpeg_make_c_derived_tbl(cinfo, TRUE, dctbl,
+      jpeg_make_c_derived_tbl_xp(cinfo, TRUE, dctbl,
 			      & entropy->dc_derived_tbls[dctbl]);
-      jpeg_make_c_derived_tbl(cinfo, FALSE, actbl,
+      jpeg_make_c_derived_tbl_xp(cinfo, FALSE, actbl,
 			      & entropy->ac_derived_tbls[actbl]);
     }
     /* Initialize DC predictions to 0 */
@@ -176,7 +177,7 @@ start_pass_huff (j_compress_ptr cinfo, boolean gather_statistics)
  */
 
 GLOBAL(void)
-jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
+jpeg_make_c_derived_tbl_xp (j_compress_ptr cinfo, boolean isDC, int tblno,
 			 c_derived_tbl ** pdtbl)
 {
   JHUFF_TBL *htbl;
@@ -270,17 +271,18 @@ jpeg_make_c_derived_tbl (j_compress_ptr cinfo, boolean isDC, int tblno,
 #define emit_byte(state,val,action)  \
 	{ *(state)->next_output_byte++ = (JOCTET) (val);  \
 	  if (--(state)->free_in_buffer == 0)  \
-	    if (! dump_buffer(state))  \
+	    if (! dump_buffer_xp(state))  \
 	      { action; } }
 
 
 LOCAL(boolean)
-dump_buffer (working_state * state)
+dump_buffer_xp (working_state_xp * state)
 /* Empty the output buffer; return TRUE if successful, FALSE if must suspend */
 {
-  struct jpeg_destination_mgr * dest = state->cinfo->dest;
+  struct jpeg_destination_mgr_xp * dest =
+    ((j_compress_ptr_xp) state->cinfo->client_data)->dest_xp;
 
-  if (! (*dest->empty_output_buffer) (state->cinfo))
+  if (! (*dest->empty_output_buffer_xp) (state->cinfo))
     return FALSE;
   /* After a successful buffer dump, must reset buffer pointers */
   state->next_output_byte = dest->next_output_byte;
@@ -299,7 +301,7 @@ dump_buffer (working_state * state)
 
 INLINE
 LOCAL(boolean)
-emit_bits (working_state * state, unsigned int code, int size)
+emit_bits_xp (working_state_xp * state, unsigned int code, int size)
 /* Emit some bits; return TRUE if successful, FALSE if must suspend */
 {
   /* This routine is heavily used, so it's worth coding tightly. */
@@ -337,9 +339,9 @@ emit_bits (working_state * state, unsigned int code, int size)
 
 
 LOCAL(boolean)
-flush_bits (working_state * state)
+flush_bits_xp (working_state_xp * state)
 {
-  if (! emit_bits(state, 0x7F, 7)) /* fill any partial byte with ones */
+  if (! emit_bits_xp(state, 0x7F, 7)) /* fill any partial byte with ones */
     return FALSE;
   state->cur.put_buffer = 0;	/* and reset bit-buffer to empty */
   state->cur.put_bits = 0;
@@ -350,7 +352,7 @@ flush_bits (working_state * state)
 /* Encode a single block's worth of coefficients */
 
 LOCAL(boolean)
-encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
+encode_one_block_xp (working_state_xp * state, JCOEFPTR block, int last_dc_val,
 		  c_derived_tbl *dctbl, c_derived_tbl *actbl)
 {
   register int temp, temp2;
@@ -381,13 +383,13 @@ encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
     ERREXIT(state->cinfo, JERR_BAD_DCT_COEF);
   
   /* Emit the Huffman-coded symbol for the number of bits */
-  if (! emit_bits(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
+  if (! emit_bits_xp(state, dctbl->ehufco[nbits], dctbl->ehufsi[nbits]))
     return FALSE;
 
   /* Emit that number of bits of the value, if positive, */
   /* or the complement of its magnitude, if negative. */
   if (nbits)			/* emit_bits rejects calls with size 0 */
-    if (! emit_bits(state, (unsigned int) temp2, nbits))
+    if (! emit_bits_xp(state, (unsigned int) temp2, nbits))
       return FALSE;
 
   /* Encode the AC coefficients per section F.1.2.2 */
@@ -400,7 +402,7 @@ encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
     } else {
       /* if run length > 15, must emit special run-length-16 codes (0xF0) */
       while (r > 15) {
-	if (! emit_bits(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
+	if (! emit_bits_xp(state, actbl->ehufco[0xF0], actbl->ehufsi[0xF0]))
 	  return FALSE;
 	r -= 16;
       }
@@ -422,12 +424,12 @@ encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
       
       /* Emit Huffman symbol for run length / number of bits */
       i = (r << 4) + nbits;
-      if (! emit_bits(state, actbl->ehufco[i], actbl->ehufsi[i]))
+      if (! emit_bits_xp(state, actbl->ehufco[i], actbl->ehufsi[i]))
 	return FALSE;
 
       /* Emit that number of bits of the value, if positive, */
       /* or the complement of its magnitude, if negative. */
-      if (! emit_bits(state, (unsigned int) temp2, nbits))
+      if (! emit_bits_xp(state, (unsigned int) temp2, nbits))
 	return FALSE;
       
       r = 0;
@@ -436,7 +438,7 @@ encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
 
   /* If the last coef(s) were zero, emit an end-of-block code */
   if (r > 0)
-    if (! emit_bits(state, actbl->ehufco[0], actbl->ehufsi[0]))
+    if (! emit_bits_xp(state, actbl->ehufco[0], actbl->ehufsi[0]))
       return FALSE;
 
   return TRUE;
@@ -448,11 +450,11 @@ encode_one_block (working_state * state, JCOEFPTR block, int last_dc_val,
  */
 
 LOCAL(boolean)
-emit_restart (working_state * state, int restart_num)
+emit_restart_xp (working_state_xp * state, int restart_num)
 {
   int ci;
 
-  if (! flush_bits(state))
+  if (! flush_bits_xp(state))
     return FALSE;
 
   emit_byte(state, 0xFF, return FALSE);
@@ -473,23 +475,24 @@ emit_restart (working_state * state, int restart_num)
  */
 
 METHODDEF(boolean)
-encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
+encode_mcu_huff_xp (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
-  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-  working_state state;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  huff_entropy_ptr entropy = (huff_entropy_ptr) xinfo->entropy_xp;
+  working_state_xp state;
   int blkn, ci;
   jpeg_component_info * compptr;
 
   /* Load up working state */
-  state.next_output_byte = cinfo->dest->next_output_byte;
-  state.free_in_buffer = cinfo->dest->free_in_buffer;
+  state.next_output_byte = xinfo->dest_xp->next_output_byte;
+  state.free_in_buffer = xinfo->dest_xp->free_in_buffer;
   ASSIGN_STATE(state.cur, entropy->saved);
   state.cinfo = cinfo;
 
   /* Emit restart marker if needed */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
-      if (! emit_restart(&state, entropy->next_restart_num))
+      if (! emit_restart_xp(&state, entropy->next_restart_num))
 	return FALSE;
   }
 
@@ -497,7 +500,7 @@ encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
     ci = cinfo->MCU_membership[blkn];
     compptr = cinfo->cur_comp_info[ci];
-    if (! encode_one_block(&state,
+    if (! encode_one_block_xp(&state,
 			   MCU_data[blkn][0], state.cur.last_dc_val[ci],
 			   entropy->dc_derived_tbls[compptr->dc_tbl_no],
 			   entropy->ac_derived_tbls[compptr->ac_tbl_no]))
@@ -507,8 +510,8 @@ encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   }
 
   /* Completed MCU, so update state */
-  cinfo->dest->next_output_byte = state.next_output_byte;
-  cinfo->dest->free_in_buffer = state.free_in_buffer;
+  xinfo->dest_xp->next_output_byte = state.next_output_byte;
+  xinfo->dest_xp->free_in_buffer = state.free_in_buffer;
   ASSIGN_STATE(entropy->saved, state.cur);
 
   /* Update restart-interval state too */
@@ -530,24 +533,25 @@ encode_mcu_huff (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 METHODDEF(void)
-finish_pass_huff (j_compress_ptr cinfo)
+finish_pass_huff_xp (j_compress_ptr cinfo)
 {
-  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
-  working_state state;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  huff_entropy_ptr entropy = (huff_entropy_ptr) xinfo->entropy_xp;
+  working_state_xp state;
 
   /* Load up working state ... flush_bits needs it */
-  state.next_output_byte = cinfo->dest->next_output_byte;
-  state.free_in_buffer = cinfo->dest->free_in_buffer;
+  state.next_output_byte = xinfo->dest_xp->next_output_byte;
+  state.free_in_buffer = xinfo->dest_xp->free_in_buffer;
   ASSIGN_STATE(state.cur, entropy->saved);
   state.cinfo = cinfo;
 
   /* Flush out the last data */
-  if (! flush_bits(&state))
+  if (! flush_bits_xp(&state))
     ERREXIT(cinfo, JERR_CANT_SUSPEND);
 
   /* Update state */
-  cinfo->dest->next_output_byte = state.next_output_byte;
-  cinfo->dest->free_in_buffer = state.free_in_buffer;
+  xinfo->dest_xp->next_output_byte = state.next_output_byte;
+  xinfo->dest_xp->free_in_buffer = state.free_in_buffer;
   ASSIGN_STATE(entropy->saved, state.cur);
 }
 
@@ -569,7 +573,7 @@ finish_pass_huff (j_compress_ptr cinfo)
 /* Process a single block's worth of coefficients */
 
 LOCAL(void)
-htest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
+htest_one_block_xp (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
 		 long dc_counts[], long ac_counts[])
 {
   register int temp;
@@ -642,9 +646,10 @@ htest_one_block (j_compress_ptr cinfo, JCOEFPTR block, int last_dc_val,
  */
 
 METHODDEF(boolean)
-encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
+encode_mcu_gather_xp (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
-  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
+  huff_entropy_ptr entropy =
+    (huff_entropy_ptr) ((j_compress_ptr_xp) cinfo->client_data)->entropy_xp;
   int blkn, ci;
   jpeg_component_info * compptr;
 
@@ -663,7 +668,7 @@ encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   for (blkn = 0; blkn < cinfo->blocks_in_MCU; blkn++) {
     ci = cinfo->MCU_membership[blkn];
     compptr = cinfo->cur_comp_info[ci];
-    htest_one_block(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
+    htest_one_block_xp(cinfo, MCU_data[blkn][0], entropy->saved.last_dc_val[ci],
 		    entropy->dc_count_ptrs[compptr->dc_tbl_no],
 		    entropy->ac_count_ptrs[compptr->ac_tbl_no]);
     entropy->saved.last_dc_val[ci] = MCU_data[blkn][0][0];
@@ -702,7 +707,7 @@ encode_mcu_gather (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 GLOBAL(void)
-jpeg_gen_optimal_table (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
+jpeg_gen_optimal_table_xp (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
 {
 #define MAX_CLEN 32		/* assumed maximum initial code length */
   UINT8 bits[MAX_CLEN+1];	/* bits[k] = # of symbols with code length k */
@@ -843,9 +848,10 @@ jpeg_gen_optimal_table (j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[])
  */
 
 METHODDEF(void)
-finish_pass_gather (j_compress_ptr cinfo)
+finish_pass_gather_xp (j_compress_ptr cinfo)
 {
-  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
+  huff_entropy_ptr entropy =
+    (huff_entropy_ptr) ((j_compress_ptr_xp) cinfo->client_data)->entropy_xp;
   int ci, dctbl, actbl;
   jpeg_component_info * compptr;
   JHUFF_TBL **htblptr;
@@ -866,14 +872,14 @@ finish_pass_gather (j_compress_ptr cinfo)
       htblptr = & cinfo->dc_huff_tbl_ptrs[dctbl];
       if (*htblptr == NULL)
 	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
-      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
+      jpeg_gen_optimal_table_xp(cinfo, *htblptr, entropy->dc_count_ptrs[dctbl]);
       did_dc[dctbl] = TRUE;
     }
     if (! did_ac[actbl]) {
       htblptr = & cinfo->ac_huff_tbl_ptrs[actbl];
       if (*htblptr == NULL)
 	*htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
-      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
+      jpeg_gen_optimal_table_xp(cinfo, *htblptr, entropy->ac_count_ptrs[actbl]);
       did_ac[actbl] = TRUE;
     }
   }
@@ -888,16 +894,17 @@ finish_pass_gather (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_huff_encoder (j_compress_ptr cinfo)
+jinit_huff_encoder_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   huff_entropy_ptr entropy;
   int i;
 
   entropy = (huff_entropy_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(huff_entropy_encoder));
-  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
-  entropy->pub.start_pass = start_pass_huff;
+  xinfo->entropy_xp = (struct jpeg_entropy_encoder_xp *) entropy;
+  entropy->pub.start_pass_xp = start_pass_huff_xp;
 
   /* Mark tables unallocated */
   for (i = 0; i < NUM_HUFF_TBLS; i++) {
diff --git a/jchuff.h b/xjchuff.h
similarity index 86%
rename from jchuff.h
rename to xjchuff.h
index a9599fc..a3b2aa6 100644
--- a/jchuff.h
+++ b/xjchuff.h
@@ -1,5 +1,5 @@
 /*
- * jchuff.h
+ * xjchuff.h
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,7 +16,7 @@
  * Hence the magnitude should always fit in 10 or 14 bits respectively.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define MAX_COEF_BITS 10
 #else
 #define MAX_COEF_BITS 14
@@ -33,15 +33,15 @@ typedef struct {
 /* Short forms of external names for systems with brain-damaged linkers. */
 
 #ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jpeg_make_c_derived_tbl	jMkCDerived
-#define jpeg_gen_optimal_table	jGenOptTbl
+#define jpeg_make_c_derived_tbl_xp	jMkCDerivedXp
+#define jpeg_gen_optimal_table_xp	jGenOptTblXp
 #endif /* NEED_SHORT_EXTERNAL_NAMES */
 
 /* Expand a Huffman table definition into the derived format */
-EXTERN(void) jpeg_make_c_derived_tbl
+EXTERN(void) jpeg_make_c_derived_tbl_xp
 	JPP((j_compress_ptr cinfo, boolean isDC, int tblno,
 	     c_derived_tbl ** pdtbl));
 
 /* Generate an optimal table definition given the specified counts */
-EXTERN(void) jpeg_gen_optimal_table
+EXTERN(void) jpeg_gen_optimal_table_xp
 	JPP((j_compress_ptr cinfo, JHUFF_TBL * htbl, long freq[]));
diff --git a/jcinit.c b/xjcinit.c
similarity index 70%
rename from jcinit.c
rename to xjcinit.c
index 5efffe3..2314bb0 100644
--- a/jcinit.c
+++ b/xjcinit.c
@@ -1,5 +1,5 @@
 /*
- * jcinit.c
+ * xjcinit.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -17,7 +17,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /*
@@ -27,46 +27,47 @@
  */
 
 GLOBAL(void)
-jinit_compress_master (j_compress_ptr cinfo)
+jinit_compress_master_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   /* Initialize master control (includes parameter checking/processing) */
-  jinit_c_master_control(cinfo, FALSE /* full compression */);
+  jinit_c_master_control_xp(cinfo, FALSE /* full compression */);
 
   /* Preprocessing */
   if (! cinfo->raw_data_in) {
-    jinit_color_converter(cinfo);
-    jinit_downsampler(cinfo);
-    jinit_c_prep_controller(cinfo, FALSE /* never need full buffer here */);
+    jinit_color_converter_xp(cinfo);
+    jinit_downsampler_xp(cinfo);
+    jinit_c_prep_controller_xp(cinfo, FALSE /* never need full buffer here */);
   }
   /* Forward DCT */
-  jinit_forward_dct(cinfo);
+  jinit_forward_dct_xp(cinfo);
   /* Entropy encoding: either Huffman or arithmetic coding. */
   if (cinfo->arith_code) {
     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
   } else {
     if (cinfo->progressive_mode) {
 #ifdef C_PROGRESSIVE_SUPPORTED
-      jinit_phuff_encoder(cinfo);
+      jinit_phuff_encoder_xp(cinfo);
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
     } else
-      jinit_huff_encoder(cinfo);
+      jinit_huff_encoder_xp(cinfo);
   }
 
   /* Need a full-image coefficient buffer in any multi-pass mode. */
-  jinit_c_coef_controller(cinfo,
+  jinit_c_coef_controller_xp(cinfo,
 		(boolean) (cinfo->num_scans > 1 || cinfo->optimize_coding));
-  jinit_c_main_controller(cinfo, FALSE /* never need full buffer here */);
+  jinit_c_main_controller_xp(cinfo, FALSE /* never need full buffer here */);
 
-  jinit_marker_writer(cinfo);
+  jinit_marker_writer_xp(cinfo);
 
   /* We can now tell the memory manager to allocate virtual arrays. */
-  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
+  (*cinfo->mem->realize_virt_arrays_xp) ((j_common_ptr) cinfo);
 
   /* Write the datastream header (SOI) immediately.
    * Frame and scan headers are postponed till later.
    * This lets application insert special markers after the SOI.
    */
-  (*cinfo->marker->write_file_header) (cinfo);
+  (*xinfo->marker_xp->write_file_header_xp) (cinfo);
 }
diff --git a/jcmainct.c b/xjcmainct.c
similarity index 82%
rename from jcmainct.c
rename to xjcmainct.c
index e0279a7..29abc79 100644
--- a/jcmainct.c
+++ b/xjcmainct.c
@@ -1,5 +1,5 @@
 /*
- * jcmainct.c
+ * xjcmainct.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -12,7 +12,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Note: currently, there is no operating mode in which a full-image buffer
@@ -26,7 +26,7 @@
 /* Private buffer controller object */
 
 typedef struct {
-  struct jpeg_c_main_controller pub; /* public fields */
+  struct jpeg_c_main_controller_xp pub; /* public fields */
 
   JDIMENSION cur_iMCU_row;	/* number of current iMCU row */
   JDIMENSION rowgroup_ctr;	/* counts row groups received in iMCU row */
@@ -37,7 +37,7 @@ typedef struct {
    * (we allocate one for each component).  In the full-image case, this
    * points to the currently accessible strips of the virtual arrays.
    */
-  JSAMPARRAY buffer[MAX_COMPONENTS];
+  JSAMPARRAYXP buffer[MAX_COMPONENTS];
 
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
   /* If using full-image storage, this array holds pointers to virtual-array
@@ -45,18 +45,18 @@ typedef struct {
    */
   jvirt_sarray_ptr whole_image[MAX_COMPONENTS];
 #endif
-} my_main_controller;
+} my_main_controller_xp;
 
-typedef my_main_controller * my_main_ptr;
+typedef my_main_controller_xp * my_main_ptr;
 
 
 /* Forward declarations */
-METHODDEF(void) process_data_simple_main
-	JPP((j_compress_ptr cinfo, JSAMPARRAY input_buf,
+METHODDEF(void) process_data_simple_main_xp
+	JPP((j_compress_ptr cinfo, JSAMPARRAYXP input_buf,
 	     JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail));
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
-METHODDEF(void) process_data_buffer_main
-	JPP((j_compress_ptr cinfo, JSAMPARRAY input_buf,
+METHODDEF(void) process_data_buffer_main_xp
+	JPP((j_compress_ptr cinfo, JSAMPARRAYXP input_buf,
 	     JDIMENSION *in_row_ctr, JDIMENSION in_rows_avail));
 #endif
 
@@ -66,9 +66,10 @@ METHODDEF(void) process_data_buffer_main
  */
 
 METHODDEF(void)
-start_pass_main (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
+start_pass_main_xp (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
 
   /* Do nothing in raw-data mode. */
   if (cinfo->raw_data_in)
@@ -85,7 +86,7 @@ start_pass_main (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
     if (main->whole_image[0] != NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 #endif
-    main->pub.process_data = process_data_simple_main;
+    main->pub.process_data_xp = process_data_simple_main_xp;
     break;
 #ifdef FULL_MAIN_BUFFER_SUPPORTED
   case JBUF_SAVE_SOURCE:
@@ -110,16 +111,18 @@ start_pass_main (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
  */
 
 METHODDEF(void)
-process_data_simple_main (j_compress_ptr cinfo,
-			  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
-			  JDIMENSION in_rows_avail)
+process_data_simple_main_xp (j_compress_ptr cinfo,
+                                JSAMPARRAYXP input_buf,
+                                JDIMENSION *in_row_ctr,
+                                JDIMENSION in_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
 
   while (main->cur_iMCU_row < cinfo->total_iMCU_rows) {
     /* Read input data if we haven't filled the main buffer yet */
     if (main->rowgroup_ctr < DCTSIZE)
-      (*cinfo->prep->pre_process_data) (cinfo,
+      (*xinfo->prep_xp->pre_process_data_xp) (cinfo,
 					input_buf, in_row_ctr, in_rows_avail,
 					main->buffer, &main->rowgroup_ctr,
 					(JDIMENSION) DCTSIZE);
@@ -132,7 +135,7 @@ process_data_simple_main (j_compress_ptr cinfo,
       return;
 
     /* Send the completed row to the compressor */
-    if (! (*cinfo->coef->compress_data) (cinfo, main->buffer)) {
+    if (! (*xinfo->coef_xp->compress_data_xp) (cinfo, main->buffer)) {
       /* If compressor did not consume the whole row, then we must need to
        * suspend processing and return to the application.  In this situation
        * we pretend we didn't yet consume the last input row; otherwise, if
@@ -166,9 +169,10 @@ process_data_simple_main (j_compress_ptr cinfo,
  */
 
 METHODDEF(void)
-process_data_buffer_main (j_compress_ptr cinfo,
-			  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
-			  JDIMENSION in_rows_avail)
+process_data_buffer_main_xp (j_compress_ptr cinfo,
+                                JSAMPARRAYXP input_buf,
+                                JDIMENSION *in_row_ctr,
+                                JDIMENSION in_rows_avail)
 {
   my_main_ptr main = (my_main_ptr) cinfo->main;
   int ci;
@@ -180,7 +184,7 @@ process_data_buffer_main (j_compress_ptr cinfo,
     if (main->rowgroup_ctr == 0) {
       for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 	   ci++, compptr++) {
-	main->buffer[ci] = (*cinfo->mem->access_virt_sarray)
+	main->buffer[ci] = (*cinfo->mem->access_virt_sarray_xp)
 	  ((j_common_ptr) cinfo, main->whole_image[ci],
 	   main->cur_iMCU_row * (compptr->v_samp_factor * DCTSIZE),
 	   (JDIMENSION) (compptr->v_samp_factor * DCTSIZE), writing);
@@ -242,17 +246,18 @@ process_data_buffer_main (j_compress_ptr cinfo,
  */
 
 GLOBAL(void)
-jinit_c_main_controller (j_compress_ptr cinfo, boolean need_full_buffer)
+jinit_c_main_controller_xp (j_compress_ptr cinfo, boolean need_full_buffer)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_main_ptr main;
   int ci;
   jpeg_component_info *compptr;
 
   main = (my_main_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				SIZEOF(my_main_controller));
-  cinfo->main = (struct jpeg_c_main_controller *) main;
-  main->pub.start_pass = start_pass_main;
+				SIZEOF(my_main_controller_xp));
+  xinfo->main_xp = (struct jpeg_c_main_controller_xp *) main;
+  main->pub.start_pass_xp = start_pass_main_xp;
 
   /* We don't need to create a buffer in raw-data mode. */
   if (cinfo->raw_data_in)
@@ -284,7 +289,7 @@ jinit_c_main_controller (j_compress_ptr cinfo, boolean need_full_buffer)
     /* Allocate a strip buffer for each component */
     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 	 ci++, compptr++) {
-      main->buffer[ci] = (*cinfo->mem->alloc_sarray)
+      main->buffer[ci] = (*cinfo->mem->alloc_sarray_xp)
 	((j_common_ptr) cinfo, JPOOL_IMAGE,
 	 compptr->width_in_blocks * DCTSIZE,
 	 (JDIMENSION) (compptr->v_samp_factor * DCTSIZE));
diff --git a/jcmarker.c b/xjcmarker.c
similarity index 66%
rename from jcmarker.c
rename to xjcmarker.c
index 3d1e6c6..2e9ed29 100644
--- a/jcmarker.c
+++ b/xjcmarker.c
@@ -1,5 +1,5 @@
 /*
- * jcmarker.c
+ * xjcmarker.c
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -10,7 +10,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 typedef enum {			/* JPEG marker codes */
@@ -84,7 +84,7 @@ typedef enum {			/* JPEG marker codes */
 /* Private state */
 
 typedef struct {
-  struct jpeg_marker_writer pub; /* public fields */
+  struct jpeg_marker_writer_xp pub; /* public fields */
 
   unsigned int last_restart_interval; /* last DRI value emitted; 0 after SOI */
 } my_marker_writer;
@@ -105,34 +105,35 @@ typedef my_marker_writer * my_marker_ptr;
  */
 
 LOCAL(void)
-emit_byte (j_compress_ptr cinfo, int val)
+emit_byte_xp (j_compress_ptr cinfo, int val)
 /* Emit a byte */
 {
-  struct jpeg_destination_mgr * dest = cinfo->dest;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  struct jpeg_destination_mgr_xp * dest = xinfo->dest_xp;
 
   *(dest->next_output_byte)++ = (JOCTET) val;
   if (--dest->free_in_buffer == 0) {
-    if (! (*dest->empty_output_buffer) (cinfo))
+    if (! (*dest->empty_output_buffer_xp) (cinfo))
       ERREXIT(cinfo, JERR_CANT_SUSPEND);
   }
 }
 
 
 LOCAL(void)
-emit_marker (j_compress_ptr cinfo, JPEG_MARKER mark)
+emit_marker_xp (j_compress_ptr cinfo, JPEG_MARKER mark)
 /* Emit a marker code */
 {
-  emit_byte(cinfo, 0xFF);
-  emit_byte(cinfo, (int) mark);
+  emit_byte_xp(cinfo, 0xFF);
+  emit_byte_xp(cinfo, (int) mark);
 }
 
 
 LOCAL(void)
-emit_2bytes (j_compress_ptr cinfo, int value)
+emit_2bytes_xp (j_compress_ptr cinfo, int value)
 /* Emit a 2-byte integer; these are always MSB first in JPEG files */
 {
-  emit_byte(cinfo, (value >> 8) & 0xFF);
-  emit_byte(cinfo, value & 0xFF);
+  emit_byte_xp(cinfo, (value >> 8) & 0xFF);
+  emit_byte_xp(cinfo, value & 0xFF);
 }
 
 
@@ -141,7 +142,7 @@ emit_2bytes (j_compress_ptr cinfo, int value)
  */
 
 LOCAL(int)
-emit_dqt (j_compress_ptr cinfo, int index)
+emit_dqt_xp (j_compress_ptr cinfo, int index)
 /* Emit a DQT marker */
 /* Returns the precision used (0 = 8bits, 1 = 16bits) for baseline checking */
 {
@@ -159,18 +160,18 @@ emit_dqt (j_compress_ptr cinfo, int index)
   }
 
   if (! qtbl->sent_table) {
-    emit_marker(cinfo, M_DQT);
+    emit_marker_xp(cinfo, M_DQT);
 
-    emit_2bytes(cinfo, prec ? DCTSIZE2*2 + 1 + 2 : DCTSIZE2 + 1 + 2);
+    emit_2bytes_xp(cinfo, prec ? DCTSIZE2*2 + 1 + 2 : DCTSIZE2 + 1 + 2);
 
-    emit_byte(cinfo, index + (prec<<4));
+    emit_byte_xp(cinfo, index + (prec<<4));
 
     for (i = 0; i < DCTSIZE2; i++) {
       /* The table entries must be emitted in zigzag order. */
       unsigned int qval = qtbl->quantval[jpeg_natural_order[i]];
       if (prec)
-	emit_byte(cinfo, (int) (qval >> 8));
-      emit_byte(cinfo, (int) (qval & 0xFF));
+	emit_byte_xp(cinfo, (int) (qval >> 8));
+      emit_byte_xp(cinfo, (int) (qval & 0xFF));
     }
 
     qtbl->sent_table = TRUE;
@@ -181,7 +182,7 @@ emit_dqt (j_compress_ptr cinfo, int index)
 
 
 LOCAL(void)
-emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)
+emit_dht_xp (j_compress_ptr cinfo, int index, boolean is_ac)
 /* Emit a DHT marker */
 {
   JHUFF_TBL * htbl;
@@ -198,20 +199,20 @@ emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)
     ERREXIT1(cinfo, JERR_NO_HUFF_TABLE, index);
   
   if (! htbl->sent_table) {
-    emit_marker(cinfo, M_DHT);
+    emit_marker_xp(cinfo, M_DHT);
     
     length = 0;
     for (i = 1; i <= 16; i++)
       length += htbl->bits[i];
     
-    emit_2bytes(cinfo, length + 2 + 1 + 16);
-    emit_byte(cinfo, index);
+    emit_2bytes_xp(cinfo, length + 2 + 1 + 16);
+    emit_byte_xp(cinfo, index);
     
     for (i = 1; i <= 16; i++)
-      emit_byte(cinfo, htbl->bits[i]);
+      emit_byte_xp(cinfo, htbl->bits[i]);
     
     for (i = 0; i < length; i++)
-      emit_byte(cinfo, htbl->huffval[i]);
+      emit_byte_xp(cinfo, htbl->huffval[i]);
     
     htbl->sent_table = TRUE;
   }
@@ -219,7 +220,7 @@ emit_dht (j_compress_ptr cinfo, int index, boolean is_ac)
 
 
 LOCAL(void)
-emit_dac (j_compress_ptr cinfo)
+emit_dac_xp (j_compress_ptr cinfo)
 /* Emit a DAC marker */
 /* Since the useful info is so small, we want to emit all the tables in */
 /* one DAC marker.  Therefore this routine does its own scan of the table. */
@@ -243,18 +244,18 @@ emit_dac (j_compress_ptr cinfo)
   for (i = 0; i < NUM_ARITH_TBLS; i++)
     length += dc_in_use[i] + ac_in_use[i];
   
-  emit_marker(cinfo, M_DAC);
+  emit_marker_xp(cinfo, M_DAC);
   
-  emit_2bytes(cinfo, length*2 + 2);
+  emit_2bytes_xp(cinfo, length*2 + 2);
   
   for (i = 0; i < NUM_ARITH_TBLS; i++) {
     if (dc_in_use[i]) {
-      emit_byte(cinfo, i);
-      emit_byte(cinfo, cinfo->arith_dc_L[i] + (cinfo->arith_dc_U[i]<<4));
+      emit_byte_xp(cinfo, i);
+      emit_byte_xp(cinfo, cinfo->arith_dc_L[i] + (cinfo->arith_dc_U[i]<<4));
     }
     if (ac_in_use[i]) {
-      emit_byte(cinfo, i + 0x10);
-      emit_byte(cinfo, cinfo->arith_ac_K[i]);
+      emit_byte_xp(cinfo, i + 0x10);
+      emit_byte_xp(cinfo, cinfo->arith_ac_K[i]);
     }
   }
 #endif /* C_ARITH_CODING_SUPPORTED */
@@ -262,64 +263,64 @@ emit_dac (j_compress_ptr cinfo)
 
 
 LOCAL(void)
-emit_dri (j_compress_ptr cinfo)
+emit_dri_xp (j_compress_ptr cinfo)
 /* Emit a DRI marker */
 {
-  emit_marker(cinfo, M_DRI);
+  emit_marker_xp(cinfo, M_DRI);
   
-  emit_2bytes(cinfo, 4);	/* fixed length */
+  emit_2bytes_xp(cinfo, 4);	/* fixed length */
 
-  emit_2bytes(cinfo, (int) cinfo->restart_interval);
+  emit_2bytes_xp(cinfo, (int) cinfo->restart_interval);
 }
 
 
 LOCAL(void)
-emit_sof (j_compress_ptr cinfo, JPEG_MARKER code)
+emit_sof_xp (j_compress_ptr cinfo, JPEG_MARKER code)
 /* Emit a SOF marker */
 {
   int ci;
   jpeg_component_info *compptr;
   
-  emit_marker(cinfo, code);
+  emit_marker_xp(cinfo, code);
   
-  emit_2bytes(cinfo, 3 * cinfo->num_components + 2 + 5 + 1); /* length */
+  emit_2bytes_xp(cinfo, 3 * cinfo->num_components + 2 + 5 + 1); /* length */
 
   /* Make sure image isn't bigger than SOF field can handle */
   if ((long) cinfo->image_height > 65535L ||
       (long) cinfo->image_width > 65535L)
     ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) 65535);
 
-  emit_byte(cinfo, cinfo->data_precision);
-  emit_2bytes(cinfo, (int) cinfo->image_height);
-  emit_2bytes(cinfo, (int) cinfo->image_width);
+  emit_byte_xp(cinfo, cinfo->data_precision);
+  emit_2bytes_xp(cinfo, (int) cinfo->image_height);
+  emit_2bytes_xp(cinfo, (int) cinfo->image_width);
 
-  emit_byte(cinfo, cinfo->num_components);
+  emit_byte_xp(cinfo, cinfo->num_components);
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
-    emit_byte(cinfo, compptr->component_id);
-    emit_byte(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);
-    emit_byte(cinfo, compptr->quant_tbl_no);
+    emit_byte_xp(cinfo, compptr->component_id);
+    emit_byte_xp(cinfo, (compptr->h_samp_factor << 4) + compptr->v_samp_factor);
+    emit_byte_xp(cinfo, compptr->quant_tbl_no);
   }
 }
 
 
 LOCAL(void)
-emit_sos (j_compress_ptr cinfo)
+emit_sos_xp (j_compress_ptr cinfo)
 /* Emit a SOS marker */
 {
   int i, td, ta;
   jpeg_component_info *compptr;
   
-  emit_marker(cinfo, M_SOS);
+  emit_marker_xp(cinfo, M_SOS);
   
-  emit_2bytes(cinfo, 2 * cinfo->comps_in_scan + 2 + 1 + 3); /* length */
+  emit_2bytes_xp(cinfo, 2 * cinfo->comps_in_scan + 2 + 1 + 3); /* length */
   
-  emit_byte(cinfo, cinfo->comps_in_scan);
+  emit_byte_xp(cinfo, cinfo->comps_in_scan);
   
   for (i = 0; i < cinfo->comps_in_scan; i++) {
     compptr = cinfo->cur_comp_info[i];
-    emit_byte(cinfo, compptr->component_id);
+    emit_byte_xp(cinfo, compptr->component_id);
     td = compptr->dc_tbl_no;
     ta = compptr->ac_tbl_no;
     if (cinfo->progressive_mode) {
@@ -336,17 +337,17 @@ emit_sos (j_compress_ptr cinfo)
 	td = 0;			/* AC scan */
       }
     }
-    emit_byte(cinfo, (td << 4) + ta);
+    emit_byte_xp(cinfo, (td << 4) + ta);
   }
 
-  emit_byte(cinfo, cinfo->Ss);
-  emit_byte(cinfo, cinfo->Se);
-  emit_byte(cinfo, (cinfo->Ah << 4) + cinfo->Al);
+  emit_byte_xp(cinfo, cinfo->Ss);
+  emit_byte_xp(cinfo, cinfo->Se);
+  emit_byte_xp(cinfo, (cinfo->Ah << 4) + cinfo->Al);
 }
 
 
 LOCAL(void)
-emit_jfif_app0 (j_compress_ptr cinfo)
+emit_jfif_app0_xp (j_compress_ptr cinfo)
 /* Emit a JFIF-compliant APP0 marker */
 {
   /*
@@ -361,27 +362,27 @@ emit_jfif_app0 (j_compress_ptr cinfo)
    * Thumbnail Y size		(1 byte)
    */
   
-  emit_marker(cinfo, M_APP0);
+  emit_marker_xp(cinfo, M_APP0);
   
-  emit_2bytes(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1); /* length */
-
-  emit_byte(cinfo, 0x4A);	/* Identifier: ASCII "JFIF" */
-  emit_byte(cinfo, 0x46);
-  emit_byte(cinfo, 0x49);
-  emit_byte(cinfo, 0x46);
-  emit_byte(cinfo, 0);
-  emit_byte(cinfo, cinfo->JFIF_major_version); /* Version fields */
-  emit_byte(cinfo, cinfo->JFIF_minor_version);
-  emit_byte(cinfo, cinfo->density_unit); /* Pixel size information */
-  emit_2bytes(cinfo, (int) cinfo->X_density);
-  emit_2bytes(cinfo, (int) cinfo->Y_density);
-  emit_byte(cinfo, 0);		/* No thumbnail image */
-  emit_byte(cinfo, 0);
+  emit_2bytes_xp(cinfo, 2 + 4 + 1 + 2 + 1 + 2 + 2 + 1 + 1); /* length */
+
+  emit_byte_xp(cinfo, 0x4A);	/* Identifier: ASCII "JFIF" */
+  emit_byte_xp(cinfo, 0x46);
+  emit_byte_xp(cinfo, 0x49);
+  emit_byte_xp(cinfo, 0x46);
+  emit_byte_xp(cinfo, 0);
+  emit_byte_xp(cinfo, cinfo->JFIF_major_version); /* Version fields */
+  emit_byte_xp(cinfo, cinfo->JFIF_minor_version);
+  emit_byte_xp(cinfo, cinfo->density_unit); /* Pixel size information */
+  emit_2bytes_xp(cinfo, (int) cinfo->X_density);
+  emit_2bytes_xp(cinfo, (int) cinfo->Y_density);
+  emit_byte_xp(cinfo, 0);		/* No thumbnail image */
+  emit_byte_xp(cinfo, 0);
 }
 
 
 LOCAL(void)
-emit_adobe_app14 (j_compress_ptr cinfo)
+emit_adobe_app14_xp (j_compress_ptr cinfo)
 /* Emit an Adobe APP14 marker */
 {
   /*
@@ -400,27 +401,27 @@ emit_adobe_app14 (j_compress_ptr cinfo)
    * whether the encoder performed a transformation, which is pretty useless.
    */
   
-  emit_marker(cinfo, M_APP14);
+  emit_marker_xp(cinfo, M_APP14);
   
-  emit_2bytes(cinfo, 2 + 5 + 2 + 2 + 2 + 1); /* length */
-
-  emit_byte(cinfo, 0x41);	/* Identifier: ASCII "Adobe" */
-  emit_byte(cinfo, 0x64);
-  emit_byte(cinfo, 0x6F);
-  emit_byte(cinfo, 0x62);
-  emit_byte(cinfo, 0x65);
-  emit_2bytes(cinfo, 100);	/* Version */
-  emit_2bytes(cinfo, 0);	/* Flags0 */
-  emit_2bytes(cinfo, 0);	/* Flags1 */
+  emit_2bytes_xp(cinfo, 2 + 5 + 2 + 2 + 2 + 1); /* length */
+
+  emit_byte_xp(cinfo, 0x41);	/* Identifier: ASCII "Adobe" */
+  emit_byte_xp(cinfo, 0x64);
+  emit_byte_xp(cinfo, 0x6F);
+  emit_byte_xp(cinfo, 0x62);
+  emit_byte_xp(cinfo, 0x65);
+  emit_2bytes_xp(cinfo, 100);	/* Version */
+  emit_2bytes_xp(cinfo, 0);	/* Flags0 */
+  emit_2bytes_xp(cinfo, 0);	/* Flags1 */
   switch (cinfo->jpeg_color_space) {
   case JCS_YCbCr:
-    emit_byte(cinfo, 1);	/* Color transform = 1 */
+    emit_byte_xp(cinfo, 1);	/* Color transform = 1 */
     break;
   case JCS_YCCK:
-    emit_byte(cinfo, 2);	/* Color transform = 2 */
+    emit_byte_xp(cinfo, 2);	/* Color transform = 2 */
     break;
   default:
-    emit_byte(cinfo, 0);	/* Color transform = 0 */
+    emit_byte_xp(cinfo, 0);	/* Color transform = 0 */
     break;
   }
 }
@@ -435,22 +436,22 @@ emit_adobe_app14 (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-write_marker_header (j_compress_ptr cinfo, int marker, unsigned int datalen)
+write_marker_header_xp (j_compress_ptr cinfo, int marker, unsigned int datalen)
 /* Emit an arbitrary marker header */
 {
   if (datalen > (unsigned int) 65533)		/* safety check */
     ERREXIT(cinfo, JERR_BAD_LENGTH);
 
-  emit_marker(cinfo, (JPEG_MARKER) marker);
+  emit_marker_xp(cinfo, (JPEG_MARKER) marker);
 
-  emit_2bytes(cinfo, (int) (datalen + 2));	/* total length */
+  emit_2bytes_xp(cinfo, (int) (datalen + 2));	/* total length */
 }
 
 METHODDEF(void)
-write_marker_byte (j_compress_ptr cinfo, int val)
+write_marker_byte_xp (j_compress_ptr cinfo, int val)
 /* Emit one byte of marker parameters following write_marker_header */
 {
-  emit_byte(cinfo, val);
+  emit_byte_xp(cinfo, val);
 }
 
 
@@ -466,19 +467,20 @@ write_marker_byte (j_compress_ptr cinfo, int val)
  */
 
 METHODDEF(void)
-write_file_header (j_compress_ptr cinfo)
+write_file_header_xp (j_compress_ptr cinfo)
 {
-  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_marker_ptr marker = (my_marker_ptr) xinfo->marker_xp;
 
-  emit_marker(cinfo, M_SOI);	/* first the SOI */
+  emit_marker_xp(cinfo, M_SOI);	/* first the SOI */
 
   /* SOI is defined to reset restart interval to 0 */
   marker->last_restart_interval = 0;
 
   if (cinfo->write_JFIF_header)	/* next an optional JFIF APP0 */
-    emit_jfif_app0(cinfo);
+    emit_jfif_app0_xp(cinfo);
   if (cinfo->write_Adobe_marker) /* next an optional Adobe APP14 */
-    emit_adobe_app14(cinfo);
+    emit_adobe_app14_xp(cinfo);
 }
 
 
@@ -491,7 +493,7 @@ write_file_header (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-write_frame_header (j_compress_ptr cinfo)
+write_frame_header_xp (j_compress_ptr cinfo)
 {
   int ci, prec;
   boolean is_baseline;
@@ -503,7 +505,7 @@ write_frame_header (j_compress_ptr cinfo)
   prec = 0;
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
-    prec += emit_dqt(cinfo, compptr->quant_tbl_no);
+    prec += emit_dqt_xp(cinfo, compptr->quant_tbl_no);
   }
   /* now prec is nonzero iff there are any 16-bit quant tables. */
 
@@ -529,14 +531,14 @@ write_frame_header (j_compress_ptr cinfo)
 
   /* Emit the proper SOF marker */
   if (cinfo->arith_code) {
-    emit_sof(cinfo, M_SOF9);	/* SOF code for arithmetic coding */
+    emit_sof_xp(cinfo, M_SOF9);	/* SOF code for arithmetic coding */
   } else {
     if (cinfo->progressive_mode)
-      emit_sof(cinfo, M_SOF2);	/* SOF code for progressive Huffman */
+      emit_sof_xp(cinfo, M_SOF2);	/* SOF code for progressive Huffman */
     else if (is_baseline)
-      emit_sof(cinfo, M_SOF0);	/* SOF code for baseline implementation */
+      emit_sof_xp(cinfo, M_SOF0);	/* SOF code for baseline implementation */
     else
-      emit_sof(cinfo, M_SOF1);	/* SOF code for non-baseline Huffman file */
+      emit_sof_xp(cinfo, M_SOF1);	/* SOF code for non-baseline Huffman file */
   }
 }
 
@@ -548,9 +550,10 @@ write_frame_header (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-write_scan_header (j_compress_ptr cinfo)
+write_scan_header_xp (j_compress_ptr cinfo)
 {
-  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_marker_ptr marker = (my_marker_ptr) xinfo->marker_xp;
   int i;
   jpeg_component_info *compptr;
 
@@ -559,7 +562,7 @@ write_scan_header (j_compress_ptr cinfo)
      * if the file has multiple scans, but it's so small it's hardly
      * worth worrying about.
      */
-    emit_dac(cinfo);
+    emit_dac_xp(cinfo);
   } else {
     /* Emit Huffman tables.
      * Note that emit_dht() suppresses any duplicate tables.
@@ -570,14 +573,14 @@ write_scan_header (j_compress_ptr cinfo)
 	/* Progressive mode: only DC or only AC tables are used in one scan */
 	if (cinfo->Ss == 0) {
 	  if (cinfo->Ah == 0)	/* DC needs no table for refinement scan */
-	    emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
+	    emit_dht_xp(cinfo, compptr->dc_tbl_no, FALSE);
 	} else {
-	  emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
+	  emit_dht_xp(cinfo, compptr->ac_tbl_no, TRUE);
 	}
       } else {
 	/* Sequential mode: need both DC and AC tables */
-	emit_dht(cinfo, compptr->dc_tbl_no, FALSE);
-	emit_dht(cinfo, compptr->ac_tbl_no, TRUE);
+	emit_dht_xp(cinfo, compptr->dc_tbl_no, FALSE);
+	emit_dht_xp(cinfo, compptr->ac_tbl_no, TRUE);
       }
     }
   }
@@ -586,11 +589,11 @@ write_scan_header (j_compress_ptr cinfo)
    * We avoid wasting space with unnecessary DRIs, however.
    */
   if (cinfo->restart_interval != marker->last_restart_interval) {
-    emit_dri(cinfo);
+    emit_dri_xp(cinfo);
     marker->last_restart_interval = cinfo->restart_interval;
   }
 
-  emit_sos(cinfo);
+  emit_sos_xp(cinfo);
 }
 
 
@@ -599,9 +602,9 @@ write_scan_header (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-write_file_trailer (j_compress_ptr cinfo)
+write_file_trailer_xp (j_compress_ptr cinfo)
 {
-  emit_marker(cinfo, M_EOI);
+  emit_marker_xp(cinfo, M_EOI);
 }
 
 
@@ -613,27 +616,27 @@ write_file_trailer (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-write_tables_only (j_compress_ptr cinfo)
+write_tables_only_xp (j_compress_ptr cinfo)
 {
   int i;
 
-  emit_marker(cinfo, M_SOI);
+  emit_marker_xp(cinfo, M_SOI);
 
   for (i = 0; i < NUM_QUANT_TBLS; i++) {
     if (cinfo->quant_tbl_ptrs[i] != NULL)
-      (void) emit_dqt(cinfo, i);
+      (void) emit_dqt_xp(cinfo, i);
   }
 
   if (! cinfo->arith_code) {
     for (i = 0; i < NUM_HUFF_TBLS; i++) {
       if (cinfo->dc_huff_tbl_ptrs[i] != NULL)
-	emit_dht(cinfo, i, FALSE);
+	emit_dht_xp(cinfo, i, FALSE);
       if (cinfo->ac_huff_tbl_ptrs[i] != NULL)
-	emit_dht(cinfo, i, TRUE);
+	emit_dht_xp(cinfo, i, TRUE);
     }
   }
 
-  emit_marker(cinfo, M_EOI);
+  emit_marker_xp(cinfo, M_EOI);
 }
 
 
@@ -642,23 +645,24 @@ write_tables_only (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_marker_writer (j_compress_ptr cinfo)
+jinit_marker_writer_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_marker_ptr marker;
 
   /* Create the subobject */
   marker = (my_marker_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_marker_writer));
-  cinfo->marker = (struct jpeg_marker_writer *) marker;
+  xinfo->marker_xp = (struct jpeg_marker_writer_xp *) marker;
   /* Initialize method pointers */
-  marker->pub.write_file_header = write_file_header;
-  marker->pub.write_frame_header = write_frame_header;
-  marker->pub.write_scan_header = write_scan_header;
-  marker->pub.write_file_trailer = write_file_trailer;
-  marker->pub.write_tables_only = write_tables_only;
-  marker->pub.write_marker_header = write_marker_header;
-  marker->pub.write_marker_byte = write_marker_byte;
+  marker->pub.write_file_header_xp = write_file_header_xp;
+  marker->pub.write_frame_header_xp = write_frame_header_xp;
+  marker->pub.write_scan_header_xp = write_scan_header_xp;
+  marker->pub.write_file_trailer_xp = write_file_trailer_xp;
+  marker->pub.write_tables_only_xp = write_tables_only_xp;
+  marker->pub.write_marker_header_xp = write_marker_header_xp;
+  marker->pub.write_marker_byte_xp = write_marker_byte_xp;
   /* Initialize private state */
   marker->last_restart_interval = 0;
 }
diff --git a/jcmaster.c b/xjcmaster.c
similarity index 87%
rename from jcmaster.c
rename to xjcmaster.c
index aab4020..e67aeb1 100644
--- a/jcmaster.c
+++ b/xjcmaster.c
@@ -1,5 +1,5 @@
 /*
- * jcmaster.c
+ * xjcmaster.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -13,7 +13,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Private state */
@@ -25,7 +25,7 @@ typedef enum {
 } c_pass_type;
 
 typedef struct {
-  struct jpeg_comp_master pub;	/* public fields */
+  struct jpeg_comp_master_xp pub;	/* public fields */
 
   c_pass_type pass_type;	/* the type of the current pass */
 
@@ -43,7 +43,7 @@ typedef my_comp_master * my_master_ptr;
  */
 
 LOCAL(void)
-initial_setup (j_compress_ptr cinfo)
+initial_setup_xp (j_compress_ptr cinfo)
 /* Do computations that are needed before master selection phase */
 {
   int ci;
@@ -68,7 +68,7 @@ initial_setup (j_compress_ptr cinfo)
     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
 
   /* For now, precision must match compiled-in value... */
-  if (cinfo->data_precision != BITS_IN_JSAMPLE)
+  if (cinfo->data_precision != BITS_IN_JSAMPLE12)
     ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
 
   /* Check that number of components won't exceed internal array sizes */
@@ -127,7 +127,7 @@ initial_setup (j_compress_ptr cinfo)
 #ifdef C_MULTISCAN_FILES_SUPPORTED
 
 LOCAL(void)
-validate_script (j_compress_ptr cinfo)
+validate_script_xp (j_compress_ptr cinfo)
 /* Verify that the scan script in cinfo->scan_info[] is valid; also
  * determine whether it uses progressive JPEG, and set cinfo->progressive_mode.
  */
@@ -192,7 +192,7 @@ validate_script (j_compress_ptr cinfo)
        * out-of-range reconstructed DC values during the first DC scan,
        * which might cause problems for some decoders.
        */
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define MAX_AH_AL 10
 #else
 #define MAX_AH_AL 13
@@ -264,15 +264,16 @@ validate_script (j_compress_ptr cinfo)
 
 
 LOCAL(void)
-select_scan_parameters (j_compress_ptr cinfo)
+select_scan_parameters_xp (j_compress_ptr cinfo)
 /* Set up the scan parameters for the current scan */
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   int ci;
 
 #ifdef C_MULTISCAN_FILES_SUPPORTED
   if (cinfo->scan_info != NULL) {
     /* Prepare for current scan --- the script is already validated */
-    my_master_ptr master = (my_master_ptr) cinfo->master;
+    my_master_ptr master = (my_master_ptr) xinfo->master_xp;
     const jpeg_scan_info * scanptr = cinfo->scan_info + master->scan_number;
 
     cinfo->comps_in_scan = scanptr->comps_in_scan;
@@ -305,7 +306,7 @@ select_scan_parameters (j_compress_ptr cinfo)
 
 
 LOCAL(void)
-per_scan_setup (j_compress_ptr cinfo)
+per_scan_setup_xp (j_compress_ptr cinfo)
 /* Do computations that are needed before processing a JPEG scan */
 /* cinfo->comps_in_scan and cinfo->cur_comp_info[] are already set */
 {
@@ -398,28 +399,29 @@ per_scan_setup (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-prepare_for_pass (j_compress_ptr cinfo)
+prepare_for_pass_xp (j_compress_ptr cinfo)
 {
-  my_master_ptr master = (my_master_ptr) cinfo->master;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_master_ptr master = (my_master_ptr) xinfo->master_xp;
 
   switch (master->pass_type) {
   case main_pass:
     /* Initial pass: will collect input data, and do either Huffman
      * optimization or data output for the first scan.
      */
-    select_scan_parameters(cinfo);
-    per_scan_setup(cinfo);
+    select_scan_parameters_xp(cinfo);
+    per_scan_setup_xp(cinfo);
     if (! cinfo->raw_data_in) {
-      (*cinfo->cconvert->start_pass) (cinfo);
-      (*cinfo->downsample->start_pass) (cinfo);
-      (*cinfo->prep->start_pass) (cinfo, JBUF_PASS_THRU);
+      (*xinfo->cconvert_xp->start_pass_xp) (cinfo);
+      (*xinfo->downsample_xp->start_pass_xp) (cinfo);
+      (*xinfo->prep_xp->start_pass_xp) (cinfo, JBUF_PASS_THRU);
     }
-    (*cinfo->fdct->start_pass) (cinfo);
-    (*cinfo->entropy->start_pass) (cinfo, cinfo->optimize_coding);
-    (*cinfo->coef->start_pass) (cinfo,
+    (*xinfo->fdct_xp->start_pass_xp) (cinfo);
+    (*xinfo->entropy_xp->start_pass_xp) (cinfo, cinfo->optimize_coding);
+    (*xinfo->coef_xp->start_pass_xp) (cinfo,
 				(master->total_passes > 1 ?
 				 JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
-    (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
+    (*xinfo->main_xp->start_pass_xp) (cinfo, JBUF_PASS_THRU);
     if (cinfo->optimize_coding) {
       /* No immediate data output; postpone writing frame/scan headers */
       master->pub.call_pass_startup = FALSE;
@@ -431,11 +433,11 @@ prepare_for_pass (j_compress_ptr cinfo)
 #ifdef ENTROPY_OPT_SUPPORTED
   case huff_opt_pass:
     /* Do Huffman optimization for a scan after the first one. */
-    select_scan_parameters(cinfo);
-    per_scan_setup(cinfo);
+    select_scan_parameters_xp(cinfo);
+    per_scan_setup_xp(cinfo);
     if (cinfo->Ss != 0 || cinfo->Ah == 0 || cinfo->arith_code) {
-      (*cinfo->entropy->start_pass) (cinfo, TRUE);
-      (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
+      (*xinfo->entropy_xp->start_pass_xp) (cinfo, TRUE);
+      (*xinfo->coef_xp->start_pass_xp) (cinfo, JBUF_CRANK_DEST);
       master->pub.call_pass_startup = FALSE;
       break;
     }
@@ -450,15 +452,15 @@ prepare_for_pass (j_compress_ptr cinfo)
     /* Do a data-output pass. */
     /* We need not repeat per-scan setup if prior optimization pass did it. */
     if (! cinfo->optimize_coding) {
-      select_scan_parameters(cinfo);
-      per_scan_setup(cinfo);
+      select_scan_parameters_xp(cinfo);
+      per_scan_setup_xp(cinfo);
     }
-    (*cinfo->entropy->start_pass) (cinfo, FALSE);
-    (*cinfo->coef->start_pass) (cinfo, JBUF_CRANK_DEST);
+    (*xinfo->entropy_xp->start_pass_xp) (cinfo, FALSE);
+    (*xinfo->coef_xp->start_pass_xp) (cinfo, JBUF_CRANK_DEST);
     /* We emit frame/scan headers now */
     if (master->scan_number == 0)
-      (*cinfo->marker->write_frame_header) (cinfo);
-    (*cinfo->marker->write_scan_header) (cinfo);
+      (*xinfo->marker_xp->write_frame_header_xp) (cinfo);
+    (*xinfo->marker_xp->write_scan_header_xp) (cinfo);
     master->pub.call_pass_startup = FALSE;
     break;
   default:
@@ -486,12 +488,13 @@ prepare_for_pass (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-pass_startup (j_compress_ptr cinfo)
+pass_startup_xp (j_compress_ptr cinfo)
 {
-  cinfo->master->call_pass_startup = FALSE; /* reset flag so call only once */
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  xinfo->master_xp->call_pass_startup = FALSE; /* reset flag so call only once */
 
-  (*cinfo->marker->write_frame_header) (cinfo);
-  (*cinfo->marker->write_scan_header) (cinfo);
+  (*xinfo->marker_xp->write_frame_header_xp) (cinfo);
+  (*xinfo->marker_xp->write_scan_header_xp) (cinfo);
 }
 
 
@@ -500,14 +503,15 @@ pass_startup (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-finish_pass_master (j_compress_ptr cinfo)
+finish_pass_master_xp (j_compress_ptr cinfo)
 {
-  my_master_ptr master = (my_master_ptr) cinfo->master;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_master_ptr master = (my_master_ptr) xinfo->master_xp;
 
   /* The entropy coder always needs an end-of-pass call,
    * either to analyze statistics or to flush its output buffer.
    */
-  (*cinfo->entropy->finish_pass) (cinfo);
+  (*xinfo->entropy_xp->finish_pass_xp) (cinfo);
 
   /* Update state for next pass */
   switch (master->pass_type) {
@@ -540,25 +544,26 @@ finish_pass_master (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_c_master_control (j_compress_ptr cinfo, boolean transcode_only)
+jinit_c_master_control_xp (j_compress_ptr cinfo, boolean transcode_only)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_master_ptr master;
 
   master = (my_master_ptr)
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				  SIZEOF(my_comp_master));
-  cinfo->master = (struct jpeg_comp_master *) master;
-  master->pub.prepare_for_pass = prepare_for_pass;
-  master->pub.pass_startup = pass_startup;
-  master->pub.finish_pass = finish_pass_master;
+  xinfo->master_xp = (struct jpeg_comp_master_xp *) master;
+  master->pub.prepare_for_pass_xp = prepare_for_pass_xp;
+  master->pub.pass_startup_xp = pass_startup_xp;
+  master->pub.finish_pass_xp = finish_pass_master_xp;
   master->pub.is_last_pass = FALSE;
 
   /* Validate parameters, determine derived values */
-  initial_setup(cinfo);
+  initial_setup_xp(cinfo);
 
   if (cinfo->scan_info != NULL) {
 #ifdef C_MULTISCAN_FILES_SUPPORTED
-    validate_script(cinfo);
+    validate_script_xp(cinfo);
 #else
     ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
diff --git a/jcomapi.c b/xjcomapi.c
similarity index 93%
rename from jcomapi.c
rename to xjcomapi.c
index 9b1fa75..d21f331 100644
--- a/jcomapi.c
+++ b/xjcomapi.c
@@ -1,5 +1,5 @@
 /*
- * jcomapi.c
+ * xjcomapi.c
  *
  * Copyright (C) 1994-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -11,7 +11,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /*
@@ -26,7 +26,7 @@
  */
 
 GLOBAL(void)
-jpeg_abort (j_common_ptr cinfo)
+jpeg_abort_xp (j_common_ptr cinfo)
 {
   int pool;
 
@@ -66,7 +66,7 @@ jpeg_abort (j_common_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_destroy (j_common_ptr cinfo)
+jpeg_destroy_xp (j_common_ptr cinfo)
 {
   /* We need only tell the memory manager to release everything. */
   /* NB: mem pointer is NULL if memory mgr failed to initialize. */
@@ -77,13 +77,14 @@ jpeg_destroy (j_common_ptr cinfo)
 }
 
 
+#if 0
 /*
  * Convenience routines for allocating quantization and Huffman tables.
  * (Would jutils.c be a more reasonable place to put these?)
  */
 
 GLOBAL(JQUANT_TBL *)
-jpeg_alloc_quant_table (j_common_ptr cinfo)
+jpeg_alloc_quant_table_xp (j_common_ptr cinfo)
 {
   JQUANT_TBL *tbl;
 
@@ -95,7 +96,7 @@ jpeg_alloc_quant_table (j_common_ptr cinfo)
 
 
 GLOBAL(JHUFF_TBL *)
-jpeg_alloc_huff_table (j_common_ptr cinfo)
+jpeg_alloc_huff_table_xp (j_common_ptr cinfo)
 {
   JHUFF_TBL *tbl;
 
@@ -104,3 +105,4 @@ jpeg_alloc_huff_table (j_common_ptr cinfo)
   tbl->sent_table = FALSE;	/* make sure this is false in any new table */
   return tbl;
 }
+#endif
\ No newline at end of file
diff --git a/jcparam.c b/xjcparam.c
similarity index 91%
rename from jcparam.c
rename to xjcparam.c
index 6fc48f5..afd83cd 100644
--- a/jcparam.c
+++ b/xjcparam.c
@@ -1,5 +1,5 @@
 /*
- * jcparam.c
+ * xjcparam.c
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -12,7 +12,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /*
@@ -20,7 +20,7 @@
  */
 
 GLOBAL(void)
-jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,
+jpeg_add_quant_table_xp (j_compress_ptr cinfo, int which_tbl,
 		      const unsigned int *basic_table,
 		      int scale_factor, boolean force_baseline)
 /* Define a quantization table equal to the basic_table times
@@ -61,7 +61,7 @@ jpeg_add_quant_table (j_compress_ptr cinfo, int which_tbl,
 
 
 GLOBAL(void)
-jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
+jpeg_set_linear_quality_xp (j_compress_ptr cinfo, int scale_factor,
 			 boolean force_baseline)
 /* Set or change the 'quality' (quantization) setting, using default tables
  * and a straight percentage-scaling quality scale.  In most cases it's better
@@ -95,41 +95,41 @@ jpeg_set_linear_quality (j_compress_ptr cinfo, int scale_factor,
   };
 
   /* Set up two quantization tables using the specified scaling */
-  jpeg_add_quant_table(cinfo, 0, std_luminance_quant_tbl,
+  jpeg_add_quant_table_xp(cinfo, 0, std_luminance_quant_tbl,
 		       scale_factor, force_baseline);
-  jpeg_add_quant_table(cinfo, 1, std_chrominance_quant_tbl,
+  jpeg_add_quant_table_xp(cinfo, 1, std_chrominance_quant_tbl,
 		       scale_factor, force_baseline);
 }
 
-
-GLOBAL(int)
-jpeg_quality_scaling (int quality)
-/* Convert a user-specified quality rating to a percentage scaling factor
- * for an underlying quantization table, using our recommended scaling curve.
- * The input 'quality' factor should be 0 (terrible) to 100 (very good).
- */
-{
-  /* Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide. */
+/*
+  GLOBAL(int)
+  jpeg_quality_scaling (int quality)
+  * Convert a user-specified quality rating to a percentage scaling factor
+  * for an underlying quantization table, using our recommended scaling curve.
+  * The input 'quality' factor should be 0 (terrible) to 100 (very good).
+  *
+  {
+  // Safety limit on quality factor.  Convert 0 to 1 to avoid zero divide.
   if (quality <= 0) quality = 1;
   if (quality > 100) quality = 100;
 
-  /* The basic table is used as-is (scaling 100) for a quality of 50.
-   * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
-   * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table
-   * to make all the table entries 1 (hence, minimum quantization loss).
-   * Qualities 1..50 are converted to scaling percentage 5000/Q.
-   */
+  * The basic table is used as-is (scaling 100) for a quality of 50.
+  * Qualities 50..100 are converted to scaling percentage 200 - 2*Q;
+  * note that at Q=100 the scaling is 0, which will cause jpeg_add_quant_table
+  * to make all the table entries 1 (hence, minimum quantization loss).
+  * Qualities 1..50 are converted to scaling percentage 5000/Q.
+  *
   if (quality < 50)
-    quality = 5000 / quality;
+  quality = 5000 / quality;
   else
-    quality = 200 - quality*2;
-
+  quality = 200 - quality*2;
+  
   return quality;
-}
-
+  }
+*/
 
 GLOBAL(void)
-jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline)
+jpeg_set_quality_xp (j_compress_ptr cinfo, int quality, boolean force_baseline)
 /* Set or change the 'quality' (quantization) setting, using default tables.
  * This is the standard quality-adjusting entry point for typical user
  * interfaces; only those who want detailed control over quantization tables
@@ -140,7 +140,7 @@ jpeg_set_quality (j_compress_ptr cinfo, int quality, boolean force_baseline)
   quality = jpeg_quality_scaling(quality);
 
   /* Set up standard quality tables */
-  jpeg_set_linear_quality(cinfo, quality, force_baseline);
+  jpeg_set_linear_quality_xp(cinfo, quality, force_baseline);
 }
 
 
@@ -265,7 +265,7 @@ std_huff_tables (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_set_defaults (j_compress_ptr cinfo)
+jpeg_set_defaults_xp (j_compress_ptr cinfo)
 {
   int i;
 
@@ -284,9 +284,9 @@ jpeg_set_defaults (j_compress_ptr cinfo)
 
   /* Initialize everything not dependent on the color space */
 
-  cinfo->data_precision = BITS_IN_JSAMPLE;
+  cinfo->data_precision = BITS_IN_JSAMPLE12;
   /* Set up two quantization tables using default quality of 75 */
-  jpeg_set_quality(cinfo, 75, TRUE);
+  jpeg_set_quality_xp(cinfo, 75, TRUE);
   /* Set up two Huffman tables */
   std_huff_tables(cinfo);
 
@@ -347,7 +347,7 @@ jpeg_set_defaults (j_compress_ptr cinfo)
 
   /* Choose JPEG colorspace based on input space, set defaults accordingly */
 
-  jpeg_default_colorspace(cinfo);
+  jpeg_default_colorspace_xp(cinfo);
 }
 
 
@@ -356,26 +356,26 @@ jpeg_set_defaults (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_default_colorspace (j_compress_ptr cinfo)
+jpeg_default_colorspace_xp (j_compress_ptr cinfo)
 {
   switch (cinfo->in_color_space) {
   case JCS_GRAYSCALE:
-    jpeg_set_colorspace(cinfo, JCS_GRAYSCALE);
+    jpeg_set_colorspace_xp(cinfo, JCS_GRAYSCALE);
     break;
   case JCS_RGB:
-    jpeg_set_colorspace(cinfo, JCS_YCbCr);
+    jpeg_set_colorspace_xp(cinfo, JCS_YCbCr);
     break;
   case JCS_YCbCr:
-    jpeg_set_colorspace(cinfo, JCS_YCbCr);
+    jpeg_set_colorspace_xp(cinfo, JCS_YCbCr);
     break;
   case JCS_CMYK:
-    jpeg_set_colorspace(cinfo, JCS_CMYK); /* By default, no translation */
+    jpeg_set_colorspace_xp(cinfo, JCS_CMYK); /* By default, no translation */
     break;
   case JCS_YCCK:
-    jpeg_set_colorspace(cinfo, JCS_YCCK);
+    jpeg_set_colorspace_xp(cinfo, JCS_YCCK);
     break;
   case JCS_UNKNOWN:
-    jpeg_set_colorspace(cinfo, JCS_UNKNOWN);
+    jpeg_set_colorspace_xp(cinfo, JCS_UNKNOWN);
     break;
   default:
     ERREXIT(cinfo, JERR_BAD_IN_COLORSPACE);
@@ -388,7 +388,7 @@ jpeg_default_colorspace (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_set_colorspace (j_compress_ptr cinfo, J_COLOR_SPACE colorspace)
+jpeg_set_colorspace_xp (j_compress_ptr cinfo, J_COLOR_SPACE colorspace)
 {
   jpeg_component_info * compptr;
   int ci;
@@ -534,7 +534,7 @@ fill_dc_scans (jpeg_scan_info * scanptr, int ncomps, int Ah, int Al)
  */
 
 GLOBAL(void)
-jpeg_simple_progression (j_compress_ptr cinfo)
+jpeg_simple_progression_xp (j_compress_ptr cinfo)
 {
   int ncomps = cinfo->num_components;
   int nscans;
diff --git a/jcphuff.c b/xjcphuff.c
similarity index 83%
rename from jcphuff.c
rename to xjcphuff.c
index 07f9178..c1aa150 100644
--- a/jcphuff.c
+++ b/xjcphuff.c
@@ -1,5 +1,5 @@
 /*
- * jcphuff.c
+ * xjcphuff.c
  *
  * Copyright (C) 1995-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -14,15 +14,15 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jchuff.h"		/* Declarations shared with jchuff.c */
+#include "xjpeglib.h"
+#include "xjchuff.h"		/* Declarations shared with jchuff.c */
 
 #ifdef C_PROGRESSIVE_SUPPORTED
 
 /* Expanded entropy encoder object for progressive Huffman encoding. */
 
 typedef struct {
-  struct jpeg_entropy_encoder pub; /* public fields */
+  struct jpeg_entropy_encoder_xp pub; /* public fields */
 
   /* Mode flag: TRUE for optimization, FALSE for actual data output */
   boolean gather_statistics;
@@ -86,16 +86,16 @@ typedef phuff_entropy_encoder * phuff_entropy_ptr;
 #endif
 
 /* Forward declarations */
-METHODDEF(boolean) encode_mcu_DC_first JPP((j_compress_ptr cinfo,
+METHODDEF(boolean) encode_mcu_DC_first_xp JPP((j_compress_ptr cinfo,
 					    JBLOCKROW *MCU_data));
-METHODDEF(boolean) encode_mcu_AC_first JPP((j_compress_ptr cinfo,
+METHODDEF(boolean) encode_mcu_AC_first_xp JPP((j_compress_ptr cinfo,
 					    JBLOCKROW *MCU_data));
-METHODDEF(boolean) encode_mcu_DC_refine JPP((j_compress_ptr cinfo,
+METHODDEF(boolean) encode_mcu_DC_refine_xp JPP((j_compress_ptr cinfo,
 					     JBLOCKROW *MCU_data));
-METHODDEF(boolean) encode_mcu_AC_refine JPP((j_compress_ptr cinfo,
+METHODDEF(boolean) encode_mcu_AC_refine_xp JPP((j_compress_ptr cinfo,
 					     JBLOCKROW *MCU_data));
-METHODDEF(void) finish_pass_phuff JPP((j_compress_ptr cinfo));
-METHODDEF(void) finish_pass_gather_phuff JPP((j_compress_ptr cinfo));
+METHODDEF(void) finish_pass_phuff_xp JPP((j_compress_ptr cinfo));
+METHODDEF(void) finish_pass_gather_phuff_xp JPP((j_compress_ptr cinfo));
 
 
 /*
@@ -103,9 +103,10 @@ METHODDEF(void) finish_pass_gather_phuff JPP((j_compress_ptr cinfo));
  */
 
 METHODDEF(void)
-start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
+start_pass_phuff_xp (j_compress_ptr cinfo, boolean gather_statistics)
 {  
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   boolean is_DC_band;
   int ci, tbl;
   jpeg_component_info * compptr;
@@ -120,14 +121,14 @@ start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
   /* Select execution routines */
   if (cinfo->Ah == 0) {
     if (is_DC_band)
-      entropy->pub.encode_mcu = encode_mcu_DC_first;
+      entropy->pub.encode_mcu_xp = encode_mcu_DC_first_xp;
     else
-      entropy->pub.encode_mcu = encode_mcu_AC_first;
+      entropy->pub.encode_mcu_xp = encode_mcu_AC_first_xp;
   } else {
     if (is_DC_band)
-      entropy->pub.encode_mcu = encode_mcu_DC_refine;
+      entropy->pub.encode_mcu_xp = encode_mcu_DC_refine_xp;
     else {
-      entropy->pub.encode_mcu = encode_mcu_AC_refine;
+      entropy->pub.encode_mcu_xp = encode_mcu_AC_refine_xp;
       /* AC refinement needs a correction bit buffer */
       if (entropy->bit_buffer == NULL)
 	entropy->bit_buffer = (char *)
@@ -136,9 +137,9 @@ start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
     }
   }
   if (gather_statistics)
-    entropy->pub.finish_pass = finish_pass_gather_phuff;
+    entropy->pub.finish_pass_xp = finish_pass_gather_phuff_xp;
   else
-    entropy->pub.finish_pass = finish_pass_phuff;
+    entropy->pub.finish_pass_xp = finish_pass_phuff_xp;
 
   /* Only DC coefficients may be interleaved, so cinfo->comps_in_scan = 1
    * for AC coefficients.
@@ -170,7 +171,7 @@ start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
     } else {
       /* Compute derived values for Huffman table */
       /* We may do this more than once for a table, but it's not expensive */
-      jpeg_make_c_derived_tbl(cinfo, is_DC_band, tbl,
+      jpeg_make_c_derived_tbl_xp(cinfo, is_DC_band, tbl,
 			      & entropy->derived_tbls[tbl]);
     }
   }
@@ -198,16 +199,17 @@ start_pass_phuff (j_compress_ptr cinfo, boolean gather_statistics)
 #define emit_byte(entropy,val)  \
 	{ *(entropy)->next_output_byte++ = (JOCTET) (val);  \
 	  if (--(entropy)->free_in_buffer == 0)  \
-	    dump_buffer(entropy); }
+	    dump_buffer_xp(entropy); }
 
 
 LOCAL(void)
-dump_buffer (phuff_entropy_ptr entropy)
+dump_buffer_xp (phuff_entropy_ptr entropy)
 /* Empty the output buffer; we do not support suspension in this module. */
 {
-  struct jpeg_destination_mgr * dest = entropy->cinfo->dest;
+  struct jpeg_destination_mgr_xp * dest =
+    ((j_compress_ptr_xp) entropy->cinfo->client_data)->dest_xp;
 
-  if (! (*dest->empty_output_buffer) (entropy->cinfo))
+  if (! (*dest->empty_output_buffer_xp) (entropy->cinfo))
     ERREXIT(entropy->cinfo, JERR_CANT_SUSPEND);
   /* After a successful buffer dump, must reset buffer pointers */
   entropy->next_output_byte = dest->next_output_byte;
@@ -374,9 +376,10 @@ emit_restart (phuff_entropy_ptr entropy, int restart_num)
  */
 
 METHODDEF(boolean)
-encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
+encode_mcu_DC_first_xp (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   register int temp, temp2;
   register int nbits;
   int blkn, ci;
@@ -385,8 +388,8 @@ encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   jpeg_component_info * compptr;
   ISHIFT_TEMPS
 
-  entropy->next_output_byte = cinfo->dest->next_output_byte;
-  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
+  entropy->next_output_byte = xinfo->dest_xp->next_output_byte;
+  entropy->free_in_buffer = xinfo->dest_xp->free_in_buffer;
 
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
@@ -438,8 +441,8 @@ encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
       emit_bits(entropy, (unsigned int) temp2, nbits);
   }
 
-  cinfo->dest->next_output_byte = entropy->next_output_byte;
-  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
+  xinfo->dest_xp->next_output_byte = entropy->next_output_byte;
+  xinfo->dest_xp->free_in_buffer = entropy->free_in_buffer;
 
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
@@ -461,9 +464,10 @@ encode_mcu_DC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 METHODDEF(boolean)
-encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
+encode_mcu_AC_first_xp (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   register int temp, temp2;
   register int nbits;
   register int r, k;
@@ -471,8 +475,8 @@ encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   int Al = cinfo->Al;
   JBLOCKROW block;
 
-  entropy->next_output_byte = cinfo->dest->next_output_byte;
-  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
+  entropy->next_output_byte = xinfo->dest_xp->next_output_byte;
+  entropy->free_in_buffer = xinfo->dest_xp->free_in_buffer;
 
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
@@ -544,8 +548,8 @@ encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
       emit_eobrun(entropy);	/* force it out to avoid overflow */
   }
 
-  cinfo->dest->next_output_byte = entropy->next_output_byte;
-  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
+  xinfo->dest_xp->next_output_byte = entropy->next_output_byte;
+  xinfo->dest_xp->free_in_buffer = entropy->free_in_buffer;
 
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
@@ -568,16 +572,17 @@ encode_mcu_AC_first (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 METHODDEF(boolean)
-encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
+encode_mcu_DC_refine_xp (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   register int temp;
   int blkn;
   int Al = cinfo->Al;
   JBLOCKROW block;
 
-  entropy->next_output_byte = cinfo->dest->next_output_byte;
-  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
+  entropy->next_output_byte = xinfo->dest_xp->next_output_byte;
+  entropy->free_in_buffer = xinfo->dest_xp->free_in_buffer;
 
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
@@ -593,8 +598,8 @@ encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
     emit_bits(entropy, (unsigned int) (temp >> Al), 1);
   }
 
-  cinfo->dest->next_output_byte = entropy->next_output_byte;
-  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
+  xinfo->dest_xp->next_output_byte = entropy->next_output_byte;
+  xinfo->dest_xp->free_in_buffer = entropy->free_in_buffer;
 
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
@@ -615,9 +620,10 @@ encode_mcu_DC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 METHODDEF(boolean)
-encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
+encode_mcu_AC_refine_xp (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
 {
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   register int temp;
   register int r, k;
   int EOB;
@@ -628,8 +634,8 @@ encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
   JBLOCKROW block;
   int absvalues[DCTSIZE2];
 
-  entropy->next_output_byte = cinfo->dest->next_output_byte;
-  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
+  entropy->next_output_byte = xinfo->dest_xp->next_output_byte;
+  entropy->free_in_buffer = xinfo->dest_xp->free_in_buffer;
 
   /* Emit restart marker if needed */
   if (cinfo->restart_interval)
@@ -721,8 +727,8 @@ encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
       emit_eobrun(entropy);
   }
 
-  cinfo->dest->next_output_byte = entropy->next_output_byte;
-  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
+  xinfo->dest_xp->next_output_byte = entropy->next_output_byte;
+  xinfo->dest_xp->free_in_buffer = entropy->free_in_buffer;
 
   /* Update restart-interval state too */
   if (cinfo->restart_interval) {
@@ -743,19 +749,20 @@ encode_mcu_AC_refine (j_compress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 METHODDEF(void)
-finish_pass_phuff (j_compress_ptr cinfo)
+finish_pass_phuff_xp (j_compress_ptr cinfo)
 {   
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
 
-  entropy->next_output_byte = cinfo->dest->next_output_byte;
-  entropy->free_in_buffer = cinfo->dest->free_in_buffer;
+  entropy->next_output_byte = xinfo->dest_xp->next_output_byte;
+  entropy->free_in_buffer = xinfo->dest_xp->free_in_buffer;
 
   /* Flush out any buffered data */
   emit_eobrun(entropy);
   flush_bits(entropy);
 
-  cinfo->dest->next_output_byte = entropy->next_output_byte;
-  cinfo->dest->free_in_buffer = entropy->free_in_buffer;
+  xinfo->dest_xp->next_output_byte = entropy->next_output_byte;
+  xinfo->dest_xp->free_in_buffer = entropy->free_in_buffer;
 }
 
 
@@ -764,9 +771,10 @@ finish_pass_phuff (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-finish_pass_gather_phuff (j_compress_ptr cinfo)
+finish_pass_gather_phuff_xp (j_compress_ptr cinfo)
 {
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   boolean is_DC_band;
   int ci, tbl;
   jpeg_component_info * compptr;
@@ -799,7 +807,7 @@ finish_pass_gather_phuff (j_compress_ptr cinfo)
         htblptr = & cinfo->ac_huff_tbl_ptrs[tbl];
       if (*htblptr == NULL)
         *htblptr = jpeg_alloc_huff_table((j_common_ptr) cinfo);
-      jpeg_gen_optimal_table(cinfo, *htblptr, entropy->count_ptrs[tbl]);
+      jpeg_gen_optimal_table_xp(cinfo, *htblptr, entropy->count_ptrs[tbl]);
       did[tbl] = TRUE;
     }
   }
@@ -811,16 +819,17 @@ finish_pass_gather_phuff (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_phuff_encoder (j_compress_ptr cinfo)
+jinit_phuff_encoder_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   phuff_entropy_ptr entropy;
   int i;
 
   entropy = (phuff_entropy_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(phuff_entropy_encoder));
-  cinfo->entropy = (struct jpeg_entropy_encoder *) entropy;
-  entropy->pub.start_pass = start_pass_phuff;
+  xinfo->entropy_xp = (struct jpeg_entropy_encoder_xp *) entropy;
+  entropy->pub.start_pass_xp = start_pass_phuff_xp;
 
   /* Mark tables unallocated */
   for (i = 0; i < NUM_HUFF_TBLS; i++) {
diff --git a/jcprepct.c b/xjcprepct.c
similarity index 79%
rename from jcprepct.c
rename to xjcprepct.c
index fa93333..b800992 100644
--- a/jcprepct.c
+++ b/xjcprepct.c
@@ -1,5 +1,5 @@
 /*
- * jcprepct.c
+ * xjcprepct.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,7 +16,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* At present, jcsample.c can request context rows only for smoothing.
@@ -51,12 +51,12 @@
 /* Private buffer controller object */
 
 typedef struct {
-  struct jpeg_c_prep_controller pub; /* public fields */
+  struct jpeg_c_prep_controller_xp pub; /* public fields */
 
   /* Downsampling input buffer.  This buffer holds color-converted data
    * until we have enough to do a downsample step.
    */
-  JSAMPARRAY color_buf[MAX_COMPONENTS];
+  JSAMPARRAYXP color_buf[MAX_COMPONENTS];
 
   JDIMENSION rows_to_go;	/* counts rows remaining in source image */
   int next_buf_row;		/* index of next row to store in color_buf */
@@ -65,9 +65,9 @@ typedef struct {
   int this_row_group;		/* starting row index of group to process */
   int next_buf_stop;		/* downsample when we reach this index */
 #endif
-} my_prep_controller;
+} my_prep_controller_xp;
 
-typedef my_prep_controller * my_prep_ptr;
+typedef my_prep_controller_xp * my_prep_ptr;
 
 
 /*
@@ -75,9 +75,10 @@ typedef my_prep_controller * my_prep_ptr;
  */
 
 METHODDEF(void)
-start_pass_prep (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
+start_pass_prep_xp (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_prep_ptr prep = (my_prep_ptr) xinfo->prep_xp;
 
   if (pass_mode != JBUF_PASS_THRU)
     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
@@ -103,13 +104,13 @@ start_pass_prep (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
  */
 
 LOCAL(void)
-expand_bottom_edge (JSAMPARRAY image_data, JDIMENSION num_cols,
+expand_bottom_edge (JSAMPARRAYXP image_data, JDIMENSION num_cols,
 		    int input_rows, int output_rows)
 {
   register int row;
 
   for (row = input_rows; row < output_rows; row++) {
-    jcopy_sample_rows(image_data, input_rows-1, image_data, row,
+    jcopy_sample_rows_xp(image_data, input_rows-1, image_data, row,
 		      1, num_cols);
   }
 }
@@ -125,13 +126,14 @@ expand_bottom_edge (JSAMPARRAY image_data, JDIMENSION num_cols,
  */
 
 METHODDEF(void)
-pre_process_data (j_compress_ptr cinfo,
-		  JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
-		  JDIMENSION in_rows_avail,
-		  JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr,
-		  JDIMENSION out_row_groups_avail)
+pre_process_data_xp (j_compress_ptr cinfo,
+                        JSAMPARRAYXP input_buf, JDIMENSION *in_row_ctr,
+                        JDIMENSION in_rows_avail,
+                        JSAMPIMAGEXP output_buf, JDIMENSION *out_row_group_ctr,
+                        JDIMENSION out_row_groups_avail)
 {
-  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_prep_ptr prep = (my_prep_ptr) xinfo->prep_xp;
   int numrows, ci;
   JDIMENSION inrows;
   jpeg_component_info * compptr;
@@ -142,7 +144,7 @@ pre_process_data (j_compress_ptr cinfo,
     inrows = in_rows_avail - *in_row_ctr;
     numrows = cinfo->max_v_samp_factor - prep->next_buf_row;
     numrows = (int) MIN((JDIMENSION) numrows, inrows);
-    (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,
+    (*xinfo->cconvert_xp->color_convert_xp) (cinfo, input_buf + *in_row_ctr,
 				       prep->color_buf,
 				       (JDIMENSION) prep->next_buf_row,
 				       numrows);
@@ -160,7 +162,7 @@ pre_process_data (j_compress_ptr cinfo,
     }
     /* If we've filled the conversion buffer, empty it. */
     if (prep->next_buf_row == cinfo->max_v_samp_factor) {
-      (*cinfo->downsample->downsample) (cinfo,
+      (*xinfo->downsample_xp->downsample_xp) (cinfo,
 					prep->color_buf, (JDIMENSION) 0,
 					output_buf, *out_row_group_ctr);
       prep->next_buf_row = 0;
@@ -192,13 +194,14 @@ pre_process_data (j_compress_ptr cinfo,
  */
 
 METHODDEF(void)
-pre_process_context (j_compress_ptr cinfo,
-		     JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
-		     JDIMENSION in_rows_avail,
-		     JSAMPIMAGE output_buf, JDIMENSION *out_row_group_ctr,
-		     JDIMENSION out_row_groups_avail)
+pre_process_context_xp (j_compress_ptr cinfo,
+                           JSAMPARRAYXP input_buf, JDIMENSION *in_row_ctr,
+                           JDIMENSION in_rows_avail,
+                           JSAMPIMAGEXP output_buf, JDIMENSION *out_row_group_ctr,
+                           JDIMENSION out_row_groups_avail)
 {
-  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_prep_ptr prep = (my_prep_ptr) xinfo->prep_xp;
   int numrows, ci;
   int buf_height = cinfo->max_v_samp_factor * 3;
   JDIMENSION inrows;
@@ -209,7 +212,7 @@ pre_process_context (j_compress_ptr cinfo,
       inrows = in_rows_avail - *in_row_ctr;
       numrows = prep->next_buf_stop - prep->next_buf_row;
       numrows = (int) MIN((JDIMENSION) numrows, inrows);
-      (*cinfo->cconvert->color_convert) (cinfo, input_buf + *in_row_ctr,
+      (*xinfo->cconvert_xp->color_convert_xp) (cinfo, input_buf + *in_row_ctr,
 					 prep->color_buf,
 					 (JDIMENSION) prep->next_buf_row,
 					 numrows);
@@ -218,7 +221,7 @@ pre_process_context (j_compress_ptr cinfo,
 	for (ci = 0; ci < cinfo->num_components; ci++) {
 	  int row;
 	  for (row = 1; row <= cinfo->max_v_samp_factor; row++) {
-	    jcopy_sample_rows(prep->color_buf[ci], 0,
+	    jcopy_sample_rows_xp(prep->color_buf[ci], 0,
 			      prep->color_buf[ci], -row,
 			      1, cinfo->image_width);
 	  }
@@ -242,7 +245,7 @@ pre_process_context (j_compress_ptr cinfo,
     }
     /* If we've gotten enough data, downsample a row group. */
     if (prep->next_buf_row == prep->next_buf_stop) {
-      (*cinfo->downsample->downsample) (cinfo,
+      (*xinfo->downsample_xp->downsample_xp) (cinfo,
 					prep->color_buf,
 					(JDIMENSION) prep->this_row_group,
 					output_buf, *out_row_group_ctr);
@@ -264,21 +267,22 @@ pre_process_context (j_compress_ptr cinfo,
  */
 
 LOCAL(void)
-create_context_buffer (j_compress_ptr cinfo)
+create_context_buffer_xp (j_compress_ptr cinfo)
 {
-  my_prep_ptr prep = (my_prep_ptr) cinfo->prep;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_prep_ptr prep = (my_prep_ptr) xinfo->prep_xp;
   int rgroup_height = cinfo->max_v_samp_factor;
   int ci, i;
   jpeg_component_info * compptr;
-  JSAMPARRAY true_buffer, fake_buffer;
+  JSAMPARRAYXP true_buffer, fake_buffer;
 
   /* Grab enough space for fake row pointers for all the components;
    * we need five row groups' worth of pointers for each component.
    */
-  fake_buffer = (JSAMPARRAY)
+  fake_buffer = (JSAMPARRAYXP)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				(cinfo->num_components * 5 * rgroup_height) *
-				SIZEOF(JSAMPROW));
+				SIZEOF(JSAMPROWXP));
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
@@ -286,14 +290,14 @@ create_context_buffer (j_compress_ptr cinfo)
      * We make the buffer wide enough to allow the downsampler to edge-expand
      * horizontally within the buffer, if it so chooses.
      */
-    true_buffer = (*cinfo->mem->alloc_sarray)
+    true_buffer = (*cinfo->mem->alloc_sarray_xp)
       ((j_common_ptr) cinfo, JPOOL_IMAGE,
        (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
 		      cinfo->max_h_samp_factor) / compptr->h_samp_factor),
        (JDIMENSION) (3 * rgroup_height));
     /* Copy true buffer row pointers into the middle of the fake row array */
     MEMCOPY(fake_buffer + rgroup_height, true_buffer,
-	    3 * rgroup_height * SIZEOF(JSAMPROW));
+	    3 * rgroup_height * SIZEOF(JSAMPROWXP));
     /* Fill in the above and below wraparound pointers */
     for (i = 0; i < rgroup_height; i++) {
       fake_buffer[i] = true_buffer[2 * rgroup_height + i];
@@ -312,8 +316,9 @@ create_context_buffer (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_c_prep_controller (j_compress_ptr cinfo, boolean need_full_buffer)
+jinit_c_prep_controller_xp (j_compress_ptr cinfo, boolean need_full_buffer)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_prep_ptr prep;
   int ci;
   jpeg_component_info * compptr;
@@ -323,28 +328,28 @@ jinit_c_prep_controller (j_compress_ptr cinfo, boolean need_full_buffer)
 
   prep = (my_prep_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				SIZEOF(my_prep_controller));
-  cinfo->prep = (struct jpeg_c_prep_controller *) prep;
-  prep->pub.start_pass = start_pass_prep;
+				SIZEOF(my_prep_controller_xp));
+  xinfo->prep_xp = (struct jpeg_c_prep_controller_xp *) prep;
+  prep->pub.start_pass_xp = start_pass_prep_xp;
 
   /* Allocate the color conversion buffer.
    * We make the buffer wide enough to allow the downsampler to edge-expand
    * horizontally within the buffer, if it so chooses.
    */
-  if (cinfo->downsample->need_context_rows) {
+  if (xinfo->downsample_xp->need_context_rows) {
     /* Set up to provide context rows */
 #ifdef CONTEXT_ROWS_SUPPORTED
-    prep->pub.pre_process_data = pre_process_context;
-    create_context_buffer(cinfo);
+    prep->pub.pre_process_data_xp = pre_process_context_xp;
+    create_context_buffer_xp(cinfo);
 #else
     ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
   } else {
     /* No context, just make it tall enough for one row group */
-    prep->pub.pre_process_data = pre_process_data;
+    prep->pub.pre_process_data_xp = pre_process_data_xp;
     for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
 	 ci++, compptr++) {
-      prep->color_buf[ci] = (*cinfo->mem->alloc_sarray)
+      prep->color_buf[ci] = (*cinfo->mem->alloc_sarray_xp)
 	((j_common_ptr) cinfo, JPOOL_IMAGE,
 	 (JDIMENSION) (((long) compptr->width_in_blocks * DCTSIZE *
 			cinfo->max_h_samp_factor) / compptr->h_samp_factor),
diff --git a/jcsample.c b/xjcsample.c
similarity index 82%
rename from jcsample.c
rename to xjcsample.c
index 212ec87..4b9863a 100644
--- a/jcsample.c
+++ b/xjcsample.c
@@ -1,5 +1,5 @@
 /*
- * jcsample.c
+ * xjcsample.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -47,18 +47,18 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Pointer to routine to downsample a single component */
 typedef JMETHOD(void, downsample1_ptr,
 		(j_compress_ptr cinfo, jpeg_component_info * compptr,
-		 JSAMPARRAY input_data, JSAMPARRAY output_data));
+		 JSAMPARRAYXP input_data, JSAMPARRAYXP output_data));
 
 /* Private subobject */
 
 typedef struct {
-  struct jpeg_downsampler pub;	/* public fields */
+  struct jpeg_downsampler_xp pub;	/* public fields */
 
   /* Downsampling method pointers, one per component */
   downsample1_ptr methods[MAX_COMPONENTS];
@@ -72,7 +72,7 @@ typedef my_downsampler * my_downsample_ptr;
  */
 
 METHODDEF(void)
-start_pass_downsample (j_compress_ptr cinfo)
+start_pass_downsample_xp (j_compress_ptr cinfo)
 {
   /* no work for now */
 }
@@ -84,11 +84,11 @@ start_pass_downsample (j_compress_ptr cinfo)
  */
 
 LOCAL(void)
-expand_right_edge (JSAMPARRAY image_data, int num_rows,
-		   JDIMENSION input_cols, JDIMENSION output_cols)
+expand_right_edge_xp (JSAMPARRAYXP image_data, int num_rows,
+                         JDIMENSION input_cols, JDIMENSION output_cols)
 {
-  register JSAMPROW ptr;
-  register JSAMPLE pixval;
+  register JSAMPROWXP ptr;
+  register JSAMPLEXP pixval;
   register int count;
   int row;
   int numcols = (int) (output_cols - input_cols);
@@ -111,14 +111,15 @@ expand_right_edge (JSAMPARRAY image_data, int num_rows,
  */
 
 METHODDEF(void)
-sep_downsample (j_compress_ptr cinfo,
-		JSAMPIMAGE input_buf, JDIMENSION in_row_index,
-		JSAMPIMAGE output_buf, JDIMENSION out_row_group_index)
+sep_downsample_xp (j_compress_ptr cinfo,
+		JSAMPIMAGEXP input_buf, JDIMENSION in_row_index,
+		JSAMPIMAGEXP output_buf, JDIMENSION out_row_group_index)
 {
-  my_downsample_ptr downsample = (my_downsample_ptr) cinfo->downsample;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_downsample_ptr downsample = (my_downsample_ptr) xinfo->downsample_xp;
   int ci;
   jpeg_component_info * compptr;
-  JSAMPARRAY in_ptr, out_ptr;
+  JSAMPARRAYXP in_ptr, out_ptr;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
@@ -137,13 +138,13 @@ sep_downsample (j_compress_ptr cinfo,
  */
 
 METHODDEF(void)
-int_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
-		JSAMPARRAY input_data, JSAMPARRAY output_data)
+int_downsample_xp (j_compress_ptr cinfo, jpeg_component_info * compptr,
+		JSAMPARRAYXP input_data, JSAMPARRAYXP output_data)
 {
   int inrow, outrow, h_expand, v_expand, numpix, numpix2, h, v;
   JDIMENSION outcol, outcol_h;	/* outcol_h == outcol*h_expand */
   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
-  JSAMPROW inptr, outptr;
+  JSAMPROWXP inptr, outptr;
   INT32 outvalue;
 
   h_expand = cinfo->max_h_samp_factor / compptr->h_samp_factor;
@@ -155,7 +156,7 @@ int_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
    * by the standard loop.  Special-casing padded output would be more
    * efficient.
    */
-  expand_right_edge(input_data, cinfo->max_v_samp_factor,
+  expand_right_edge_xp(input_data, cinfo->max_v_samp_factor,
 		    cinfo->image_width, output_cols * h_expand);
 
   inrow = 0;
@@ -170,7 +171,7 @@ int_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
 	  outvalue += (INT32) GETJSAMPLE(*inptr++);
 	}
       }
-      *outptr++ = (JSAMPLE) ((outvalue + numpix2) / numpix);
+      *outptr++ = (JSAMPLEXP) ((outvalue + numpix2) / numpix);
     }
     inrow += v_expand;
   }
@@ -184,14 +185,14 @@ int_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-fullsize_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
-		     JSAMPARRAY input_data, JSAMPARRAY output_data)
+fullsize_downsample_xp (j_compress_ptr cinfo, jpeg_component_info * compptr,
+		     JSAMPARRAYXP input_data, JSAMPARRAYXP output_data)
 {
   /* Copy the data */
-  jcopy_sample_rows(input_data, 0, output_data, 0,
+  jcopy_sample_rows_xp(input_data, 0, output_data, 0,
 		    cinfo->max_v_samp_factor, cinfo->image_width);
   /* Edge-expand */
-  expand_right_edge(output_data, cinfo->max_v_samp_factor,
+  expand_right_edge_xp(output_data, cinfo->max_v_samp_factor,
 		    cinfo->image_width, compptr->width_in_blocks * DCTSIZE);
 }
 
@@ -209,20 +210,20 @@ fullsize_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-h2v1_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
-		 JSAMPARRAY input_data, JSAMPARRAY output_data)
+h2v1_downsample_xp (j_compress_ptr cinfo, jpeg_component_info * compptr,
+		 JSAMPARRAYXP input_data, JSAMPARRAYXP output_data)
 {
   int outrow;
   JDIMENSION outcol;
   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
-  register JSAMPROW inptr, outptr;
+  register JSAMPROWXP inptr, outptr;
   register int bias;
 
   /* Expand input data enough to let all the output samples be generated
    * by the standard loop.  Special-casing padded output would be more
    * efficient.
    */
-  expand_right_edge(input_data, cinfo->max_v_samp_factor,
+  expand_right_edge_xp(input_data, cinfo->max_v_samp_factor,
 		    cinfo->image_width, output_cols * 2);
 
   for (outrow = 0; outrow < compptr->v_samp_factor; outrow++) {
@@ -230,7 +231,7 @@ h2v1_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
     inptr = input_data[outrow];
     bias = 0;			/* bias = 0,1,0,1,... for successive samples */
     for (outcol = 0; outcol < output_cols; outcol++) {
-      *outptr++ = (JSAMPLE) ((GETJSAMPLE(*inptr) + GETJSAMPLE(inptr[1])
+      *outptr++ = (JSAMPLEXP) ((GETJSAMPLE(*inptr) + GETJSAMPLE(inptr[1])
 			      + bias) >> 1);
       bias ^= 1;		/* 0=>1, 1=>0 */
       inptr += 2;
@@ -246,20 +247,20 @@ h2v1_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-h2v2_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
-		 JSAMPARRAY input_data, JSAMPARRAY output_data)
+h2v2_downsample_xp (j_compress_ptr cinfo, jpeg_component_info * compptr,
+		 JSAMPARRAYXP input_data, JSAMPARRAYXP output_data)
 {
   int inrow, outrow;
   JDIMENSION outcol;
   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
-  register JSAMPROW inptr0, inptr1, outptr;
+  register JSAMPROWXP inptr0, inptr1, outptr;
   register int bias;
 
   /* Expand input data enough to let all the output samples be generated
    * by the standard loop.  Special-casing padded output would be more
    * efficient.
    */
-  expand_right_edge(input_data, cinfo->max_v_samp_factor,
+  expand_right_edge_xp(input_data, cinfo->max_v_samp_factor,
 		    cinfo->image_width, output_cols * 2);
 
   inrow = 0;
@@ -269,7 +270,7 @@ h2v2_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
     inptr1 = input_data[inrow+1];
     bias = 1;			/* bias = 1,2,1,2,... for successive samples */
     for (outcol = 0; outcol < output_cols; outcol++) {
-      *outptr++ = (JSAMPLE) ((GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
+      *outptr++ = (JSAMPLEXP) ((GETJSAMPLE(*inptr0) + GETJSAMPLE(inptr0[1]) +
 			      GETJSAMPLE(*inptr1) + GETJSAMPLE(inptr1[1])
 			      + bias) >> 2);
       bias ^= 3;		/* 1=>2, 2=>1 */
@@ -289,20 +290,20 @@ h2v2_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-h2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
-			JSAMPARRAY input_data, JSAMPARRAY output_data)
+h2v2_smooth_downsample_xp (j_compress_ptr cinfo, jpeg_component_info * compptr,
+			JSAMPARRAYXP input_data, JSAMPARRAYXP output_data)
 {
   int inrow, outrow;
   JDIMENSION colctr;
   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
-  register JSAMPROW inptr0, inptr1, above_ptr, below_ptr, outptr;
+  register JSAMPROWXP inptr0, inptr1, above_ptr, below_ptr, outptr;
   INT32 membersum, neighsum, memberscale, neighscale;
 
   /* Expand input data enough to let all the output samples be generated
    * by the standard loop.  Special-casing padded output would be more
    * efficient.
    */
-  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
+  expand_right_edge_xp(input_data - 1, cinfo->max_v_samp_factor + 2,
 		    cinfo->image_width, output_cols * 2);
 
   /* We don't bother to form the individual "smoothed" input pixel values;
@@ -340,7 +341,7 @@ h2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
     neighsum += GETJSAMPLE(*above_ptr) + GETJSAMPLE(above_ptr[2]) +
 		GETJSAMPLE(*below_ptr) + GETJSAMPLE(below_ptr[2]);
     membersum = membersum * memberscale + neighsum * neighscale;
-    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
+    *outptr++ = (JSAMPLEXP) ((membersum + 32768) >> 16);
     inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;
 
     for (colctr = output_cols - 2; colctr > 0; colctr--) {
@@ -360,7 +361,7 @@ h2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
       /* form final output scaled up by 2^16 */
       membersum = membersum * memberscale + neighsum * neighscale;
       /* round, descale and output it */
-      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
+      *outptr++ = (JSAMPLEXP) ((membersum + 32768) >> 16);
       inptr0 += 2; inptr1 += 2; above_ptr += 2; below_ptr += 2;
     }
 
@@ -375,7 +376,7 @@ h2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
     neighsum += GETJSAMPLE(above_ptr[-1]) + GETJSAMPLE(above_ptr[1]) +
 		GETJSAMPLE(below_ptr[-1]) + GETJSAMPLE(below_ptr[1]);
     membersum = membersum * memberscale + neighsum * neighscale;
-    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);
+    *outptr = (JSAMPLEXP) ((membersum + 32768) >> 16);
 
     inrow += 2;
   }
@@ -389,13 +390,13 @@ h2v2_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-fullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
-			    JSAMPARRAY input_data, JSAMPARRAY output_data)
+fullsize_smooth_downsample_xp (j_compress_ptr cinfo, jpeg_component_info *compptr,
+			    JSAMPARRAYXP input_data, JSAMPARRAYXP output_data)
 {
   int outrow;
   JDIMENSION colctr;
   JDIMENSION output_cols = compptr->width_in_blocks * DCTSIZE;
-  register JSAMPROW inptr, above_ptr, below_ptr, outptr;
+  register JSAMPROWXP inptr, above_ptr, below_ptr, outptr;
   INT32 membersum, neighsum, memberscale, neighscale;
   int colsum, lastcolsum, nextcolsum;
 
@@ -403,7 +404,7 @@ fullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
    * by the standard loop.  Special-casing padded output would be more
    * efficient.
    */
-  expand_right_edge(input_data - 1, cinfo->max_v_samp_factor + 2,
+  expand_right_edge_xp(input_data - 1, cinfo->max_v_samp_factor + 2,
 		    cinfo->image_width, output_cols);
 
   /* Each of the eight neighbor pixels contributes a fraction SF to the
@@ -429,7 +430,7 @@ fullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
 		 GETJSAMPLE(*inptr);
     neighsum = colsum + (colsum - membersum) + nextcolsum;
     membersum = membersum * memberscale + neighsum * neighscale;
-    *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
+    *outptr++ = (JSAMPLEXP) ((membersum + 32768) >> 16);
     lastcolsum = colsum; colsum = nextcolsum;
 
     for (colctr = output_cols - 2; colctr > 0; colctr--) {
@@ -439,7 +440,7 @@ fullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
 		   GETJSAMPLE(*inptr);
       neighsum = lastcolsum + (colsum - membersum) + nextcolsum;
       membersum = membersum * memberscale + neighsum * neighscale;
-      *outptr++ = (JSAMPLE) ((membersum + 32768) >> 16);
+      *outptr++ = (JSAMPLEXP) ((membersum + 32768) >> 16);
       lastcolsum = colsum; colsum = nextcolsum;
     }
 
@@ -447,7 +448,7 @@ fullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
     membersum = GETJSAMPLE(*inptr);
     neighsum = lastcolsum + (colsum - membersum) + colsum;
     membersum = membersum * memberscale + neighsum * neighscale;
-    *outptr = (JSAMPLE) ((membersum + 32768) >> 16);
+    *outptr = (JSAMPLEXP) ((membersum + 32768) >> 16);
 
   }
 }
@@ -461,8 +462,9 @@ fullsize_smooth_downsample (j_compress_ptr cinfo, jpeg_component_info *compptr,
  */
 
 GLOBAL(void)
-jinit_downsampler (j_compress_ptr cinfo)
+jinit_downsampler_xp (j_compress_ptr cinfo)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_downsample_ptr downsample;
   int ci;
   jpeg_component_info * compptr;
@@ -471,9 +473,9 @@ jinit_downsampler (j_compress_ptr cinfo)
   downsample = (my_downsample_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_downsampler));
-  cinfo->downsample = (struct jpeg_downsampler *) downsample;
-  downsample->pub.start_pass = start_pass_downsample;
-  downsample->pub.downsample = sep_downsample;
+  xinfo->downsample_xp = (struct jpeg_downsampler_xp *) downsample;
+  downsample->pub.start_pass_xp = start_pass_downsample_xp;
+  downsample->pub.downsample_xp = sep_downsample_xp;
   downsample->pub.need_context_rows = FALSE;
 
   if (cinfo->CCIR601_sampling)
@@ -486,28 +488,28 @@ jinit_downsampler (j_compress_ptr cinfo)
 	compptr->v_samp_factor == cinfo->max_v_samp_factor) {
 #ifdef INPUT_SMOOTHING_SUPPORTED
       if (cinfo->smoothing_factor) {
-	downsample->methods[ci] = fullsize_smooth_downsample;
+	downsample->methods[ci] = fullsize_smooth_downsample_xp;
 	downsample->pub.need_context_rows = TRUE;
       } else
 #endif
-	downsample->methods[ci] = fullsize_downsample;
+	downsample->methods[ci] = fullsize_downsample_xp;
     } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
 	       compptr->v_samp_factor == cinfo->max_v_samp_factor) {
       smoothok = FALSE;
-      downsample->methods[ci] = h2v1_downsample;
+      downsample->methods[ci] = h2v1_downsample_xp;
     } else if (compptr->h_samp_factor * 2 == cinfo->max_h_samp_factor &&
 	       compptr->v_samp_factor * 2 == cinfo->max_v_samp_factor) {
 #ifdef INPUT_SMOOTHING_SUPPORTED
       if (cinfo->smoothing_factor) {
-	downsample->methods[ci] = h2v2_smooth_downsample;
+	downsample->methods[ci] = h2v2_smooth_downsample_xp;
 	downsample->pub.need_context_rows = TRUE;
       } else
 #endif
-	downsample->methods[ci] = h2v2_downsample;
+	downsample->methods[ci] = h2v2_downsample_xp;
     } else if ((cinfo->max_h_samp_factor % compptr->h_samp_factor) == 0 &&
 	       (cinfo->max_v_samp_factor % compptr->v_samp_factor) == 0) {
       smoothok = FALSE;
-      downsample->methods[ci] = int_downsample;
+      downsample->methods[ci] = int_downsample_xp;
     } else
       ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
   }
diff --git a/jctrans.c b/xjctrans.c
similarity index 83%
rename from jctrans.c
rename to xjctrans.c
index 0e6d707..78a0cb7 100644
--- a/jctrans.c
+++ b/xjctrans.c
@@ -1,5 +1,5 @@
 /*
- * jctrans.c
+ * xjctrans.c
  *
  * Copyright (C) 1995-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -12,13 +12,13 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Forward declarations */
-LOCAL(void) transencode_master_selection
+LOCAL(void) transencode_master_selection_xp
 	JPP((j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays));
-LOCAL(void) transencode_coef_controller
+LOCAL(void) transencode_coef_controller_xp
 	JPP((j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays));
 
 
@@ -35,17 +35,18 @@ LOCAL(void) transencode_coef_controller
  */
 
 GLOBAL(void)
-jpeg_write_coefficients (j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays)
+jpeg_write_coefficients_xp (j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   if (cinfo->global_state != CSTATE_START)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   /* Mark all tables to be written */
-  jpeg_suppress_tables(cinfo, FALSE);
+  jpeg_suppress_tables_xp(cinfo, FALSE);
   /* (Re)initialize error mgr and destination modules */
   (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
-  (*cinfo->dest->init_destination) (cinfo);
+  (*xinfo->dest_xp->init_destination_xp) (cinfo);
   /* Perform master selection of active modules */
-  transencode_master_selection(cinfo, coef_arrays);
+  transencode_master_selection_xp(cinfo, coef_arrays);
   /* Wait for jpeg_finish_compress() call */
   cinfo->next_scanline = 0;	/* so jpeg_write_marker works */
   cinfo->global_state = CSTATE_WRCOEFS;
@@ -60,8 +61,8 @@ jpeg_write_coefficients (j_compress_ptr cinfo, jvirt_barray_ptr * coef_arrays)
  */
 
 GLOBAL(void)
-jpeg_copy_critical_parameters (j_decompress_ptr srcinfo,
-			       j_compress_ptr dstinfo)
+jpeg_copy_critical_parameters_xp (j_decompress_ptr srcinfo,
+                                     j_compress_ptr dstinfo)
 {
   JQUANT_TBL ** qtblptr;
   jpeg_component_info *incomp, *outcomp;
@@ -77,11 +78,11 @@ jpeg_copy_critical_parameters (j_decompress_ptr srcinfo,
   dstinfo->input_components = srcinfo->num_components;
   dstinfo->in_color_space = srcinfo->jpeg_color_space;
   /* Initialize all parameters to default values */
-  jpeg_set_defaults(dstinfo);
+  jpeg_set_defaults_xp(dstinfo);
   /* jpeg_set_defaults may choose wrong colorspace, eg YCbCr if input is RGB.
    * Fix it to get the right header markers for the image colorspace.
    */
-  jpeg_set_colorspace(dstinfo, srcinfo->jpeg_color_space);
+  jpeg_set_colorspace_xp(dstinfo, srcinfo->jpeg_color_space);
   dstinfo->data_precision = srcinfo->data_precision;
   dstinfo->CCIR601_sampling = srcinfo->CCIR601_sampling;
   /* Copy the source's quantization tables. */
@@ -155,15 +156,16 @@ jpeg_copy_critical_parameters (j_decompress_ptr srcinfo,
  */
 
 LOCAL(void)
-transencode_master_selection (j_compress_ptr cinfo,
-			      jvirt_barray_ptr * coef_arrays)
+transencode_master_selection_xp (j_compress_ptr cinfo,
+                                    jvirt_barray_ptr * coef_arrays)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   /* Although we don't actually use input_components for transcoding,
    * jcmaster.c's initial_setup will complain if input_components is 0.
    */
   cinfo->input_components = 1;
   /* Initialize master control (includes parameter checking/processing) */
-  jinit_c_master_control(cinfo, TRUE /* transcode only */);
+  jinit_c_master_control_xp(cinfo, TRUE /* transcode only */);
 
   /* Entropy encoding: either Huffman or arithmetic coding. */
   if (cinfo->arith_code) {
@@ -171,27 +173,27 @@ transencode_master_selection (j_compress_ptr cinfo,
   } else {
     if (cinfo->progressive_mode) {
 #ifdef C_PROGRESSIVE_SUPPORTED
-      jinit_phuff_encoder(cinfo);
+      jinit_phuff_encoder_xp(cinfo);
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
     } else
-      jinit_huff_encoder(cinfo);
+      jinit_huff_encoder_xp(cinfo);
   }
 
   /* We need a special coefficient buffer controller. */
-  transencode_coef_controller(cinfo, coef_arrays);
+  transencode_coef_controller_xp(cinfo, coef_arrays);
 
-  jinit_marker_writer(cinfo);
+  jinit_marker_writer_xp(cinfo);
 
   /* We can now tell the memory manager to allocate virtual arrays. */
-  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
+  (*cinfo->mem->realize_virt_arrays_xp) ((j_common_ptr) cinfo);
 
   /* Write the datastream header (SOI, JFIF) immediately.
    * Frame and scan headers are postponed till later.
    * This lets application insert special markers after the SOI.
    */
-  (*cinfo->marker->write_file_header) (cinfo);
+  (*xinfo->marker_xp->write_file_header_xp) (cinfo);
 }
 
 
@@ -206,7 +208,7 @@ transencode_master_selection (j_compress_ptr cinfo,
 /* Private buffer controller object */
 
 typedef struct {
-  struct jpeg_c_coef_controller pub; /* public fields */
+  struct jpeg_c_coef_controller_xp pub; /* public fields */
 
   JDIMENSION iMCU_row_num;	/* iMCU row # within image */
   JDIMENSION mcu_ctr;		/* counts MCUs processed in current row */
@@ -218,16 +220,17 @@ typedef struct {
 
   /* Workspace for constructing dummy blocks at right/bottom edges. */
   JBLOCKROW dummy_buffer[C_MAX_BLOCKS_IN_MCU];
-} my_coef_controller;
+} my_coef_controller_xp;
 
-typedef my_coef_controller * my_coef_ptr;
+typedef my_coef_controller_xp * my_xp_coef_ptr;
 
 
 LOCAL(void)
-start_iMCU_row (j_compress_ptr cinfo)
+start_iMCU_row_xp (j_compress_ptr cinfo)
 /* Reset within-iMCU-row counters for a new row */
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_xp_coef_ptr coef = (my_xp_coef_ptr) xinfo->coef_xp;
 
   /* In an interleaved scan, an MCU row is the same as an iMCU row.
    * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
@@ -252,15 +255,16 @@ start_iMCU_row (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
+start_pass_coef_xp (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_xp_coef_ptr coef = (my_xp_coef_ptr) xinfo->coef_xp;
 
   if (pass_mode != JBUF_CRANK_DEST)
     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
 
   coef->iMCU_row_num = 0;
-  start_iMCU_row(cinfo);
+  start_iMCU_row_xp(cinfo);
 }
 
 
@@ -275,9 +279,10 @@ start_pass_coef (j_compress_ptr cinfo, J_BUF_MODE pass_mode)
  */
 
 METHODDEF(boolean)
-compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
+compress_output_xp (j_compress_ptr cinfo, JSAMPIMAGEXP input_buf)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_xp_coef_ptr coef = (my_xp_coef_ptr) xinfo->coef_xp;
   JDIMENSION MCU_col_num;	/* index of current MCU within row */
   JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
@@ -334,7 +339,7 @@ compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
 	}
       }
       /* Try to write the MCU. */
-      if (! (*cinfo->entropy->encode_mcu) (cinfo, MCU_buffer)) {
+      if (! (*xinfo->entropy_xp->encode_mcu_xp) (cinfo, MCU_buffer)) {
 	/* Suspension forced; update state counters and exit */
 	coef->MCU_vert_offset = yoffset;
 	coef->mcu_ctr = MCU_col_num;
@@ -346,7 +351,7 @@ compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
   }
   /* Completed the iMCU row, advance counters for next one */
   coef->iMCU_row_num++;
-  start_iMCU_row(cinfo);
+  start_iMCU_row_xp(cinfo);
   return TRUE;
 }
 
@@ -360,19 +365,20 @@ compress_output (j_compress_ptr cinfo, JSAMPIMAGE input_buf)
  */
 
 LOCAL(void)
-transencode_coef_controller (j_compress_ptr cinfo,
+transencode_coef_controller_xp (j_compress_ptr cinfo,
 			     jvirt_barray_ptr * coef_arrays)
 {
-  my_coef_ptr coef;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_xp_coef_ptr coef;
   JBLOCKROW buffer;
   int i;
 
-  coef = (my_coef_ptr)
+  coef = (my_xp_coef_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				SIZEOF(my_coef_controller));
-  cinfo->coef = (struct jpeg_c_coef_controller *) coef;
-  coef->pub.start_pass = start_pass_coef;
-  coef->pub.compress_data = compress_output;
+				SIZEOF(my_coef_controller_xp));
+  xinfo->coef_xp = (struct jpeg_c_coef_controller_xp *) coef;
+  coef->pub.start_pass_xp = start_pass_coef_xp;
+  coef->pub.compress_data_xp = compress_output_xp;
 
   /* Save pointer to virtual arrays */
   coef->whole_image = coef_arrays;
diff --git a/jdapimin.c b/xjdapimin.c
similarity index 81%
rename from jdapimin.c
rename to xjdapimin.c
index cadb59f..12cb864 100644
--- a/jdapimin.c
+++ b/xjdapimin.c
@@ -1,5 +1,5 @@
 /*
- * jdapimin.c
+ * xjdapimin.c
  *
  * Copyright (C) 1994-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -18,7 +18,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
+#include "xjerror.h"
 
 
 /*
@@ -27,9 +28,10 @@
  */
 
 GLOBAL(void)
-jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
+jpeg_CreateDecompress_xp (j_decompress_ptr cinfo, int version, size_t structsize)
 {
   int i;
+  j_decompress_ptr_xp xinfo;
 
   /* Guard against version mismatches between library and caller. */
   cinfo->mem = NULL;		/* so jpeg_destroy knows mem mgr not called */
@@ -55,11 +57,16 @@ jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
   cinfo->is_decompressor = TRUE;
 
   /* Initialize a memory manager instance for this object */
-  jinit_memory_mgr((j_common_ptr) cinfo);
+  jinit_memory_mgr_xp((j_common_ptr) cinfo);
+
+  xinfo = (j_decompress_ptr_xp)
+    (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
+        SIZEOF(jpeg_decompress_struct_xp));
+  cinfo->client_data = (void*) xinfo;
 
   /* Zero out pointers to permanent structures. */
   cinfo->progress = NULL;
-  cinfo->src = NULL;
+  xinfo->src_xp = NULL;
 
   for (i = 0; i < NUM_QUANT_TBLS; i++)
     cinfo->quant_tbl_ptrs[i] = NULL;
@@ -73,10 +80,10 @@ jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
    * for COM, APPn markers before calling jpeg_read_header.
    */
   cinfo->marker_list = NULL;
-  jinit_marker_reader(cinfo);
+  jinit_marker_reader_xp(cinfo);
 
   /* And initialize the overall input controller. */
-  jinit_input_controller(cinfo);
+  jinit_input_controller_xp(cinfo);
 
   /* OK, I'm ready */
   cinfo->global_state = DSTATE_START;
@@ -88,9 +95,9 @@ jpeg_CreateDecompress (j_decompress_ptr cinfo, int version, size_t structsize)
  */
 
 GLOBAL(void)
-jpeg_destroy_decompress (j_decompress_ptr cinfo)
+jpeg_destroy_decompress_xp (j_decompress_ptr cinfo)
 {
-  jpeg_destroy((j_common_ptr) cinfo); /* use common routine */
+  jpeg_destroy_xp((j_common_ptr) cinfo); /* use common routine */
 }
 
 
@@ -100,9 +107,9 @@ jpeg_destroy_decompress (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_abort_decompress (j_decompress_ptr cinfo)
+jpeg_abort_decompress_xp (j_decompress_ptr cinfo)
 {
-  jpeg_abort((j_common_ptr) cinfo); /* use common routine */
+  jpeg_abort_xp((j_common_ptr) cinfo); /* use common routine */
 }
 
 
@@ -111,8 +118,9 @@ jpeg_abort_decompress (j_decompress_ptr cinfo)
  */
 
 LOCAL(void)
-default_decompress_parms (j_decompress_ptr cinfo)
+default_decompress_parms_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   /* Guess the input colorspace, and set output colorspace accordingly. */
   /* (Wish JPEG committee had provided a real way to specify this...) */
   /* Note application may override our guesses. */
@@ -149,8 +157,14 @@ default_decompress_parms (j_decompress_ptr cinfo)
       else if (cid0 == 82 && cid1 == 71 && cid2 == 66)
 	cinfo->jpeg_color_space = JCS_RGB; /* ASCII 'R', 'G', 'B' */
       else {
-	TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
-	cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
+	if (xinfo->lossless_xp) {
+	  TRACEMS3(cinfo, 1, JTRC_UNKNOWN_LOSSLESS_IDS, cid0, cid1, cid2);
+	  cinfo->jpeg_color_space = JCS_RGB; /* assume it's RGB */
+	}
+	else {  /* Lossy processes */
+	  TRACEMS3(cinfo, 1, JTRC_UNKNOWN_IDS, cid0, cid1, cid2);
+	  cinfo->jpeg_color_space = JCS_YCbCr; /* assume it's YCbCr */
+	}
       }
     }
     /* Always guess RGB is proper output colorspace. */
@@ -202,7 +216,7 @@ default_decompress_parms (j_decompress_ptr cinfo)
   cinfo->two_pass_quantize = FALSE;
 #endif
   cinfo->desired_number_of_colors = 256;
-  cinfo->colormap = NULL;
+  xinfo->colormap_xp = NULL;
   /* Initialize for no mode change in buffered-image mode. */
   cinfo->enable_1pass_quant = FALSE;
   cinfo->enable_external_quant = FALSE;
@@ -238,7 +252,7 @@ default_decompress_parms (j_decompress_ptr cinfo)
  */
 
 GLOBAL(int)
-jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
+jpeg_read_header_xp (j_decompress_ptr cinfo, boolean require_image)
 {
   int retcode;
 
@@ -246,7 +260,7 @@ jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
       cinfo->global_state != DSTATE_INHEADER)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
-  retcode = jpeg_consume_input(cinfo);
+  retcode = jpeg_consume_input_xp(cinfo);
 
   switch (retcode) {
   case JPEG_REACHED_SOS:
@@ -259,7 +273,7 @@ jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
      * call jpeg_abort, but we can't change it now for compatibility reasons.
      * A side effect is to free any temporary memory (there shouldn't be any).
      */
-    jpeg_abort((j_common_ptr) cinfo); /* sets state = DSTATE_START */
+    jpeg_abort_xp((j_common_ptr) cinfo); /* sets state = DSTATE_START */
     retcode = JPEG_HEADER_TABLES_ONLY;
     break;
   case JPEG_SUSPENDED:
@@ -284,24 +298,25 @@ jpeg_read_header (j_decompress_ptr cinfo, boolean require_image)
  */
 
 GLOBAL(int)
-jpeg_consume_input (j_decompress_ptr cinfo)
+jpeg_consume_input_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int retcode = JPEG_SUSPENDED;
 
   /* NB: every possible DSTATE value should be listed in this switch */
   switch (cinfo->global_state) {
   case DSTATE_START:
     /* Start-of-datastream actions: reset appropriate modules */
-    (*cinfo->inputctl->reset_input_controller) (cinfo);
+    (*xinfo->inputctl_xp->reset_input_controller_xp) (cinfo);
     /* Initialize application's data source module */
-    (*cinfo->src->init_source) (cinfo);
+    (*xinfo->src_xp->init_source) (cinfo);
     cinfo->global_state = DSTATE_INHEADER;
     /*FALLTHROUGH*/
   case DSTATE_INHEADER:
-    retcode = (*cinfo->inputctl->consume_input) (cinfo);
+    retcode = (*xinfo->inputctl_xp->consume_input_xp) (cinfo);
     if (retcode == JPEG_REACHED_SOS) { /* Found SOS, prepare to decompress */
       /* Set up default parameters based on header data */
-      default_decompress_parms(cinfo);
+      default_decompress_parms_xp(cinfo);
       /* Set global state: ready for start_decompress */
       cinfo->global_state = DSTATE_READY;
     }
@@ -317,7 +332,7 @@ jpeg_consume_input (j_decompress_ptr cinfo)
   case DSTATE_BUFIMAGE:
   case DSTATE_BUFPOST:
   case DSTATE_STOPPING:
-    retcode = (*cinfo->inputctl->consume_input) (cinfo);
+    retcode = (*xinfo->inputctl_xp->consume_input_xp) (cinfo);
     break;
   default:
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
@@ -331,13 +346,14 @@ jpeg_consume_input (j_decompress_ptr cinfo)
  */
 
 GLOBAL(boolean)
-jpeg_input_complete (j_decompress_ptr cinfo)
+jpeg_input_complete_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   /* Check for valid jpeg object */
   if (cinfo->global_state < DSTATE_START ||
       cinfo->global_state > DSTATE_STOPPING)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
-  return cinfo->inputctl->eoi_reached;
+  return xinfo->inputctl_xp->eoi_reached;
 }
 
 
@@ -346,13 +362,14 @@ jpeg_input_complete (j_decompress_ptr cinfo)
  */
 
 GLOBAL(boolean)
-jpeg_has_multiple_scans (j_decompress_ptr cinfo)
+jpeg_has_multiple_scans_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   /* Only valid after jpeg_read_header completes */
   if (cinfo->global_state < DSTATE_READY ||
       cinfo->global_state > DSTATE_STOPPING)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
-  return cinfo->inputctl->has_multiple_scans;
+  return xinfo->inputctl_xp->has_multiple_scans;
 }
 
 
@@ -366,14 +383,15 @@ jpeg_has_multiple_scans (j_decompress_ptr cinfo)
  */
 
 GLOBAL(boolean)
-jpeg_finish_decompress (j_decompress_ptr cinfo)
+jpeg_finish_decompress_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   if ((cinfo->global_state == DSTATE_SCANNING ||
        cinfo->global_state == DSTATE_RAW_OK) && ! cinfo->buffered_image) {
     /* Terminate final pass of non-buffered mode */
     if (cinfo->output_scanline < cinfo->output_height)
       ERREXIT(cinfo, JERR_TOO_LITTLE_DATA);
-    (*cinfo->master->finish_output_pass) (cinfo);
+    (*xinfo->master_xp->finish_output_pass_xp) (cinfo);
     cinfo->global_state = DSTATE_STOPPING;
   } else if (cinfo->global_state == DSTATE_BUFIMAGE) {
     /* Finishing after a buffered-image operation */
@@ -383,13 +401,13 @@ jpeg_finish_decompress (j_decompress_ptr cinfo)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   }
   /* Read until EOI */
-  while (! cinfo->inputctl->eoi_reached) {
-    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
+  while (! xinfo->inputctl_xp->eoi_reached) {
+    if ((*xinfo->inputctl_xp->consume_input_xp) (cinfo) == JPEG_SUSPENDED)
       return FALSE;		/* Suspend, come back later */
   }
   /* Do final cleanup */
-  (*cinfo->src->term_source) (cinfo);
+  (*xinfo->src_xp->term_source) (cinfo);
   /* We can use jpeg_abort to release memory and reset global_state */
-  jpeg_abort((j_common_ptr) cinfo);
+  jpeg_abort_xp((j_common_ptr) cinfo);
   return TRUE;
 }
diff --git a/jdapistd.c b/xjdapistd.c
similarity index 80%
rename from jdapistd.c
rename to xjdapistd.c
index c8e3fa0..3de93c1 100644
--- a/jdapistd.c
+++ b/xjdapistd.c
@@ -1,5 +1,5 @@
 /*
- * jdapistd.c
+ * xjdapistd.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,11 +16,11 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Forward declarations */
-LOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));
+LOCAL(boolean) output_pass_setup_xp JPP((j_decompress_ptr cinfo));
 
 
 /*
@@ -35,11 +35,12 @@ LOCAL(boolean) output_pass_setup JPP((j_decompress_ptr cinfo));
  */
 
 GLOBAL(boolean)
-jpeg_start_decompress (j_decompress_ptr cinfo)
+jpeg_start_decompress_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   if (cinfo->global_state == DSTATE_READY) {
     /* First call: initialize master control, select active modules */
-    jinit_master_decompress(cinfo);
+    jinit_master_decompress_xp(cinfo);
     if (cinfo->buffered_image) {
       /* No more work here; expecting jpeg_start_output next */
       cinfo->global_state = DSTATE_BUFIMAGE;
@@ -49,7 +50,7 @@ jpeg_start_decompress (j_decompress_ptr cinfo)
   }
   if (cinfo->global_state == DSTATE_PRELOAD) {
     /* If file has multiple scans, absorb them all into the coef buffer */
-    if (cinfo->inputctl->has_multiple_scans) {
+    if (xinfo->inputctl_xp->has_multiple_scans) {
 #ifdef D_MULTISCAN_FILES_SUPPORTED
       for (;;) {
 	int retcode;
@@ -57,7 +58,7 @@ jpeg_start_decompress (j_decompress_ptr cinfo)
 	if (cinfo->progress != NULL)
 	  (*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
 	/* Absorb some more input */
-	retcode = (*cinfo->inputctl->consume_input) (cinfo);
+	retcode = (*xinfo->inputctl_xp->consume_input_xp) (cinfo);
 	if (retcode == JPEG_SUSPENDED)
 	  return FALSE;
 	if (retcode == JPEG_REACHED_EOI)
@@ -79,7 +80,7 @@ jpeg_start_decompress (j_decompress_ptr cinfo)
   } else if (cinfo->global_state != DSTATE_PRESCAN)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   /* Perform any dummy output passes, and set up for the final pass */
-  return output_pass_setup(cinfo);
+  return output_pass_setup_xp(cinfo);
 }
 
 
@@ -92,16 +93,17 @@ jpeg_start_decompress (j_decompress_ptr cinfo)
  */
 
 LOCAL(boolean)
-output_pass_setup (j_decompress_ptr cinfo)
+output_pass_setup_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   if (cinfo->global_state != DSTATE_PRESCAN) {
     /* First call: do pass setup */
-    (*cinfo->master->prepare_for_output_pass) (cinfo);
+    (*xinfo->master_xp->prepare_for_output_pass_xp) (cinfo);
     cinfo->output_scanline = 0;
     cinfo->global_state = DSTATE_PRESCAN;
   }
   /* Loop over any required dummy passes */
-  while (cinfo->master->is_dummy_pass) {
+  while (xinfo->master_xp->is_dummy_pass) {
 #ifdef QUANT_2PASS_SUPPORTED
     /* Crank through the dummy pass */
     while (cinfo->output_scanline < cinfo->output_height) {
@@ -114,14 +116,14 @@ output_pass_setup (j_decompress_ptr cinfo)
       }
       /* Process some data */
       last_scanline = cinfo->output_scanline;
-      (*cinfo->main->process_data) (cinfo, (JSAMPARRAY) NULL,
+      (*xinfo->main_xp->process_data_xp) (cinfo, (JSAMPARRAYXP) NULL,
 				    &cinfo->output_scanline, (JDIMENSION) 0);
       if (cinfo->output_scanline == last_scanline)
 	return FALSE;		/* No progress made, must suspend */
     }
     /* Finish up dummy pass, and set up for another one */
-    (*cinfo->master->finish_output_pass) (cinfo);
-    (*cinfo->master->prepare_for_output_pass) (cinfo);
+    (*xinfo->master_xp->finish_output_pass_xp) (cinfo);
+    (*xinfo->master_xp->prepare_for_output_pass_xp) (cinfo);
     cinfo->output_scanline = 0;
 #else
     ERREXIT(cinfo, JERR_NOT_COMPILED);
@@ -149,9 +151,10 @@ output_pass_setup (j_decompress_ptr cinfo)
  */
 
 GLOBAL(JDIMENSION)
-jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
+jpeg_read_scanlines_xp (j_decompress_ptr cinfo, JSAMPARRAYXP scanlines,
 		     JDIMENSION max_lines)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   JDIMENSION row_ctr;
 
   if (cinfo->global_state != DSTATE_SCANNING)
@@ -170,7 +173,7 @@ jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
 
   /* Process some data */
   row_ctr = 0;
-  (*cinfo->main->process_data) (cinfo, scanlines, &row_ctr, max_lines);
+  (*xinfo->main_xp->process_data_xp) (cinfo, scanlines, &row_ctr, max_lines);
   cinfo->output_scanline += row_ctr;
   return row_ctr;
 }
@@ -182,9 +185,10 @@ jpeg_read_scanlines (j_decompress_ptr cinfo, JSAMPARRAY scanlines,
  */
 
 GLOBAL(JDIMENSION)
-jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,
+jpeg_read_raw_data_xp (j_decompress_ptr cinfo, JSAMPIMAGEXP data,
 		    JDIMENSION max_lines)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   JDIMENSION lines_per_iMCU_row;
 
   if (cinfo->global_state != DSTATE_RAW_OK)
@@ -207,8 +211,16 @@ jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,
     ERREXIT(cinfo, JERR_BUFFER_SIZE);
 
   /* Decompress directly into user's buffer. */
-  if (! (*cinfo->coef->decompress_data) (cinfo, data))
-    return 0;			/* suspension forced, can do nothing more */
+  if (xinfo->lossless_xp)
+  {
+    if (! (*xinfo->codec_xp->decompress_data) (cinfo, data))
+      return 0;			/* suspension forced, can do nothing more */
+  }
+  else
+  {
+    if (! (*xinfo->coef_xp->decompress_data_xp) (cinfo, data))
+      return 0;			/* suspension forced, can do nothing more */
+  }
 
   /* OK, we processed one iMCU row. */
   cinfo->output_scanline += lines_per_iMCU_row;
@@ -225,20 +237,21 @@ jpeg_read_raw_data (j_decompress_ptr cinfo, JSAMPIMAGE data,
  */
 
 GLOBAL(boolean)
-jpeg_start_output (j_decompress_ptr cinfo, int scan_number)
+jpeg_start_output_xp (j_decompress_ptr cinfo, int scan_number)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   if (cinfo->global_state != DSTATE_BUFIMAGE &&
       cinfo->global_state != DSTATE_PRESCAN)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
   /* Limit scan number to valid range */
   if (scan_number <= 0)
     scan_number = 1;
-  if (cinfo->inputctl->eoi_reached &&
+  if (xinfo->inputctl_xp->eoi_reached &&
       scan_number > cinfo->input_scan_number)
     scan_number = cinfo->input_scan_number;
   cinfo->output_scan_number = scan_number;
   /* Perform any dummy output passes, and set up for the real pass */
-  return output_pass_setup(cinfo);
+  return output_pass_setup_xp(cinfo);
 }
 
 
@@ -250,13 +263,14 @@ jpeg_start_output (j_decompress_ptr cinfo, int scan_number)
  */
 
 GLOBAL(boolean)
-jpeg_finish_output (j_decompress_ptr cinfo)
+jpeg_finish_output_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   if ((cinfo->global_state == DSTATE_SCANNING ||
        cinfo->global_state == DSTATE_RAW_OK) && cinfo->buffered_image) {
     /* Terminate this pass. */
     /* We do not require the whole pass to have been completed. */
-    (*cinfo->master->finish_output_pass) (cinfo);
+    (*xinfo->master_xp->finish_output_pass_xp) (cinfo);
     cinfo->global_state = DSTATE_BUFPOST;
   } else if (cinfo->global_state != DSTATE_BUFPOST) {
     /* BUFPOST = repeat call after a suspension, anything else is error */
@@ -264,8 +278,8 @@ jpeg_finish_output (j_decompress_ptr cinfo)
   }
   /* Read markers looking for SOS or EOI */
   while (cinfo->input_scan_number <= cinfo->output_scan_number &&
-	 ! cinfo->inputctl->eoi_reached) {
-    if ((*cinfo->inputctl->consume_input) (cinfo) == JPEG_SUSPENDED)
+	 ! xinfo->inputctl_xp->eoi_reached) {
+    if ((*xinfo->inputctl_xp->consume_input_xp) (cinfo) == JPEG_SUSPENDED)
       return FALSE;		/* Suspend, come back later */
   }
   cinfo->global_state = DSTATE_BUFIMAGE;
diff --git a/jdatadst.c b/xjdatadst.c
similarity index 80%
rename from jdatadst.c
rename to xjdatadst.c
index a8f6fb0..5d01260 100644
--- a/jdatadst.c
+++ b/xjdatadst.c
@@ -1,5 +1,5 @@
 /*
- * jdatadst.c
+ * xjdatadst.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,14 +16,14 @@
 
 /* this is not a core library module, so it doesn't define JPEG_INTERNALS */
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 #include "jerror.h"
 
 
 /* Expanded data destination object for stdio output */
 
 typedef struct {
-  struct jpeg_destination_mgr pub; /* public fields */
+  struct jpeg_destination_mgr_xp pub; /* public fields */
 
   FILE * outfile;		/* target stream */
   JOCTET * buffer;		/* start of buffer */
@@ -40,9 +40,10 @@ typedef my_destination_mgr * my_dest_ptr;
  */
 
 METHODDEF(void)
-init_destination (j_compress_ptr cinfo)
+init_destination_xp (j_compress_ptr cinfo)
 {
-  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_dest_ptr dest = (my_dest_ptr) xinfo->dest_xp;
 
   /* Allocate the output buffer --- it will be released when done with image */
   dest->buffer = (JOCTET *)
@@ -78,9 +79,10 @@ init_destination (j_compress_ptr cinfo)
  */
 
 METHODDEF(boolean)
-empty_output_buffer (j_compress_ptr cinfo)
+empty_output_buffer_xp (j_compress_ptr cinfo)
 {
-  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_dest_ptr dest = (my_dest_ptr) xinfo->dest_xp;
 
   if (JFWRITE(dest->outfile, dest->buffer, OUTPUT_BUF_SIZE) !=
       (size_t) OUTPUT_BUF_SIZE)
@@ -103,9 +105,10 @@ empty_output_buffer (j_compress_ptr cinfo)
  */
 
 METHODDEF(void)
-term_destination (j_compress_ptr cinfo)
+term_destination_xp (j_compress_ptr cinfo)
 {
-  my_dest_ptr dest = (my_dest_ptr) cinfo->dest;
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
+  my_dest_ptr dest = (my_dest_ptr) xinfo->dest_xp;
   size_t datacount = OUTPUT_BUF_SIZE - dest->pub.free_in_buffer;
 
   /* Write any data remaining in the buffer */
@@ -127,8 +130,9 @@ term_destination (j_compress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_stdio_dest (j_compress_ptr cinfo, FILE * outfile)
+jpeg_stdio_dest_xp (j_compress_ptr cinfo, FILE * outfile)
 {
+  j_compress_ptr_xp xinfo = (j_compress_ptr_xp) cinfo->client_data;
   my_dest_ptr dest;
 
   /* The destination object is made permanent so that multiple JPEG images
@@ -137,15 +141,15 @@ jpeg_stdio_dest (j_compress_ptr cinfo, FILE * outfile)
    * manager serially with the same JPEG object, because their private object
    * sizes may be different.  Caveat programmer.
    */
-  if (cinfo->dest == NULL) {	/* first time for this JPEG object? */
-    cinfo->dest = (struct jpeg_destination_mgr *)
+  if (xinfo->dest_xp == NULL) {	/* first time for this JPEG object? */
+    xinfo->dest_xp = (struct jpeg_destination_mgr_xp *)
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 				  SIZEOF(my_destination_mgr));
   }
 
-  dest = (my_dest_ptr) cinfo->dest;
-  dest->pub.init_destination = init_destination;
-  dest->pub.empty_output_buffer = empty_output_buffer;
-  dest->pub.term_destination = term_destination;
+  dest = (my_dest_ptr) xinfo->dest_xp;
+  dest->pub.init_destination_xp = init_destination_xp;
+  dest->pub.empty_output_buffer_xp = empty_output_buffer_xp;
+  dest->pub.term_destination_xp = term_destination_xp;
   dest->outfile = outfile;
 }
diff --git a/jdatasrc.c b/xjdatasrc.c
similarity index 89%
rename from jdatasrc.c
rename to xjdatasrc.c
index edc752b..d473afc 100644
--- a/jdatasrc.c
+++ b/xjdatasrc.c
@@ -1,5 +1,5 @@
 /*
- * jdatasrc.c
+ * xjdatasrc.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,14 +16,14 @@
 
 /* this is not a core library module, so it doesn't define JPEG_INTERNALS */
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 #include "jerror.h"
 
 
 /* Expanded data source object for stdio input */
 
 typedef struct {
-  struct jpeg_source_mgr pub;	/* public fields */
+  struct jpeg_source_mgr_xp pub;	/* public fields */
 
   FILE * infile;		/* source stream */
   JOCTET * buffer;		/* start of buffer */
@@ -43,7 +43,8 @@ typedef my_source_mgr * my_src_ptr;
 METHODDEF(void)
 init_source (j_decompress_ptr cinfo)
 {
-  my_src_ptr src = (my_src_ptr) cinfo->src;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_src_ptr src = (my_src_ptr) xinfo->src_xp;
 
   /* We reset the empty-input-file flag for each image,
    * but we don't clear the input buffer.
@@ -89,7 +90,8 @@ init_source (j_decompress_ptr cinfo)
 METHODDEF(boolean)
 fill_input_buffer (j_decompress_ptr cinfo)
 {
-  my_src_ptr src = (my_src_ptr) cinfo->src;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_src_ptr src = (my_src_ptr) xinfo->src_xp;
   size_t nbytes;
 
   nbytes = JFREAD(src->infile, src->buffer, INPUT_BUF_SIZE);
@@ -127,7 +129,8 @@ fill_input_buffer (j_decompress_ptr cinfo)
 METHODDEF(void)
 skip_input_data (j_decompress_ptr cinfo, long num_bytes)
 {
-  my_src_ptr src = (my_src_ptr) cinfo->src;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_src_ptr src = (my_src_ptr) xinfo->src_xp;
 
   /* Just a dumb implementation for now.  Could use fseek() except
    * it doesn't work on pipes.  Not clear that being smart is worth
@@ -179,8 +182,9 @@ term_source (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile)
+jpeg_stdio_src_xp (j_decompress_ptr cinfo, FILE * infile)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_src_ptr src;
 
   /* The source object and input buffer are made permanent so that a series
@@ -190,21 +194,21 @@ jpeg_stdio_src (j_decompress_ptr cinfo, FILE * infile)
    * This makes it unsafe to use this manager and a different source
    * manager serially with the same JPEG object.  Caveat programmer.
    */
-  if (cinfo->src == NULL) {	/* first time for this JPEG object? */
-    cinfo->src = (struct jpeg_source_mgr *)
+  if (xinfo->src_xp == NULL) {	/* first time for this JPEG object? */
+    xinfo->src_xp = (struct jpeg_source_mgr_xp *)
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 				  SIZEOF(my_source_mgr));
-    src = (my_src_ptr) cinfo->src;
+    src = (my_src_ptr) xinfo->src_xp;
     src->buffer = (JOCTET *)
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 				  INPUT_BUF_SIZE * SIZEOF(JOCTET));
   }
 
-  src = (my_src_ptr) cinfo->src;
+  src = (my_src_ptr) xinfo->src_xp;
   src->pub.init_source = init_source;
   src->pub.fill_input_buffer = fill_input_buffer;
   src->pub.skip_input_data = skip_input_data;
-  src->pub.resync_to_restart = jpeg_resync_to_restart; /* use default method */
+  src->pub.resync_to_restart_xp = jpeg_resync_to_restart_xp; /* use default method */
   src->pub.term_source = term_source;
   src->infile = infile;
   src->pub.bytes_in_buffer = 0; /* forces fill_input_buffer on first read */
diff --git a/jdcoefct.c b/xjdcoefct.c
similarity index 86%
rename from jdcoefct.c
rename to xjdcoefct.c
index 4938d20..e1c37b4 100644
--- a/jdcoefct.c
+++ b/xjdcoefct.c
@@ -1,5 +1,5 @@
 /*
- * jdcoefct.c
+ * xjdcoefct.c
  *
  * Copyright (C) 1994-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,7 +16,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 /* Block smoothing is only applicable for progressive JPEG, so: */
 #ifndef D_PROGRESSIVE_SUPPORTED
@@ -26,7 +26,7 @@
 /* Private buffer controller object */
 
 typedef struct {
-  struct jpeg_d_coef_controller pub; /* public fields */
+  struct jpeg_d_coef_controller_xp pub; /* public fields */
 
   /* These variables keep track of the current location of the input side. */
   /* cinfo->input_iMCU_row is also used for this. */
@@ -62,24 +62,25 @@ typedef struct {
 typedef my_coef_controller * my_coef_ptr;
 
 /* Forward declarations */
-METHODDEF(int) decompress_onepass
-	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
+METHODDEF(int) decompress_onepass_xp
+	JPP((j_decompress_ptr cinfo, JSAMPIMAGEXP output_buf));
 #ifdef D_MULTISCAN_FILES_SUPPORTED
-METHODDEF(int) decompress_data
-	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
+METHODDEF(int) decompress_data_xp
+	JPP((j_decompress_ptr cinfo, JSAMPIMAGEXP output_buf));
 #endif
 #ifdef BLOCK_SMOOTHING_SUPPORTED
-LOCAL(boolean) smoothing_ok JPP((j_decompress_ptr cinfo));
-METHODDEF(int) decompress_smooth_data
-	JPP((j_decompress_ptr cinfo, JSAMPIMAGE output_buf));
+LOCAL(boolean) smoothing_ok_xp JPP((j_decompress_ptr cinfo));
+METHODDEF(int) decompress_smooth_data_xp
+	JPP((j_decompress_ptr cinfo, JSAMPIMAGEXP output_buf));
 #endif
 
 
 LOCAL(void)
-start_iMCU_row (j_decompress_ptr cinfo)
+start_iMCU_row_xp (j_decompress_ptr cinfo)
 /* Reset within-iMCU-row counters for a new row (input side) */
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
 
   /* In an interleaved scan, an MCU row is the same as an iMCU row.
    * In a noninterleaved scan, an iMCU row has v_samp_factor MCU rows.
@@ -104,10 +105,10 @@ start_iMCU_row (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_input_pass (j_decompress_ptr cinfo)
+start_input_pass_xp (j_decompress_ptr cinfo)
 {
   cinfo->input_iMCU_row = 0;
-  start_iMCU_row(cinfo);
+  start_iMCU_row_xp(cinfo);
 }
 
 
@@ -116,17 +117,18 @@ start_input_pass (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_output_pass (j_decompress_ptr cinfo)
+start_output_pass_xp (j_decompress_ptr cinfo)
 {
 #ifdef BLOCK_SMOOTHING_SUPPORTED
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
 
   /* If multipass, check to see whether to use block smoothing on this pass */
   if (coef->pub.coef_arrays != NULL) {
-    if (cinfo->do_block_smoothing && smoothing_ok(cinfo))
-      coef->pub.decompress_data = decompress_smooth_data;
+    if (cinfo->do_block_smoothing && smoothing_ok_xp(cinfo))
+      coef->pub.decompress_data_xp = decompress_smooth_data_xp;
     else
-      coef->pub.decompress_data = decompress_data;
+      coef->pub.decompress_data_xp = decompress_data_xp;
   }
 #endif
   cinfo->output_iMCU_row = 0;
@@ -144,17 +146,18 @@ start_output_pass (j_decompress_ptr cinfo)
  */
 
 METHODDEF(int)
-decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
+decompress_onepass_xp (j_decompress_ptr cinfo, JSAMPIMAGEXP output_buf)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
   JDIMENSION MCU_col_num;	/* index of current MCU within row */
   JDIMENSION last_MCU_col = cinfo->MCUs_per_row - 1;
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
   int blkn, ci, xindex, yindex, yoffset, useful_width;
-  JSAMPARRAY output_ptr;
+  JSAMPARRAYXP output_ptr;
   JDIMENSION start_col, output_col;
   jpeg_component_info *compptr;
-  inverse_DCT_method_ptr inverse_DCT;
+  inverse_DCT_method_ptr_xp inverse_DCT;
 
   /* Loop to process as much as one whole iMCU row */
   for (yoffset = coef->MCU_vert_offset; yoffset < coef->MCU_rows_per_iMCU_row;
@@ -164,7 +167,7 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
       /* Try to fetch an MCU.  Entropy decoder expects buffer to be zeroed. */
       jzero_far((void FAR *) coef->MCU_buffer[0],
 		(size_t) (cinfo->blocks_in_MCU * SIZEOF(JBLOCK)));
-      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
+      if (! (*xinfo->entropy_xp->decode_mcu_xp) (cinfo, coef->MCU_buffer)) {
 	/* Suspension forced; update state counters and exit */
 	coef->MCU_vert_offset = yoffset;
 	coef->MCU_ctr = MCU_col_num;
@@ -183,7 +186,7 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
 	  blkn += compptr->MCU_blocks;
 	  continue;
 	}
-	inverse_DCT = cinfo->idct->inverse_DCT[compptr->component_index];
+	inverse_DCT = xinfo->idct_xp->inverse_DCT[compptr->component_index];
 	useful_width = (MCU_col_num < last_MCU_col) ? compptr->MCU_width
 						    : compptr->last_col_width;
 	output_ptr = output_buf[compptr->component_index] +
@@ -211,11 +214,11 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
   /* Completed the iMCU row, advance counters for next one */
   cinfo->output_iMCU_row++;
   if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
-    start_iMCU_row(cinfo);
+    start_iMCU_row_xp(cinfo);
     return JPEG_ROW_COMPLETED;
   }
   /* Completed the scan */
-  (*cinfo->inputctl->finish_input_pass) (cinfo);
+  (*xinfo->inputctl_xp->finish_input_pass_xp) (cinfo);
   return JPEG_SCAN_COMPLETED;
 }
 
@@ -225,7 +228,7 @@ decompress_onepass (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  */
 
 METHODDEF(int)
-dummy_consume_data (j_decompress_ptr cinfo)
+dummy_consume_data_xp (j_decompress_ptr cinfo)
 {
   return JPEG_SUSPENDED;	/* Always indicate nothing was done */
 }
@@ -241,9 +244,10 @@ dummy_consume_data (j_decompress_ptr cinfo)
  */
 
 METHODDEF(int)
-consume_data (j_decompress_ptr cinfo)
+consume_data_xp (j_decompress_ptr cinfo)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
   JDIMENSION MCU_col_num;	/* index of current MCU within row */
   int blkn, ci, xindex, yindex, yoffset;
   JDIMENSION start_col;
@@ -282,7 +286,7 @@ consume_data (j_decompress_ptr cinfo)
 	}
       }
       /* Try to fetch the MCU. */
-      if (! (*cinfo->entropy->decode_mcu) (cinfo, coef->MCU_buffer)) {
+      if (! (*xinfo->entropy_xp->decode_mcu_xp) (cinfo, coef->MCU_buffer)) {
 	/* Suspension forced; update state counters and exit */
 	coef->MCU_vert_offset = yoffset;
 	coef->MCU_ctr = MCU_col_num;
@@ -294,11 +298,11 @@ consume_data (j_decompress_ptr cinfo)
   }
   /* Completed the iMCU row, advance counters for next one */
   if (++(cinfo->input_iMCU_row) < cinfo->total_iMCU_rows) {
-    start_iMCU_row(cinfo);
+    start_iMCU_row_xp(cinfo);
     return JPEG_ROW_COMPLETED;
   }
   /* Completed the scan */
-  (*cinfo->inputctl->finish_input_pass) (cinfo);
+  (*xinfo->inputctl_xp->finish_input_pass_xp) (cinfo);
   return JPEG_SCAN_COMPLETED;
 }
 
@@ -312,24 +316,25 @@ consume_data (j_decompress_ptr cinfo)
  */
 
 METHODDEF(int)
-decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
+decompress_data_xp (j_decompress_ptr cinfo, JSAMPIMAGEXP output_buf)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
   JDIMENSION block_num;
   int ci, block_row, block_rows;
   JBLOCKARRAY buffer;
   JBLOCKROW buffer_ptr;
-  JSAMPARRAY output_ptr;
+  JSAMPARRAYXP output_ptr;
   JDIMENSION output_col;
   jpeg_component_info *compptr;
-  inverse_DCT_method_ptr inverse_DCT;
+  inverse_DCT_method_ptr_xp inverse_DCT;
 
   /* Force some input to be done if we are getting ahead of the input. */
   while (cinfo->input_scan_number < cinfo->output_scan_number ||
 	 (cinfo->input_scan_number == cinfo->output_scan_number &&
 	  cinfo->input_iMCU_row <= cinfo->output_iMCU_row)) {
-    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
+    if ((*xinfo->inputctl_xp->consume_input_xp)(cinfo) == JPEG_SUSPENDED)
       return JPEG_SUSPENDED;
   }
 
@@ -352,7 +357,7 @@ decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
       block_rows = (int) (compptr->height_in_blocks % compptr->v_samp_factor);
       if (block_rows == 0) block_rows = compptr->v_samp_factor;
     }
-    inverse_DCT = cinfo->idct->inverse_DCT[ci];
+    inverse_DCT = xinfo->idct_xp->inverse_DCT[ci];
     output_ptr = output_buf[ci];
     /* Loop over all DCT blocks to be processed. */
     for (block_row = 0; block_row < block_rows; block_row++) {
@@ -402,9 +407,10 @@ decompress_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  */
 
 LOCAL(boolean)
-smoothing_ok (j_decompress_ptr cinfo)
+smoothing_ok_xp (j_decompress_ptr cinfo)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
   boolean smoothing_useful = FALSE;
   int ci, coefi;
   jpeg_component_info *compptr;
@@ -458,18 +464,19 @@ smoothing_ok (j_decompress_ptr cinfo)
  */
 
 METHODDEF(int)
-decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
+decompress_smooth_data_xp (j_decompress_ptr cinfo, JSAMPIMAGEXP output_buf)
 {
-  my_coef_ptr coef = (my_coef_ptr) cinfo->coef;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_coef_ptr coef = (my_coef_ptr) xinfo->coef_xp;
   JDIMENSION last_iMCU_row = cinfo->total_iMCU_rows - 1;
   JDIMENSION block_num, last_block_column;
   int ci, block_row, block_rows, access_rows;
   JBLOCKARRAY buffer;
   JBLOCKROW buffer_ptr, prev_block_row, next_block_row;
-  JSAMPARRAY output_ptr;
+  JSAMPARRAYXP output_ptr;
   JDIMENSION output_col;
   jpeg_component_info *compptr;
-  inverse_DCT_method_ptr inverse_DCT;
+  inverse_DCT_method_ptr_xp inverse_DCT;
   boolean first_row, last_row;
   JBLOCK workspace;
   int *coef_bits;
@@ -480,7 +487,7 @@ decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
 
   /* Force some input to be done if we are getting ahead of the input. */
   while (cinfo->input_scan_number <= cinfo->output_scan_number &&
-	 ! cinfo->inputctl->eoi_reached) {
+	 ! xinfo->inputctl_xp->eoi_reached) {
     if (cinfo->input_scan_number == cinfo->output_scan_number) {
       /* If input is working on current scan, we ordinarily want it to
        * have completed the current row.  But if input scan is DC,
@@ -491,7 +498,7 @@ decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
       if (cinfo->input_iMCU_row > cinfo->output_iMCU_row+delta)
 	break;
     }
-    if ((*cinfo->inputctl->consume_input)(cinfo) == JPEG_SUSPENDED)
+    if ((*xinfo->inputctl_xp->consume_input_xp)(cinfo) == JPEG_SUSPENDED)
       return JPEG_SUSPENDED;
   }
 
@@ -537,7 +544,7 @@ decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
     Q20 = quanttbl->quantval[Q20_POS];
     Q11 = quanttbl->quantval[Q11_POS];
     Q02 = quanttbl->quantval[Q02_POS];
-    inverse_DCT = cinfo->idct->inverse_DCT[ci];
+    inverse_DCT = xinfo->idct_xp->inverse_DCT[ci];
     output_ptr = output_buf[ci];
     /* Loop over all DCT blocks to be processed. */
     for (block_row = 0; block_row < block_rows; block_row++) {
@@ -673,16 +680,17 @@ decompress_smooth_data (j_decompress_ptr cinfo, JSAMPIMAGE output_buf)
  */
 
 GLOBAL(void)
-jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
+jinit_d_coef_controller_xp (j_decompress_ptr cinfo, boolean need_full_buffer)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_coef_ptr coef;
 
   coef = (my_coef_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_coef_controller));
-  cinfo->coef = (struct jpeg_d_coef_controller *) coef;
-  coef->pub.start_input_pass = start_input_pass;
-  coef->pub.start_output_pass = start_output_pass;
+  xinfo->coef_xp = (struct jpeg_d_coef_controller_xp *) coef;
+  coef->pub.start_input_pass_xp = start_input_pass_xp;
+  coef->pub.start_output_pass_xp = start_output_pass_xp;
 #ifdef BLOCK_SMOOTHING_SUPPORTED
   coef->coef_bits_latch = NULL;
 #endif
@@ -712,8 +720,8 @@ jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
 				(long) compptr->v_samp_factor),
 	 (JDIMENSION) access_rows);
     }
-    coef->pub.consume_data = consume_data;
-    coef->pub.decompress_data = decompress_data;
+    coef->pub.consume_data_xp = consume_data_xp;
+    coef->pub.decompress_data_xp = decompress_data_xp;
     coef->pub.coef_arrays = coef->whole_image; /* link to virtual arrays */
 #else
     ERREXIT(cinfo, JERR_NOT_COMPILED);
@@ -729,8 +737,8 @@ jinit_d_coef_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
     for (i = 0; i < D_MAX_BLOCKS_IN_MCU; i++) {
       coef->MCU_buffer[i] = buffer + i;
     }
-    coef->pub.consume_data = dummy_consume_data;
-    coef->pub.decompress_data = decompress_onepass;
+    coef->pub.consume_data_xp = dummy_consume_data_xp;
+    coef->pub.decompress_data_xp = decompress_onepass_xp;
     coef->pub.coef_arrays = NULL; /* flag for no virtual arrays */
   }
 }
diff --git a/jdcolor.c b/xjdcolor.c
similarity index 77%
rename from jdcolor.c
rename to xjdcolor.c
index 6c04dfe..b57fe5d 100644
--- a/jdcolor.c
+++ b/xjdcolor.c
@@ -1,5 +1,5 @@
 /*
- * jdcolor.c
+ * xjdcolor.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -10,13 +10,13 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Private subobject */
 
 typedef struct {
-  struct jpeg_color_deconverter pub; /* public fields */
+  struct jpeg_color_deconverter_xp pub; /* public fields */
 
   /* Private state for YCC->RGB conversion */
   int * Cr_r_tab;		/* => table for Cr to R conversion */
@@ -67,27 +67,30 @@ typedef my_color_deconverter * my_cconvert_ptr;
  */
 
 LOCAL(void)
-build_ycc_rgb_table (j_decompress_ptr cinfo)
+build_ycc_rgb_table_xp (j_decompress_ptr cinfo)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) xinfo->cconvert_xp;
+  const JSAMPLEXP MAXJSAMPLEXP = xinfo->max_JSAMPLEXP;
+  const JSAMPLEXP CENTERJSAMPLEXP = xinfo->center_JSAMPLEXP;
   int i;
   INT32 x;
   SHIFT_TEMPS
 
   cconvert->Cr_r_tab = (int *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				(MAXJSAMPLE+1) * SIZEOF(int));
+				(MAXJSAMPLEXP+1) * SIZEOF(int));
   cconvert->Cb_b_tab = (int *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				(MAXJSAMPLE+1) * SIZEOF(int));
+				(MAXJSAMPLEXP+1) * SIZEOF(int));
   cconvert->Cr_g_tab = (INT32 *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				(MAXJSAMPLE+1) * SIZEOF(INT32));
+				(MAXJSAMPLEXP+1) * SIZEOF(INT32));
   cconvert->Cb_g_tab = (INT32 *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				(MAXJSAMPLE+1) * SIZEOF(INT32));
+				(MAXJSAMPLEXP+1) * SIZEOF(INT32));
 
-  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
+  for (i = 0, x = -CENTERJSAMPLEXP; i <= MAXJSAMPLEXP; i++, x++) {
     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
     /* Cr=>R value is nearest int to 1.40200 * x */
@@ -117,18 +120,19 @@ build_ycc_rgb_table (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-ycc_rgb_convert (j_decompress_ptr cinfo,
-		 JSAMPIMAGE input_buf, JDIMENSION input_row,
-		 JSAMPARRAY output_buf, int num_rows)
+ycc_rgb_convert_xp (j_decompress_ptr cinfo,
+		 JSAMPIMAGEXP input_buf, JDIMENSION input_row,
+		 JSAMPARRAYXP output_buf, int num_rows)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) xinfo->cconvert_xp;
   register int y, cb, cr;
-  register JSAMPROW outptr;
-  register JSAMPROW inptr0, inptr1, inptr2;
+  register JSAMPROWXP outptr;
+  register JSAMPROWXP inptr0, inptr1, inptr2;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->output_width;
   /* copy these pointers into registers if possible */
-  register JSAMPLE * range_limit = cinfo->sample_range_limit;
+  register JSAMPLEXP * range_limit = xinfo->sample_range_limit_xp;
   register int * Crrtab = cconvert->Cr_r_tab;
   register int * Cbbtab = cconvert->Cb_b_tab;
   register INT32 * Crgtab = cconvert->Cr_g_tab;
@@ -166,11 +170,11 @@ ycc_rgb_convert (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-null_convert (j_decompress_ptr cinfo,
-	      JSAMPIMAGE input_buf, JDIMENSION input_row,
-	      JSAMPARRAY output_buf, int num_rows)
+null_convert_xp (j_decompress_ptr cinfo,
+	      JSAMPIMAGEXP input_buf, JDIMENSION input_row,
+	      JSAMPARRAYXP output_buf, int num_rows)
 {
-  register JSAMPROW inptr, outptr;
+  register JSAMPROWXP inptr, outptr;
   register JDIMENSION count;
   register int num_components = cinfo->num_components;
   JDIMENSION num_cols = cinfo->output_width;
@@ -198,11 +202,11 @@ null_convert (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-grayscale_convert (j_decompress_ptr cinfo,
-		   JSAMPIMAGE input_buf, JDIMENSION input_row,
-		   JSAMPARRAY output_buf, int num_rows)
+grayscale_convert_xp (j_decompress_ptr cinfo,
+		   JSAMPIMAGEXP input_buf, JDIMENSION input_row,
+		   JSAMPARRAYXP output_buf, int num_rows)
 {
-  jcopy_sample_rows(input_buf[0], (int) input_row, output_buf, 0,
+  jcopy_sample_rows_xp(input_buf[0], (int) input_row, output_buf, 0,
 		    num_rows, cinfo->output_width);
 }
 
@@ -214,11 +218,11 @@ grayscale_convert (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-gray_rgb_convert (j_decompress_ptr cinfo,
-		  JSAMPIMAGE input_buf, JDIMENSION input_row,
-		  JSAMPARRAY output_buf, int num_rows)
+gray_rgb_convert_xp (j_decompress_ptr cinfo,
+		  JSAMPIMAGEXP input_buf, JDIMENSION input_row,
+		  JSAMPARRAYXP output_buf, int num_rows)
 {
-  register JSAMPROW inptr, outptr;
+  register JSAMPROWXP inptr, outptr;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->output_width;
 
@@ -242,18 +246,20 @@ gray_rgb_convert (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-ycck_cmyk_convert (j_decompress_ptr cinfo,
-		   JSAMPIMAGE input_buf, JDIMENSION input_row,
-		   JSAMPARRAY output_buf, int num_rows)
+ycck_cmyk_convert_xp (j_decompress_ptr cinfo,
+		   JSAMPIMAGEXP input_buf, JDIMENSION input_row,
+		   JSAMPARRAYXP output_buf, int num_rows)
 {
-  my_cconvert_ptr cconvert = (my_cconvert_ptr) cinfo->cconvert;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cconvert_ptr cconvert = (my_cconvert_ptr) xinfo->cconvert_xp;
+  const JSAMPLEXP MAXJSAMPLEXP = xinfo->max_JSAMPLEXP;
   register int y, cb, cr;
-  register JSAMPROW outptr;
-  register JSAMPROW inptr0, inptr1, inptr2, inptr3;
+  register JSAMPROWXP outptr;
+  register JSAMPROWXP inptr0, inptr1, inptr2, inptr3;
   register JDIMENSION col;
   JDIMENSION num_cols = cinfo->output_width;
   /* copy these pointers into registers if possible */
-  register JSAMPLE * range_limit = cinfo->sample_range_limit;
+  register JSAMPLEXP * range_limit = xinfo->sample_range_limit_xp;
   register int * Crrtab = cconvert->Cr_r_tab;
   register int * Cbbtab = cconvert->Cb_b_tab;
   register INT32 * Crgtab = cconvert->Cr_g_tab;
@@ -272,11 +278,11 @@ ycck_cmyk_convert (j_decompress_ptr cinfo,
       cb = GETJSAMPLE(inptr1[col]);
       cr = GETJSAMPLE(inptr2[col]);
       /* Range-limiting is essential due to noise introduced by DCT losses. */
-      outptr[0] = range_limit[MAXJSAMPLE - (y + Crrtab[cr])];	/* red */
-      outptr[1] = range_limit[MAXJSAMPLE - (y +			/* green */
+      outptr[0] = range_limit[MAXJSAMPLEXP - (y + Crrtab[cr])];	/* red */
+      outptr[1] = range_limit[MAXJSAMPLEXP - (y +			/* green */
 			      ((int) RIGHT_SHIFT(Cbgtab[cb] + Crgtab[cr],
 						 SCALEBITS)))];
-      outptr[2] = range_limit[MAXJSAMPLE - (y + Cbbtab[cb])];	/* blue */
+      outptr[2] = range_limit[MAXJSAMPLEXP - (y + Cbbtab[cb])];	/* blue */
       /* K passes through unchanged */
       outptr[3] = inptr3[col];	/* don't need GETJSAMPLE here */
       outptr += 4;
@@ -290,7 +296,7 @@ ycck_cmyk_convert (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-start_pass_dcolor (j_decompress_ptr cinfo)
+start_pass_dcolor_xp (j_decompress_ptr cinfo)
 {
   /* no work needed */
 }
@@ -301,16 +307,17 @@ start_pass_dcolor (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_color_deconverter (j_decompress_ptr cinfo)
+jinit_color_deconverter_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_cconvert_ptr cconvert;
   int ci;
 
   cconvert = (my_cconvert_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_color_deconverter));
-  cinfo->cconvert = (struct jpeg_color_deconverter *) cconvert;
-  cconvert->pub.start_pass = start_pass_dcolor;
+  xinfo->cconvert_xp = (struct jpeg_color_deconverter_xp *) cconvert;
+  cconvert->pub.start_pass_xp = start_pass_dcolor_xp;
 
   /* Make sure num_components agrees with jpeg_color_space */
   switch (cinfo->jpeg_color_space) {
@@ -347,7 +354,7 @@ jinit_color_deconverter (j_decompress_ptr cinfo)
     cinfo->out_color_components = 1;
     if (cinfo->jpeg_color_space == JCS_GRAYSCALE ||
 	cinfo->jpeg_color_space == JCS_YCbCr) {
-      cconvert->pub.color_convert = grayscale_convert;
+      cconvert->pub.color_convert_xp = grayscale_convert_xp;
       /* For color->grayscale conversion, only the Y (0) component is needed */
       for (ci = 1; ci < cinfo->num_components; ci++)
 	cinfo->comp_info[ci].component_needed = FALSE;
@@ -358,12 +365,12 @@ jinit_color_deconverter (j_decompress_ptr cinfo)
   case JCS_RGB:
     cinfo->out_color_components = RGB_PIXELSIZE;
     if (cinfo->jpeg_color_space == JCS_YCbCr) {
-      cconvert->pub.color_convert = ycc_rgb_convert;
-      build_ycc_rgb_table(cinfo);
+      cconvert->pub.color_convert_xp = ycc_rgb_convert_xp;
+      build_ycc_rgb_table_xp(cinfo);
     } else if (cinfo->jpeg_color_space == JCS_GRAYSCALE) {
-      cconvert->pub.color_convert = gray_rgb_convert;
+      cconvert->pub.color_convert_xp = gray_rgb_convert_xp;
     } else if (cinfo->jpeg_color_space == JCS_RGB && RGB_PIXELSIZE == 3) {
-      cconvert->pub.color_convert = null_convert;
+      cconvert->pub.color_convert_xp = null_convert_xp;
     } else
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     break;
@@ -371,10 +378,10 @@ jinit_color_deconverter (j_decompress_ptr cinfo)
   case JCS_CMYK:
     cinfo->out_color_components = 4;
     if (cinfo->jpeg_color_space == JCS_YCCK) {
-      cconvert->pub.color_convert = ycck_cmyk_convert;
-      build_ycc_rgb_table(cinfo);
+      cconvert->pub.color_convert_xp = ycck_cmyk_convert_xp;
+      build_ycc_rgb_table_xp(cinfo);
     } else if (cinfo->jpeg_color_space == JCS_CMYK) {
-      cconvert->pub.color_convert = null_convert;
+      cconvert->pub.color_convert_xp = null_convert_xp;
     } else
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     break;
@@ -383,7 +390,7 @@ jinit_color_deconverter (j_decompress_ptr cinfo)
     /* Permit null conversion to same output space */
     if (cinfo->out_color_space == cinfo->jpeg_color_space) {
       cinfo->out_color_components = cinfo->num_components;
-      cconvert->pub.color_convert = null_convert;
+      cconvert->pub.color_convert_xp = null_convert_xp;
     } else			/* unsupported non-null conversion */
       ERREXIT(cinfo, JERR_CONVERSION_NOTIMPL);
     break;
diff --git a/jdct.h b/xjdct.h
similarity index 83%
rename from jdct.h
rename to xjdct.h
index 04192a2..cbc3577 100644
--- a/jdct.h
+++ b/xjdct.h
@@ -1,5 +1,5 @@
 /*
- * jdct.h
+ * xjdct.h
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -26,7 +26,7 @@
  * Quantization of the output coefficients is done by jcdctmgr.c.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 typedef int DCTELEM;		/* 16 or 32 bits is fine */
 #else
 typedef INT32 DCTELEM;		/* must have 32 bits */
@@ -54,7 +54,7 @@ typedef JMETHOD(void, float_DCT_method_ptr, (FAST_FLOAT * data));
  */
 
 typedef MULTIPLIER ISLOW_MULT_TYPE; /* short or int, whichever is faster */
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 typedef MULTIPLIER IFAST_MULT_TYPE; /* 16 bits is OK, use short if faster */
 #define IFAST_SCALE_BITS  2	/* fractional bits in scale factors */
 #else
@@ -73,17 +73,17 @@ typedef FAST_FLOAT FLOAT_MULT_TYPE; /* preferred floating type */
  * prepare_range_limit_table (in jdmaster.c) for more info.
  */
 
-#define IDCT_range_limit(cinfo)  ((cinfo)->sample_range_limit + CENTERJSAMPLE)
+#define IDCT_range_limit(xinfo)  ((xinfo)->sample_range_limit_xp + CENTERJSAMPLE12)
 
-#define RANGE_MASK  (MAXJSAMPLE * 4 + 3) /* 2 bits wider than legal samples */
+#define RANGE_MASK  (MAXJSAMPLE12 * 4 + 3) /* 2 bits wider than legal samples */
 
 
 /* Short forms of external names for systems with brain-damaged linkers. */
 
 #ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jpeg_fdct_islow		jFDislow
-#define jpeg_fdct_ifast		jFDifast
-#define jpeg_fdct_float		jFDfloat
+#define jpeg_fdct_islow_xp		jFDislowXp
+#define jpeg_fdct_ifast_xp		jFDifastXp
+#define jpeg_fdct_float_xp		jFDfloatXp
 #define jpeg_idct_islow		jRDislow
 #define jpeg_idct_ifast		jRDifast
 #define jpeg_idct_float		jRDfloat
@@ -94,28 +94,28 @@ typedef FAST_FLOAT FLOAT_MULT_TYPE; /* preferred floating type */
 
 /* Extern declarations for the forward and inverse DCT routines. */
 
-EXTERN(void) jpeg_fdct_islow JPP((DCTELEM * data));
-EXTERN(void) jpeg_fdct_ifast JPP((DCTELEM * data));
-EXTERN(void) jpeg_fdct_float JPP((FAST_FLOAT * data));
+EXTERN(void) jpeg_fdct_islow_xp JPP((DCTELEM * data));
+EXTERN(void) jpeg_fdct_ifast_xp JPP((DCTELEM * data));
+EXTERN(void) jpeg_fdct_float_xp JPP((FAST_FLOAT * data));
 
-EXTERN(void) jpeg_idct_islow
+EXTERN(void) jpeg_idct_islow_xp
     JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
-EXTERN(void) jpeg_idct_ifast
+	 JCOEFPTR coef_block, JSAMPARRAYXP output_buf, JDIMENSION output_col));
+EXTERN(void) jpeg_idct_ifast_xp
     JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
-EXTERN(void) jpeg_idct_float
+	 JCOEFPTR coef_block, JSAMPARRAYXP output_buf, JDIMENSION output_col));
+EXTERN(void) jpeg_idct_float_xp
     JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
-EXTERN(void) jpeg_idct_4x4
+	 JCOEFPTR coef_block, JSAMPARRAYXP output_buf, JDIMENSION output_col));
+EXTERN(void) jpeg_idct_4x4_xp
     JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
-EXTERN(void) jpeg_idct_2x2
+	 JCOEFPTR coef_block, JSAMPARRAYXP output_buf, JDIMENSION output_col));
+EXTERN(void) jpeg_idct_2x2_xp
     JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
-EXTERN(void) jpeg_idct_1x1
+	 JCOEFPTR coef_block, JSAMPARRAYXP output_buf, JDIMENSION output_col));
+EXTERN(void) jpeg_idct_1x1_xp
     JPP((j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	 JCOEFPTR coef_block, JSAMPARRAY output_buf, JDIMENSION output_col));
+	 JCOEFPTR coef_block, JSAMPARRAYXP output_buf, JDIMENSION output_col));
 
 
 /*
diff --git a/jddctmgr.c b/xjddctmgr.c
similarity index 90%
rename from jddctmgr.c
rename to xjddctmgr.c
index bbf8d0e..f6c683f 100644
--- a/jddctmgr.c
+++ b/xjddctmgr.c
@@ -1,5 +1,5 @@
 /*
- * jddctmgr.c
+ * xjddctmgr.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -17,8 +17,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 
 /*
@@ -41,7 +41,7 @@
 /* Private subobject for this module */
 
 typedef struct {
-  struct jpeg_inverse_dct pub;	/* public fields */
+  struct jpeg_inverse_dct_xp pub;	/* public fields */
 
   /* This array contains the IDCT method code that each multiplier table
    * is currently set up for, or -1 if it's not yet set up.
@@ -86,13 +86,14 @@ typedef union {
  */
 
 METHODDEF(void)
-start_pass (j_decompress_ptr cinfo)
+start_pass_xp (j_decompress_ptr cinfo)
 {
-  my_idct_ptr idct = (my_idct_ptr) cinfo->idct;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_idct_ptr idct = (my_idct_ptr) xinfo->idct_xp;
   int ci, i;
   jpeg_component_info *compptr;
   int method = 0;
-  inverse_DCT_method_ptr method_ptr = NULL;
+  inverse_DCT_method_ptr_xp method_ptr = NULL;
   JQUANT_TBL * qtbl;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
@@ -101,15 +102,15 @@ start_pass (j_decompress_ptr cinfo)
     switch (compptr->DCT_scaled_size) {
 #ifdef IDCT_SCALING_SUPPORTED
     case 1:
-      method_ptr = jpeg_idct_1x1;
+      method_ptr = jpeg_idct_1x1_xp;
       method = JDCT_ISLOW;	/* jidctred uses islow-style table */
       break;
     case 2:
-      method_ptr = jpeg_idct_2x2;
+      method_ptr = jpeg_idct_2x2_xp;
       method = JDCT_ISLOW;	/* jidctred uses islow-style table */
       break;
     case 4:
-      method_ptr = jpeg_idct_4x4;
+      method_ptr = jpeg_idct_4x4_xp;
       method = JDCT_ISLOW;	/* jidctred uses islow-style table */
       break;
 #endif
@@ -117,19 +118,19 @@ start_pass (j_decompress_ptr cinfo)
       switch (cinfo->dct_method) {
 #ifdef DCT_ISLOW_SUPPORTED
       case JDCT_ISLOW:
-	method_ptr = jpeg_idct_islow;
+	method_ptr = jpeg_idct_islow_xp;
 	method = JDCT_ISLOW;
 	break;
 #endif
 #ifdef DCT_IFAST_SUPPORTED
       case JDCT_IFAST:
-	method_ptr = jpeg_idct_ifast;
+	method_ptr = jpeg_idct_ifast_xp;
 	method = JDCT_IFAST;
 	break;
 #endif
 #ifdef DCT_FLOAT_SUPPORTED
       case JDCT_FLOAT:
-	method_ptr = jpeg_idct_float;
+	method_ptr = jpeg_idct_float_xp;
 	method = JDCT_FLOAT;
 	break;
 #endif
@@ -244,8 +245,9 @@ start_pass (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_inverse_dct (j_decompress_ptr cinfo)
+jinit_inverse_dct_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_idct_ptr idct;
   int ci;
   jpeg_component_info *compptr;
@@ -253,8 +255,8 @@ jinit_inverse_dct (j_decompress_ptr cinfo)
   idct = (my_idct_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_idct_controller));
-  cinfo->idct = (struct jpeg_inverse_dct *) idct;
-  idct->pub.start_pass = start_pass;
+  xinfo->idct_xp = (struct jpeg_inverse_dct_xp *) idct;
+  idct->pub.start_pass_xp = start_pass_xp;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
diff --git a/jdhuff.c b/xjdhuff.c
similarity index 87%
rename from jdhuff.c
rename to xjdhuff.c
index b5ba39f..2008bfa 100644
--- a/jdhuff.c
+++ b/xjdhuff.c
@@ -1,11 +1,12 @@
 /*
- * jdhuff.c
+ * xjdhuff.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
  * For conditions of distribution and use, see the accompanying README file.
  *
- * This file contains Huffman entropy decoding routines.
+ * This file contains Huffman entropy decoding routines which are shared
+ * by the sequential, progressive and lossless decoders.
  *
  * Much of the complexity here has to do with supporting input suspension.
  * If the data source module demands suspension, we want to be able to back
@@ -16,8 +17,9 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdhuff.h"		/* Declarations shared with jdphuff.c */
+#include "xjpeglib.h"
+#include "jlossls.h"		/* Private declarations for lossless codec */
+#include "xjdhuff.h"		/* Declarations shared with jdphuff.c */
 
 
 /*
@@ -50,7 +52,7 @@ typedef struct {
 
 
 typedef struct {
-  struct jpeg_entropy_decoder pub; /* public fields */
+  struct jpeg_entropy_decoder_xp pub; /* public fields */
 
   /* These fields are loaded into local variables at start of each MCU.
    * In case of suspension, we exit WITHOUT updating them.
@@ -83,9 +85,10 @@ typedef huff_entropy_decoder * huff_entropy_ptr;
  */
 
 METHODDEF(void)
-start_pass_huff_decoder (j_decompress_ptr cinfo)
+start_pass_huff_decoder_xp (j_decompress_ptr cinfo)
 {
-  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  huff_entropy_ptr entropy = (huff_entropy_ptr) xinfo->entropy_xp;
   int ci, blkn, dctbl, actbl;
   jpeg_component_info * compptr;
 
@@ -103,9 +106,9 @@ start_pass_huff_decoder (j_decompress_ptr cinfo)
     actbl = compptr->ac_tbl_no;
     /* Compute derived values for Huffman tables */
     /* We may do this more than once for a table, but it's not expensive */
-    jpeg_make_d_derived_tbl(cinfo, TRUE, dctbl,
+    jpeg_make_d_derived_tbl_xp(cinfo, TRUE, dctbl,
 			    & entropy->dc_derived_tbls[dctbl]);
-    jpeg_make_d_derived_tbl(cinfo, FALSE, actbl,
+    jpeg_make_d_derived_tbl_xp(cinfo, FALSE, actbl,
 			    & entropy->ac_derived_tbls[actbl]);
     /* Initialize DC predictions to 0 */
     entropy->saved.last_dc_val[ci] = 0;
@@ -146,7 +149,7 @@ start_pass_huff_decoder (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
+jpeg_make_d_derived_tbl_xp (j_decompress_ptr cinfo, boolean isDC, int tblno,
 			 d_derived_tbl ** pdtbl)
 {
   JHUFF_TBL *htbl;
@@ -252,14 +255,14 @@ jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
 
   /* Validate symbols as being reasonable.
    * For AC tables, we make no check, but accept all byte values 0..255.
-   * For DC tables, we require the symbols to be in range 0..15.
+   * For DC tables, we require the symbols to be in range 0..16.
    * (Tighter bounds could be applied depending on the data depth and mode,
    * but this is sufficient to ensure safe decoding.)
    */
   if (isDC) {
     for (i = 0; i < numsymbols; i++) {
       int sym = htbl->huffval[i];
-      if (sym < 0 || sym > 15)
+      if (sym < 0 || sym > 16)
 	ERREXIT(cinfo, JERR_BAD_HUFF_TABLE);
     }
   }
@@ -289,7 +292,7 @@ jpeg_make_d_derived_tbl (j_decompress_ptr cinfo, boolean isDC, int tblno,
 
 
 GLOBAL(boolean)
-jpeg_fill_bit_buffer (bitread_working_state * state,
+jpeg_fill_bit_buffer_xp (bitread_working_state_xp * state,
 		      register bit_buf_type get_buffer, register int bits_left,
 		      int nbits)
 /* Load up the bit buffer to a depth of at least nbits */
@@ -298,6 +301,7 @@ jpeg_fill_bit_buffer (bitread_working_state * state,
   register const JOCTET * next_input_byte = state->next_input_byte;
   register size_t bytes_in_buffer = state->bytes_in_buffer;
   j_decompress_ptr cinfo = state->cinfo;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
 
   /* Attempt to load at least MIN_GET_BITS bits into get_buffer. */
   /* (It is assumed that no request will be for more than that many bits.) */
@@ -309,10 +313,10 @@ jpeg_fill_bit_buffer (bitread_working_state * state,
 
       /* Attempt to read a byte */
       if (bytes_in_buffer == 0) {
-	if (! (*cinfo->src->fill_input_buffer) (cinfo))
+	if (! (*xinfo->src_xp->fill_input_buffer) (cinfo))
 	  return FALSE;
-	next_input_byte = cinfo->src->next_input_byte;
-	bytes_in_buffer = cinfo->src->bytes_in_buffer;
+	next_input_byte = xinfo->src_xp->next_input_byte;
+	bytes_in_buffer = xinfo->src_xp->bytes_in_buffer;
       }
       bytes_in_buffer--;
       c = GETJOCTET(*next_input_byte++);
@@ -326,10 +330,10 @@ jpeg_fill_bit_buffer (bitread_working_state * state,
 	 */
 	do {
 	  if (bytes_in_buffer == 0) {
-	    if (! (*cinfo->src->fill_input_buffer) (cinfo))
+	    if (! (*xinfo->src_xp->fill_input_buffer) (cinfo))
 	      return FALSE;
-	    next_input_byte = cinfo->src->next_input_byte;
-	    bytes_in_buffer = cinfo->src->bytes_in_buffer;
+	    next_input_byte = xinfo->src_xp->next_input_byte;
+	    bytes_in_buffer = xinfo->src_xp->bytes_in_buffer;
 	  }
 	  bytes_in_buffer--;
 	  c = GETJOCTET(*next_input_byte++);
@@ -369,9 +373,17 @@ jpeg_fill_bit_buffer (bitread_working_state * state,
        * We use a nonvolatile flag to ensure that only one warning message
        * appears per data segment.
        */
-      if (! cinfo->entropy->insufficient_data) {
-	WARNMS(cinfo, JWRN_HIT_MARKER);
-	cinfo->entropy->insufficient_data = TRUE;
+      if (xinfo->lossless_xp) {
+        huffd_common_ptr huffd;
+        huffd = (huffd_common_ptr) ((j_lossless_d_ptr_xp) xinfo->codec_xp)->entropy_private;
+        if (! huffd->insufficient_data) {
+          WARNMS(cinfo, JWRN_HIT_MARKER);
+          huffd->insufficient_data = TRUE;
+        }
+      }
+      else if (! xinfo->entropy_xp->insufficient_data) {
+        WARNMS(cinfo, JWRN_HIT_MARKER);
+        xinfo->entropy_xp->insufficient_data = TRUE;
       }
       /* Fill the buffer with zero bits */
       get_buffer <<= MIN_GET_BITS - bits_left;
@@ -395,7 +407,7 @@ jpeg_fill_bit_buffer (bitread_working_state * state,
  */
 
 GLOBAL(int)
-jpeg_huff_decode (bitread_working_state * state,
+jpeg_huff_decode_xp (bitread_working_state_xp * state,
 		  register bit_buf_type get_buffer, register int bits_left,
 		  d_derived_tbl * htbl, int min_bits)
 {
@@ -465,18 +477,19 @@ static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
  */
 
 LOCAL(boolean)
-process_restart (j_decompress_ptr cinfo)
+process_restart_xp (j_decompress_ptr cinfo)
 {
-  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  huff_entropy_ptr entropy = (huff_entropy_ptr) xinfo->entropy_xp;
   int ci;
 
   /* Throw away any unused bits remaining in bit buffer; */
   /* include any full bytes in next_marker's count of discarded bytes */
-  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
+  xinfo->marker_xp->discarded_bytes += entropy->bitstate.bits_left / 8;
   entropy->bitstate.bits_left = 0;
 
   /* Advance past the RSTn marker */
-  if (! (*cinfo->marker->read_restart_marker) (cinfo))
+  if (! (*xinfo->marker_xp->read_restart_marker) (cinfo))
     return FALSE;
 
   /* Re-initialize DC predictions to 0 */
@@ -514,9 +527,10 @@ process_restart (j_decompress_ptr cinfo)
  */
 
 METHODDEF(boolean)
-decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+decode_mcu_xp (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {
-  huff_entropy_ptr entropy = (huff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  huff_entropy_ptr entropy = (huff_entropy_ptr) xinfo->entropy_xp;
   int blkn;
   BITREAD_STATE_VARS;
   savable_state state;
@@ -524,7 +538,7 @@ decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
-      if (! process_restart(cinfo))
+      if (! process_restart_xp(cinfo))
 	return FALSE;
   }
 
@@ -548,7 +562,7 @@ decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
       /* Decode a single block's worth of coefficients */
 
       /* Section F.2.2.1: decode the DC coefficient difference */
-      HUFF_DECODE(s, br_state, dctbl, return FALSE, label1);
+      HUFF_DECODE_XP(s, br_state, dctbl, return FALSE, label1);
       if (s) {
 	CHECK_BIT_BUFFER(br_state, s, return FALSE);
 	r = GET_BITS(s);
@@ -569,7 +583,7 @@ decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 	/* Section F.2.2.2: decode the AC coefficients */
 	/* Since zeroes are skipped, output area must be cleared beforehand */
 	for (k = 1; k < DCTSIZE2; k++) {
-	  HUFF_DECODE(s, br_state, actbl, return FALSE, label2);
+	  HUFF_DECODE_XP(s, br_state, actbl, return FALSE, label2);
       
 	  r = s >> 4;
 	  s &= 15;
@@ -596,7 +610,7 @@ decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 	/* Section F.2.2.2: decode the AC coefficients */
 	/* In this path we just discard the values */
 	for (k = 1; k < DCTSIZE2; k++) {
-	  HUFF_DECODE(s, br_state, actbl, return FALSE, label3);
+	  HUFF_DECODE_XP(s, br_state, actbl, return FALSE, label3);
       
 	  r = s >> 4;
 	  s &= 15;
@@ -632,17 +646,18 @@ decode_mcu (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 GLOBAL(void)
-jinit_huff_decoder (j_decompress_ptr cinfo)
+jinit_huff_decoder_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   huff_entropy_ptr entropy;
   int i;
 
   entropy = (huff_entropy_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(huff_entropy_decoder));
-  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
-  entropy->pub.start_pass = start_pass_huff_decoder;
-  entropy->pub.decode_mcu = decode_mcu;
+  xinfo->entropy_xp = (struct jpeg_entropy_decoder_xp *) entropy;
+  entropy->pub.start_pass_xp = start_pass_huff_decoder_xp;
+  entropy->pub.decode_mcu_xp = decode_mcu_xp;
 
   /* Mark tables unallocated */
   for (i = 0; i < NUM_HUFF_TBLS; i++) {
diff --git a/jdhuff.h b/xjdhuff.h
similarity index 76%
rename from jdhuff.h
rename to xjdhuff.h
index ae19b6c..905f7bf 100644
--- a/jdhuff.h
+++ b/xjdhuff.h
@@ -1,5 +1,5 @@
 /*
- * jdhuff.h
+ * xjdhuff.h
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -13,7 +13,7 @@
 /* Short forms of external names for systems with brain-damaged linkers. */
 
 #ifdef NEED_SHORT_EXTERNAL_NAMES
-#define jpeg_make_d_derived_tbl	jMkDDerived
+#define jpeg_make_d_derived_tbl_xp	jMkDDerivedXp
 #define jpeg_fill_bit_buffer	jFilBitBuf
 #define jpeg_huff_decode	jHufDecode
 #endif /* NEED_SHORT_EXTERNAL_NAMES */
@@ -46,7 +46,7 @@ typedef struct {
 } d_derived_tbl;
 
 /* Expand a Huffman table definition into the derived format */
-EXTERN(void) jpeg_make_d_derived_tbl
+EXTERN(void) jpeg_make_d_derived_tbl_xp
 	JPP((j_decompress_ptr cinfo, boolean isDC, int tblno,
 	     d_derived_tbl ** pdtbl));
 
@@ -96,24 +96,24 @@ typedef struct {		/* Bitreading working state within an MCU */
   int bits_left;		/* # of unused bits in it */
   /* Pointer needed by jpeg_fill_bit_buffer. */
   j_decompress_ptr cinfo;	/* back link to decompress master record */
-} bitread_working_state;
+} bitread_working_state_xp;
 
 /* Macros to declare and load/save bitread local variables. */
 #define BITREAD_STATE_VARS  \
 	register bit_buf_type get_buffer;  \
 	register int bits_left;  \
-	bitread_working_state br_state
+	bitread_working_state_xp br_state
 
 #define BITREAD_LOAD_STATE(cinfop,permstate)  \
 	br_state.cinfo = cinfop; \
-	br_state.next_input_byte = cinfop->src->next_input_byte; \
-	br_state.bytes_in_buffer = cinfop->src->bytes_in_buffer; \
+	br_state.next_input_byte = ((j_decompress_ptr_xp) cinfop->client_data)->src_xp->next_input_byte; \
+	br_state.bytes_in_buffer = ((j_decompress_ptr_xp) cinfop->client_data)->src_xp->bytes_in_buffer; \
 	get_buffer = permstate.get_buffer; \
 	bits_left = permstate.bits_left;
 
 #define BITREAD_SAVE_STATE(cinfop,permstate)  \
-	cinfop->src->next_input_byte = br_state.next_input_byte; \
-	cinfop->src->bytes_in_buffer = br_state.bytes_in_buffer; \
+	((j_decompress_ptr_xp) cinfop->client_data)->src_xp->next_input_byte = br_state.next_input_byte; \
+	((j_decompress_ptr_xp) cinfop->client_data)->src_xp->bytes_in_buffer = br_state.bytes_in_buffer; \
 	permstate.get_buffer = get_buffer; \
 	permstate.bits_left = bits_left
 
@@ -137,7 +137,7 @@ typedef struct {		/* Bitreading working state within an MCU */
 
 #define CHECK_BIT_BUFFER(state,nbits,action) \
 	{ if (bits_left < (nbits)) {  \
-	    if (! jpeg_fill_bit_buffer(&(state),get_buffer,bits_left,nbits))  \
+	    if (! jpeg_fill_bit_buffer_xp(&(state),get_buffer,bits_left,nbits))  \
 	      { action; }  \
 	    get_buffer = (state).get_buffer; bits_left = (state).bits_left; } }
 
@@ -151,8 +151,8 @@ typedef struct {		/* Bitreading working state within an MCU */
 	(bits_left -= (nbits))
 
 /* Load up the bit buffer to a depth of at least nbits */
-EXTERN(boolean) jpeg_fill_bit_buffer
-	JPP((bitread_working_state * state, register bit_buf_type get_buffer,
+EXTERN(boolean) jpeg_fill_bit_buffer_xp
+	JPP((bitread_working_state_xp * state, register bit_buf_type get_buffer,
 	     register int bits_left, int nbits));
 
 
@@ -173,10 +173,10 @@ EXTERN(boolean) jpeg_fill_bit_buffer
  * 3. jpeg_huff_decode returns -1 if forced to suspend.
  */
 
-#define HUFF_DECODE(result,state,htbl,failaction,slowlabel) \
+#define HUFF_DECODE_XP(result,state,htbl,failaction,slowlabel) \
 { register int nb, look; \
   if (bits_left < HUFF_LOOKAHEAD) { \
-    if (! jpeg_fill_bit_buffer(&state,get_buffer,bits_left, 0)) {failaction;} \
+    if (! jpeg_fill_bit_buffer_xp(&state,get_buffer,bits_left, 0)) {failaction;} \
     get_buffer = state.get_buffer; bits_left = state.bits_left; \
     if (bits_left < HUFF_LOOKAHEAD) { \
       nb = 1; goto slowlabel; \
@@ -189,13 +189,40 @@ EXTERN(boolean) jpeg_fill_bit_buffer
   } else { \
     nb = HUFF_LOOKAHEAD+1; \
 slowlabel: \
-    if ((result=jpeg_huff_decode(&state,get_buffer,bits_left,htbl,nb)) < 0) \
+    if ((result=jpeg_huff_decode_xp(&state,get_buffer,bits_left,htbl,nb)) < 0) \
 	{ failaction; } \
     get_buffer = state.get_buffer; bits_left = state.bits_left; \
   } \
 }
 
 /* Out-of-line case for Huffman code fetching */
-EXTERN(int) jpeg_huff_decode
-	JPP((bitread_working_state * state, register bit_buf_type get_buffer,
+EXTERN(int) jpeg_huff_decode_xp
+	JPP((bitread_working_state_xp * state, register bit_buf_type get_buffer,
 	     register int bits_left, d_derived_tbl * htbl, int min_bits));
+
+
+/* Common fields between sequential, progressive and lossless Huffman entropy
+ * decoder master structs.
+ */
+
+#define huffd_common_fields \
+  boolean insufficient_data;	/* set TRUE after emmitting warning */ \
+  /* These fields are loaded into local variables at start of each MCU. \
+   * In case of suspension, we exit WITHOUT updating them. \
+   */ \
+  bitread_perm_state bitstate	/* Bit buffer at start of MCU */
+
+/* Routines that are to be used by any or all of the entropy decoders are
+ * declared to receive a pointer to this structure.  There are no actual
+ * instances of huffd_common_struct, only of shuff_entropy_decoder,
+ * phuff_entropy_decoder and lhuff_entropy_decoder.
+ */
+struct huffd_common_struct {
+  huffd_common_fields;		/* Fields common to all decoder struct types */
+  /* Additional fields follow in an actual shuff_entropy_decoder,
+   * phuff_entropy_decoder or lhuff_entropy_decoder struct.  All four structs
+   * must agree on these initial fields!  (This would be a lot cleaner in C++.)
+   */
+};
+
+typedef struct huffd_common_struct * huffd_common_ptr;
diff --git a/jdinput.c b/xjdinput.c
similarity index 73%
rename from jdinput.c
rename to xjdinput.c
index 0c2ac8f..d286f7b 100644
--- a/jdinput.c
+++ b/xjdinput.c
@@ -1,5 +1,5 @@
 /*
- * jdinput.c
+ * xjdinput.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -7,19 +7,21 @@
  *
  * This file contains input control logic for the JPEG decompressor.
  * These routines are concerned with controlling the decompressor's input
- * processing (marker reading and coefficient decoding).  The actual input
- * reading is done in jdmarker.c, jdhuff.c, and jdphuff.c.
+ * processing (marker reading and coefficient/difference decoding).
+ * The actual input reading is done in jdmarker.c, jdhuff.c, jdphuff.c,
+ * and jdlhuff.c.
  */
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
+#include "xjerror.h"
 
 
 /* Private state */
 
 typedef struct {
-  struct jpeg_input_controller pub; /* public fields */
+  struct jpeg_input_controller_xp pub; /* public fields */
 
   boolean inheaders;		/* TRUE until first SOS is reached */
 } my_input_controller;
@@ -28,7 +30,7 @@ typedef my_input_controller * my_inputctl_ptr;
 
 
 /* Forward declarations */
-METHODDEF(int) consume_markers JPP((j_decompress_ptr cinfo));
+METHODDEF(int) consume_markers_xp JPP((j_decompress_ptr cinfo));
 
 
 /*
@@ -36,9 +38,10 @@ METHODDEF(int) consume_markers JPP((j_decompress_ptr cinfo));
  */
 
 LOCAL(void)
-initial_setup (j_decompress_ptr cinfo)
+initial_setup_xp (j_decompress_ptr cinfo)
 /* Called once, when first SOS marker is reached */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int ci;
   jpeg_component_info *compptr;
 
@@ -47,9 +50,20 @@ initial_setup (j_decompress_ptr cinfo)
       (long) cinfo->image_width > (long) JPEG_MAX_DIMENSION)
     ERREXIT1(cinfo, JERR_IMAGE_TOO_BIG, (unsigned int) JPEG_MAX_DIMENSION);
 
-  /* For now, precision must match compiled-in value... */
-  if (cinfo->data_precision != BITS_IN_JSAMPLE)
-    ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
+  if (xinfo->lossless_xp) {
+    /* If precision > defined value, we must downscale */
+    if (cinfo->data_precision > xinfo->bits_in_JSAMPLEXP)
+      WARNMS2(cinfo, JWRN_MUST_DOWNSCALE,
+	      cinfo->data_precision, xinfo->bits_in_JSAMPLEXP);
+    /* If precision is not between 9 and 16 bits, we don't (yet) support it */
+    if (cinfo->data_precision <= BITS_IN_JSAMPLE || cinfo->data_precision > BITS_IN_JSAMPLE16)
+      ERREXIT1(cinfo, JERR_BAD_LOSSLESS_PRECISION, cinfo->data_precision);
+  }
+  else {  /* Lossy processes */
+    /* For now, precision must match compiled-in value... */
+    if (cinfo->data_precision != BITS_IN_JSAMPLE12)
+      ERREXIT1(cinfo, JERR_BAD_PRECISION, cinfo->data_precision);
+  }
 
   /* Check that number of components won't exceed internal array sizes */
   if (cinfo->num_components > MAX_COMPONENTS)
@@ -70,23 +84,23 @@ initial_setup (j_decompress_ptr cinfo)
 				   compptr->v_samp_factor);
   }
 
-  /* We initialize DCT_scaled_size and min_DCT_scaled_size to DCTSIZE.
+  /* We initialize DCT_scaled_size and min_DCT_scaled_size to data_unit.
    * In the full decompressor, this will be overridden by jdmaster.c;
    * but in the transcoder, jdmaster.c is not used, so we must do it here.
    */
-  cinfo->min_DCT_scaled_size = DCTSIZE;
+  cinfo->min_DCT_scaled_size = xinfo->data_unit_xp;
 
   /* Compute dimensions of components */
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
-    compptr->DCT_scaled_size = DCTSIZE;
-    /* Size in DCT blocks */
+    compptr->DCT_scaled_size = xinfo->data_unit_xp;
+    /* Size in data units */
     compptr->width_in_blocks = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_width * (long) compptr->h_samp_factor,
-		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
+		    (long) (cinfo->max_h_samp_factor * xinfo->data_unit_xp));
     compptr->height_in_blocks = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_height * (long) compptr->v_samp_factor,
-		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
+		    (long) (cinfo->max_v_samp_factor * xinfo->data_unit_xp));
     /* downsampled_width and downsampled_height will also be overridden by
      * jdmaster.c if we are doing full decompression.  The transcoder library
      * doesn't use these values, but the calling application might.
@@ -107,24 +121,25 @@ initial_setup (j_decompress_ptr cinfo)
   /* Compute number of fully interleaved MCU rows. */
   cinfo->total_iMCU_rows = (JDIMENSION)
     jdiv_round_up((long) cinfo->image_height,
-		  (long) (cinfo->max_v_samp_factor*DCTSIZE));
+		  (long) (cinfo->max_v_samp_factor*xinfo->data_unit_xp));
 
   /* Decide whether file contains multiple scans */
   if (cinfo->comps_in_scan < cinfo->num_components || cinfo->progressive_mode)
-    cinfo->inputctl->has_multiple_scans = TRUE;
+    xinfo->inputctl_xp->has_multiple_scans = TRUE;
   else
-    cinfo->inputctl->has_multiple_scans = FALSE;
+    xinfo->inputctl_xp->has_multiple_scans = FALSE;
 }
 
 
 LOCAL(void)
-per_scan_setup (j_decompress_ptr cinfo)
+per_scan_setup_xp (j_decompress_ptr cinfo)
 /* Do computations that are needed before processing a JPEG scan */
 /* cinfo->comps_in_scan and cinfo->cur_comp_info[] were set from SOS marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int ci, mcublks, tmp;
   jpeg_component_info *compptr;
-  
+
   if (cinfo->comps_in_scan == 1) {
     
     /* Noninterleaved (single-component) scan */
@@ -161,10 +176,10 @@ per_scan_setup (j_decompress_ptr cinfo)
     /* Overall image size in MCUs */
     cinfo->MCUs_per_row = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_width,
-		    (long) (cinfo->max_h_samp_factor*DCTSIZE));
+		    (long) (cinfo->max_h_samp_factor*xinfo->data_unit_xp));
     cinfo->MCU_rows_in_scan = (JDIMENSION)
       jdiv_round_up((long) cinfo->image_height,
-		    (long) (cinfo->max_v_samp_factor*DCTSIZE));
+		    (long) (cinfo->max_v_samp_factor*xinfo->data_unit_xp));
     
     cinfo->blocks_in_MCU = 0;
     
@@ -217,7 +232,7 @@ per_scan_setup (j_decompress_ptr cinfo)
  */
 
 LOCAL(void)
-latch_quant_tables (j_decompress_ptr cinfo)
+latch_quant_tables_xp (j_decompress_ptr cinfo)
 {
   int ci, qtblno;
   jpeg_component_info *compptr;
@@ -251,13 +266,22 @@ latch_quant_tables (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_input_pass (j_decompress_ptr cinfo)
+start_input_pass_xp (j_decompress_ptr cinfo)
 {
-  per_scan_setup(cinfo);
-  latch_quant_tables(cinfo);
-  (*cinfo->entropy->start_pass) (cinfo);
-  (*cinfo->coef->start_input_pass) (cinfo);
-  cinfo->inputctl->consume_input = cinfo->coef->consume_data;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  per_scan_setup_xp(cinfo);
+  if (xinfo->lossless_xp)
+  {
+    (*xinfo->codec_xp->start_input_pass) (cinfo);
+    xinfo->inputctl_xp->consume_input_xp = xinfo->codec_xp->consume_data;
+  }
+  else
+  {
+    latch_quant_tables_xp(cinfo);
+    (*xinfo->entropy_xp->start_pass_xp) (cinfo);
+    (*xinfo->coef_xp->start_input_pass_xp) (cinfo);
+    xinfo->inputctl_xp->consume_input_xp = xinfo->coef_xp->consume_data_xp;
+  }
 }
 
 
@@ -268,9 +292,10 @@ start_input_pass (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-finish_input_pass (j_decompress_ptr cinfo)
+finish_input_pass_xp (j_decompress_ptr cinfo)
 {
-  cinfo->inputctl->consume_input = consume_markers;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  xinfo->inputctl_xp->consume_input_xp = consume_markers_xp;
 }
 
 
@@ -285,20 +310,29 @@ finish_input_pass (j_decompress_ptr cinfo)
  */
 
 METHODDEF(int)
-consume_markers (j_decompress_ptr cinfo)
+consume_markers_xp (j_decompress_ptr cinfo)
 {
-  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_inputctl_ptr inputctl = (my_inputctl_ptr) xinfo->inputctl_xp;
   int val;
 
   if (inputctl->pub.eoi_reached) /* After hitting EOI, read no further */
     return JPEG_REACHED_EOI;
 
-  val = (*cinfo->marker->read_markers) (cinfo);
+  val = (*xinfo->marker_xp->read_markers_xp) (cinfo);
 
   switch (val) {
   case JPEG_REACHED_SOS:	/* Found SOS */
     if (inputctl->inheaders) {	/* 1st SOS */
-      initial_setup(cinfo);
+      initial_setup_xp(cinfo);
+      if (xinfo->lossless_xp) {
+        /*
+         * Initialize the decompression codec.  We need to do this here so that
+         * any codec-specific fields and function pointers are available to
+         * the rest of the library.
+         */
+        jinit_d_codec_xp(cinfo);
+      }
       inputctl->inheaders = FALSE;
       /* Note: start_input_pass must be called by jdmaster.c
        * before any more input can be consumed.  jdapimin.c is
@@ -307,13 +341,13 @@ consume_markers (j_decompress_ptr cinfo)
     } else {			/* 2nd or later SOS marker */
       if (! inputctl->pub.has_multiple_scans)
 	ERREXIT(cinfo, JERR_EOI_EXPECTED); /* Oops, I wasn't expecting this! */
-      start_input_pass(cinfo);
+      start_input_pass_xp(cinfo);
     }
     break;
   case JPEG_REACHED_EOI:	/* Found EOI */
     inputctl->pub.eoi_reached = TRUE;
     if (inputctl->inheaders) {	/* Tables-only datastream, apparently */
-      if (cinfo->marker->saw_SOF)
+      if (xinfo->marker_xp->saw_SOF)
 	ERREXIT(cinfo, JERR_SOF_NO_SOS);
     } else {
       /* Prevent infinite loop in coef ctlr's decompress_data routine
@@ -336,17 +370,18 @@ consume_markers (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-reset_input_controller (j_decompress_ptr cinfo)
+reset_input_controller_xp (j_decompress_ptr cinfo)
 {
-  my_inputctl_ptr inputctl = (my_inputctl_ptr) cinfo->inputctl;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_inputctl_ptr inputctl = (my_inputctl_ptr) xinfo->inputctl_xp;
 
-  inputctl->pub.consume_input = consume_markers;
+  inputctl->pub.consume_input_xp = consume_markers_xp;
   inputctl->pub.has_multiple_scans = FALSE; /* "unknown" would be better */
   inputctl->pub.eoi_reached = FALSE;
   inputctl->inheaders = TRUE;
   /* Reset other modules */
   (*cinfo->err->reset_error_mgr) ((j_common_ptr) cinfo);
-  (*cinfo->marker->reset_marker_reader) (cinfo);
+  (*xinfo->marker_xp->reset_marker_reader_xp) (cinfo);
   /* Reset progression state -- would be cleaner if entropy decoder did this */
   cinfo->coef_bits = NULL;
 }
@@ -358,20 +393,21 @@ reset_input_controller (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_input_controller (j_decompress_ptr cinfo)
+jinit_input_controller_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_inputctl_ptr inputctl;
 
   /* Create subobject in permanent pool */
   inputctl = (my_inputctl_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 				SIZEOF(my_input_controller));
-  cinfo->inputctl = (struct jpeg_input_controller *) inputctl;
+  xinfo->inputctl_xp = (struct jpeg_input_controller_xp *) inputctl;
   /* Initialize method pointers */
-  inputctl->pub.consume_input = consume_markers;
-  inputctl->pub.reset_input_controller = reset_input_controller;
-  inputctl->pub.start_input_pass = start_input_pass;
-  inputctl->pub.finish_input_pass = finish_input_pass;
+  inputctl->pub.consume_input_xp = consume_markers_xp;
+  inputctl->pub.reset_input_controller_xp = reset_input_controller_xp;
+  inputctl->pub.start_input_pass_xp = start_input_pass_xp;
+  inputctl->pub.finish_input_pass_xp = finish_input_pass_xp;
   /* Initialize state: can't use reset_input_controller since we don't
    * want to try to reset other modules yet.
    */
diff --git a/jdmainct.c b/xjdmainct.c
similarity index 80%
rename from jdmainct.c
rename to xjdmainct.c
index 13c956f..d9f73af 100644
--- a/jdmainct.c
+++ b/xjdmainct.c
@@ -1,5 +1,5 @@
 /*
- * jdmainct.c
+ * xjdmainct.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -15,7 +15,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /*
@@ -112,10 +112,10 @@
 /* Private buffer controller object */
 
 typedef struct {
-  struct jpeg_d_main_controller pub; /* public fields */
+  struct jpeg_d_main_controller_xp pub; /* public fields */
 
   /* Pointer to allocated workspace (M or M+2 row groups). */
-  JSAMPARRAY buffer[MAX_COMPONENTS];
+  JSAMPARRAYXP buffer[MAX_COMPONENTS];
 
   boolean buffer_full;		/* Have we gotten an iMCU row from decoder? */
   JDIMENSION rowgroup_ctr;	/* counts row groups output to postprocessor */
@@ -123,7 +123,7 @@ typedef struct {
   /* Remaining fields are only used in the context case. */
 
   /* These are the master pointers to the funny-order pointer lists. */
-  JSAMPIMAGE xbuffer[2];	/* pointers to weird pointer lists */
+  JSAMPIMAGEXP xbuffer[2];	/* pointers to weird pointer lists */
 
   int whichptr;			/* indicates which pointer set is now in use */
   int context_state;		/* process_data state machine status */
@@ -140,37 +140,38 @@ typedef my_main_controller * my_main_ptr;
 
 
 /* Forward declarations */
-METHODDEF(void) process_data_simple_main
-	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
+METHODDEF(void) process_data_simple_main_xp
+	JPP((j_decompress_ptr cinfo, JSAMPARRAYXP output_buf,
 	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
-METHODDEF(void) process_data_context_main
-	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
+METHODDEF(void) process_data_context_main_xp
+	JPP((j_decompress_ptr cinfo, JSAMPARRAYXP output_buf,
 	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
 #ifdef QUANT_2PASS_SUPPORTED
-METHODDEF(void) process_data_crank_post
-	JPP((j_decompress_ptr cinfo, JSAMPARRAY output_buf,
+METHODDEF(void) process_data_crank_post_xp
+	JPP((j_decompress_ptr cinfo, JSAMPARRAYXP output_buf,
 	     JDIMENSION *out_row_ctr, JDIMENSION out_rows_avail));
 #endif
 
 
 LOCAL(void)
-alloc_funny_pointers (j_decompress_ptr cinfo)
+alloc_funny_pointers_xp (j_decompress_ptr cinfo)
 /* Allocate space for the funny pointer lists.
  * This is done only once, not once per pass.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
   int ci, rgroup;
   int M = cinfo->min_DCT_scaled_size;
   jpeg_component_info *compptr;
-  JSAMPARRAY xbuf;
+  JSAMPARRAYXP xbuf;
 
   /* Get top-level space for component array pointers.
    * We alloc both arrays with one call to save a few cycles.
    */
-  main->xbuffer[0] = (JSAMPIMAGE)
+  main->xbuffer[0] = (JSAMPIMAGEXP)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				cinfo->num_components * 2 * SIZEOF(JSAMPARRAY));
+				cinfo->num_components * 2 * SIZEOF(JSAMPARRAYXP));
   main->xbuffer[1] = main->xbuffer[0] + cinfo->num_components;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
@@ -180,9 +181,9 @@ alloc_funny_pointers (j_decompress_ptr cinfo)
     /* Get space for pointer lists --- M+4 row groups in each list.
      * We alloc both pointer lists with one call to save a few cycles.
      */
-    xbuf = (JSAMPARRAY)
+    xbuf = (JSAMPARRAYXP)
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROW));
+				  2 * (rgroup * (M + 4)) * SIZEOF(JSAMPROWXP));
     xbuf += rgroup;		/* want one row group at negative offsets */
     main->xbuffer[0][ci] = xbuf;
     xbuf += rgroup * (M + 4);
@@ -192,7 +193,7 @@ alloc_funny_pointers (j_decompress_ptr cinfo)
 
 
 LOCAL(void)
-make_funny_pointers (j_decompress_ptr cinfo)
+make_funny_pointers_xp (j_decompress_ptr cinfo)
 /* Create the funny pointer lists discussed in the comments above.
  * The actual workspace is already allocated (in main->buffer),
  * and the space for the pointer lists is allocated too.
@@ -200,11 +201,12 @@ make_funny_pointers (j_decompress_ptr cinfo)
  * This will be repeated at the beginning of each pass.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
   int ci, i, rgroup;
   int M = cinfo->min_DCT_scaled_size;
   jpeg_component_info *compptr;
-  JSAMPARRAY buf, xbuf0, xbuf1;
+  JSAMPARRAYXP buf, xbuf0, xbuf1;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
@@ -235,16 +237,17 @@ make_funny_pointers (j_decompress_ptr cinfo)
 
 
 LOCAL(void)
-set_wraparound_pointers (j_decompress_ptr cinfo)
+set_wraparound_pointers_xp (j_decompress_ptr cinfo)
 /* Set up the "wraparound" pointers at top and bottom of the pointer lists.
  * This changes the pointer list state from top-of-image to the normal state.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
   int ci, i, rgroup;
   int M = cinfo->min_DCT_scaled_size;
   jpeg_component_info *compptr;
-  JSAMPARRAY xbuf0, xbuf1;
+  JSAMPARRAYXP xbuf0, xbuf1;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
@@ -263,16 +266,17 @@ set_wraparound_pointers (j_decompress_ptr cinfo)
 
 
 LOCAL(void)
-set_bottom_pointers (j_decompress_ptr cinfo)
+set_bottom_pointers_xp (j_decompress_ptr cinfo)
 /* Change the pointer lists to duplicate the last sample row at the bottom
  * of the image.  whichptr indicates which xbuffer holds the final iMCU row.
  * Also sets rowgroups_avail to indicate number of nondummy row groups in row.
  */
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
   int ci, i, rgroup, iMCUheight, rows_left;
   jpeg_component_info *compptr;
-  JSAMPARRAY xbuf;
+  JSAMPARRAYXP xbuf;
 
   for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
        ci++, compptr++) {
@@ -304,21 +308,22 @@ set_bottom_pointers (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
+start_pass_main_xp (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
 
   switch (pass_mode) {
   case JBUF_PASS_THRU:
-    if (cinfo->upsample->need_context_rows) {
-      main->pub.process_data = process_data_context_main;
-      make_funny_pointers(cinfo); /* Create the xbuffer[] lists */
+    if (xinfo->upsample_xp->need_context_rows) {
+      main->pub.process_data_xp = process_data_context_main_xp;
+      make_funny_pointers_xp(cinfo); /* Create the xbuffer[] lists */
       main->whichptr = 0;	/* Read first iMCU row into xbuffer[0] */
       main->context_state = CTX_PREPARE_FOR_IMCU;
       main->iMCU_row_ctr = 0;
     } else {
       /* Simple case with no context needed */
-      main->pub.process_data = process_data_simple_main;
+      main->pub.process_data_xp = process_data_simple_main_xp;
     }
     main->buffer_full = FALSE;	/* Mark buffer empty */
     main->rowgroup_ctr = 0;
@@ -326,7 +331,7 @@ start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
 #ifdef QUANT_2PASS_SUPPORTED
   case JBUF_CRANK_DEST:
     /* For last pass of 2-pass quantization, just crank the postprocessor */
-    main->pub.process_data = process_data_crank_post;
+    main->pub.process_data_xp = process_data_crank_post_xp;
     break;
 #endif
   default:
@@ -342,17 +347,26 @@ start_pass_main (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
  */
 
 METHODDEF(void)
-process_data_simple_main (j_decompress_ptr cinfo,
-			  JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+process_data_simple_main_xp (j_decompress_ptr cinfo,
+			  JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 			  JDIMENSION out_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
   JDIMENSION rowgroups_avail;
 
   /* Read input data if we haven't filled the main buffer yet */
   if (! main->buffer_full) {
-    if (! (*cinfo->coef->decompress_data) (cinfo, main->buffer))
-      return;			/* suspension forced, can do nothing more */
+    if (xinfo->lossless_xp)
+    {
+      if (! (*xinfo->codec_xp->decompress_data) (cinfo, main->buffer))
+        return;			/* suspension forced, can do nothing more */
+    }
+    else
+    {
+      if (! (*xinfo->coef_xp->decompress_data_xp) (cinfo, main->buffer))
+        return;			/* suspension forced, can do nothing more */
+    }
     main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
   }
 
@@ -364,7 +378,7 @@ process_data_simple_main (j_decompress_ptr cinfo,
    */
 
   /* Feed the postprocessor */
-  (*cinfo->post->post_process_data) (cinfo, main->buffer,
+  (*xinfo->post_xp->post_process_data_xp) (cinfo, main->buffer,
 				     &main->rowgroup_ctr, rowgroups_avail,
 				     output_buf, out_row_ctr, out_rows_avail);
 
@@ -382,17 +396,27 @@ process_data_simple_main (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-process_data_context_main (j_decompress_ptr cinfo,
-			   JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+process_data_context_main_xp (j_decompress_ptr cinfo,
+			   JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 			   JDIMENSION out_rows_avail)
 {
-  my_main_ptr main = (my_main_ptr) cinfo->main;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_main_ptr main = (my_main_ptr) xinfo->main_xp;
 
   /* Read input data if we haven't filled the main buffer yet */
   if (! main->buffer_full) {
-    if (! (*cinfo->coef->decompress_data) (cinfo,
-					   main->xbuffer[main->whichptr]))
-      return;			/* suspension forced, can do nothing more */
+    if (xinfo->lossless_xp)
+    {
+      if (! (*xinfo->codec_xp->decompress_data) (cinfo,
+					     main->xbuffer[main->whichptr]))
+        return;			/* suspension forced, can do nothing more */
+    }
+    else
+    {
+      if (! (*xinfo->coef_xp->decompress_data_xp) (cinfo,
+					     main->xbuffer[main->whichptr]))
+        return;			/* suspension forced, can do nothing more */
+    }
     main->buffer_full = TRUE;	/* OK, we have an iMCU row to work with */
     main->iMCU_row_ctr++;	/* count rows received */
   }
@@ -405,7 +429,7 @@ process_data_context_main (j_decompress_ptr cinfo,
   switch (main->context_state) {
   case CTX_POSTPONED_ROW:
     /* Call postprocessor using previously set pointers for postponed row */
-    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
+    (*xinfo->post_xp->post_process_data_xp) (cinfo, main->xbuffer[main->whichptr],
 			&main->rowgroup_ctr, main->rowgroups_avail,
 			output_buf, out_row_ctr, out_rows_avail);
     if (main->rowgroup_ctr < main->rowgroups_avail)
@@ -422,19 +446,19 @@ process_data_context_main (j_decompress_ptr cinfo,
      * the last sample row, and adjust rowgroups_avail to ignore padding rows.
      */
     if (main->iMCU_row_ctr == cinfo->total_iMCU_rows)
-      set_bottom_pointers(cinfo);
+      set_bottom_pointers_xp(cinfo);
     main->context_state = CTX_PROCESS_IMCU;
     /*FALLTHROUGH*/
   case CTX_PROCESS_IMCU:
     /* Call postprocessor using previously set pointers */
-    (*cinfo->post->post_process_data) (cinfo, main->xbuffer[main->whichptr],
+    (*xinfo->post_xp->post_process_data_xp) (cinfo, main->xbuffer[main->whichptr],
 			&main->rowgroup_ctr, main->rowgroups_avail,
 			output_buf, out_row_ctr, out_rows_avail);
     if (main->rowgroup_ctr < main->rowgroups_avail)
       return;			/* Need to suspend */
     /* After the first iMCU, change wraparound pointers to normal state */
     if (main->iMCU_row_ctr == 1)
-      set_wraparound_pointers(cinfo);
+      set_wraparound_pointers_xp(cinfo);
     /* Prepare to load new iMCU row using other xbuffer list */
     main->whichptr ^= 1;	/* 0=>1 or 1=>0 */
     main->buffer_full = FALSE;
@@ -456,11 +480,12 @@ process_data_context_main (j_decompress_ptr cinfo,
 #ifdef QUANT_2PASS_SUPPORTED
 
 METHODDEF(void)
-process_data_crank_post (j_decompress_ptr cinfo,
-			 JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+process_data_crank_post_xp (j_decompress_ptr cinfo,
+			 JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 			 JDIMENSION out_rows_avail)
 {
-  (*cinfo->post->post_process_data) (cinfo, (JSAMPIMAGE) NULL,
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  (*xinfo->post_xp->post_process_data_xp) (cinfo, (JSAMPIMAGEXP) NULL,
 				     (JDIMENSION *) NULL, (JDIMENSION) 0,
 				     output_buf, out_row_ctr, out_rows_avail);
 }
@@ -473,8 +498,9 @@ process_data_crank_post (j_decompress_ptr cinfo,
  */
 
 GLOBAL(void)
-jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
+jinit_d_main_controller_xp (j_decompress_ptr cinfo, boolean need_full_buffer)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_main_ptr main;
   int ci, rgroup, ngroups;
   jpeg_component_info *compptr;
@@ -482,8 +508,8 @@ jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
   main = (my_main_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_main_controller));
-  cinfo->main = (struct jpeg_d_main_controller *) main;
-  main->pub.start_pass = start_pass_main;
+  xinfo->main_xp = (struct jpeg_d_main_controller_xp *) main;
+  main->pub.start_pass_xp = start_pass_main_xp;
 
   if (need_full_buffer)		/* shouldn't happen */
     ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
@@ -491,10 +517,10 @@ jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
   /* Allocate the workspace.
    * ngroups is the number of row groups we need.
    */
-  if (cinfo->upsample->need_context_rows) {
+  if (xinfo->upsample_xp->need_context_rows) {
     if (cinfo->min_DCT_scaled_size < 2) /* unsupported, see comments above */
       ERREXIT(cinfo, JERR_NOTIMPL);
-    alloc_funny_pointers(cinfo); /* Alloc space for xbuffer[] lists */
+    alloc_funny_pointers_xp(cinfo); /* Alloc space for xbuffer[] lists */
     ngroups = cinfo->min_DCT_scaled_size + 2;
   } else {
     ngroups = cinfo->min_DCT_scaled_size;
@@ -504,7 +530,7 @@ jinit_d_main_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
        ci++, compptr++) {
     rgroup = (compptr->v_samp_factor * compptr->DCT_scaled_size) /
       cinfo->min_DCT_scaled_size; /* height of a row group of component */
-    main->buffer[ci] = (*cinfo->mem->alloc_sarray)
+    main->buffer[ci] = (*cinfo->mem->alloc_sarray_xp)
 			((j_common_ptr) cinfo, JPOOL_IMAGE,
 			 compptr->width_in_blocks * compptr->DCT_scaled_size,
 			 (JDIMENSION) (rgroup * ngroups));
diff --git a/jdmarker.c b/xjdmarker.c
similarity index 84%
rename from jdmarker.c
rename to xjdmarker.c
index f4cca8c..1ad9900 100644
--- a/jdmarker.c
+++ b/xjdmarker.c
@@ -1,5 +1,5 @@
 /*
- * jdmarker.c
+ * xjdmarker.c
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -14,7 +14,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 typedef enum {			/* JPEG marker codes */
@@ -88,11 +88,11 @@ typedef enum {			/* JPEG marker codes */
 /* Private state */
 
 typedef struct {
-  struct jpeg_marker_reader pub; /* public fields */
+  struct jpeg_marker_reader_xp pub; /* public fields */
 
   /* Application-overridable marker processing methods */
-  jpeg_marker_parser_method process_COM;
-  jpeg_marker_parser_method process_APPn[16];
+  jpeg_marker_parser_method_xp process_COM;
+  jpeg_marker_parser_method_xp process_APPn[16];
 
   /* Limit on marker data length to save for each marker type */
   unsigned int length_limit_COM;
@@ -116,8 +116,8 @@ typedef my_marker_reader * my_marker_ptr;
  */
 
 /* Declare and initialize local copies of input pointer/count */
-#define INPUT_VARS(cinfo)  \
-	struct jpeg_source_mgr * datasrc = (cinfo)->src;  \
+#define INPUT_VARS(xinfo)  \
+	struct jpeg_source_mgr_xp * datasrc = (xinfo)->src_xp;  \
 	const JOCTET * next_input_byte = datasrc->next_input_byte;  \
 	size_t bytes_in_buffer = datasrc->bytes_in_buffer
 
@@ -194,14 +194,15 @@ typedef my_marker_reader * my_marker_ptr;
 
 
 LOCAL(boolean)
-get_soi (j_decompress_ptr cinfo)
+get_soi_xp (j_decompress_ptr cinfo)
 /* Process an SOI marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int i;
   
   TRACEMS(cinfo, 1, JTRC_SOI);
 
-  if (cinfo->marker->saw_SOI)
+  if (xinfo->marker_xp->saw_SOI)
     ERREXIT(cinfo, JERR_SOI_DUPLICATE);
 
   /* Reset all parameters that are defined to be reset by SOI */
@@ -227,23 +228,34 @@ get_soi (j_decompress_ptr cinfo)
   cinfo->saw_Adobe_marker = FALSE;
   cinfo->Adobe_transform = 0;
 
-  cinfo->marker->saw_SOI = TRUE;
+  xinfo->marker_xp->saw_SOI = TRUE;
 
   return TRUE;
 }
 
 
+/* Known codec processes. */
+typedef enum {
+	JPROC_SEQUENTIAL,	/* baseline/extended sequential DCT */
+	JPROC_PROGRESSIVE,	/* progressive DCT */
+	JPROC_LOSSLESS		/* lossless (sequential) */
+} J_CODEC_PROCESS;
+
 LOCAL(boolean)
-get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
+get_sof_xp (j_decompress_ptr cinfo, J_CODEC_PROCESS process, boolean is_arith,
+	 int data_unit)
 /* Process a SOFn marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 length;
   int c, ci;
   jpeg_component_info * compptr;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
-  cinfo->progressive_mode = is_prog;
+  xinfo->data_unit_xp = data_unit;
+  cinfo->progressive_mode = JPROC_PROGRESSIVE == process;
   cinfo->arith_code = is_arith;
+  xinfo->lossless_xp = JPROC_LOSSLESS == process;
 
   INPUT_2BYTES(cinfo, length, return FALSE);
 
@@ -258,7 +270,7 @@ get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
 	   (int) cinfo->image_width, (int) cinfo->image_height,
 	   cinfo->num_components);
 
-  if (cinfo->marker->saw_SOF)
+  if (xinfo->marker_xp->saw_SOF)
     ERREXIT(cinfo, JERR_SOF_DUPLICATE);
 
   /* We don't support files in which the image height is initially specified */
@@ -290,7 +302,18 @@ get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
 	     compptr->v_samp_factor, compptr->quant_tbl_no);
   }
 
-  cinfo->marker->saw_SOF = TRUE;
+  xinfo->marker_xp->saw_SOF = TRUE;
+
+  xinfo->bits_in_JSAMPLEXP = BITS_IN_JSAMPLE12;
+  xinfo->max_JSAMPLEXP = MAXJSAMPLE12;
+  xinfo->center_JSAMPLEXP = CENTERJSAMPLE12;
+  if (xinfo->lossless_xp && cinfo->data_precision > BITS_IN_JSAMPLE &&
+    cinfo->data_precision <= BITS_IN_JSAMPLE16)
+  {
+    xinfo->bits_in_JSAMPLEXP = cinfo->data_precision;
+    xinfo->max_JSAMPLEXP = (1 << cinfo->data_precision) - 1;
+    xinfo->center_JSAMPLEXP = 1 << (cinfo->data_precision - 1);
+  }
 
   INPUT_SYNC(cinfo);
   return TRUE;
@@ -298,15 +321,16 @@ get_sof (j_decompress_ptr cinfo, boolean is_prog, boolean is_arith)
 
 
 LOCAL(boolean)
-get_sos (j_decompress_ptr cinfo)
+get_sos_xp (j_decompress_ptr cinfo)
 /* Process a SOS marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 length;
   int i, ci, n, c, cc;
   jpeg_component_info * compptr;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
-  if (! cinfo->marker->saw_SOF)
+  if (! xinfo->marker_xp->saw_SOF)
     ERREXIT(cinfo, JERR_SOS_NO_SOF);
 
   INPUT_2BYTES(cinfo, length, return FALSE);
@@ -357,7 +381,7 @@ get_sos (j_decompress_ptr cinfo)
 	   cinfo->Ah, cinfo->Al);
 
   /* Prepare to scan data & restart markers */
-  cinfo->marker->next_restart_num = 0;
+  xinfo->marker_xp->next_restart_num = 0;
 
   /* Count another SOS marker */
   cinfo->input_scan_number++;
@@ -370,12 +394,13 @@ get_sos (j_decompress_ptr cinfo)
 #ifdef D_ARITH_CODING_SUPPORTED
 
 LOCAL(boolean)
-get_dac (j_decompress_ptr cinfo)
+get_dac_xp (j_decompress_ptr cinfo)
 /* Process a DAC marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 length;
   int index, val;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   INPUT_2BYTES(cinfo, length, return FALSE);
   length -= 2;
@@ -410,21 +435,22 @@ get_dac (j_decompress_ptr cinfo)
 
 #else /* ! D_ARITH_CODING_SUPPORTED */
 
-#define get_dac(cinfo)  skip_variable(cinfo)
+#define get_dac_xp(cinfo)  skip_variable_xp(cinfo)
 
 #endif /* D_ARITH_CODING_SUPPORTED */
 
 
 LOCAL(boolean)
-get_dht (j_decompress_ptr cinfo)
+get_dht_xp (j_decompress_ptr cinfo)
 /* Process a DHT marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 length;
   UINT8 bits[17];
   UINT8 huffval[256];
   int i, index, count;
   JHUFF_TBL **htblptr;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   INPUT_2BYTES(cinfo, length, return FALSE);
   length -= 2;
@@ -487,14 +513,15 @@ get_dht (j_decompress_ptr cinfo)
 
 
 LOCAL(boolean)
-get_dqt (j_decompress_ptr cinfo)
+get_dqt_xp (j_decompress_ptr cinfo)
 /* Process a DQT marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 length;
   int n, i, prec;
   unsigned int tmp;
   JQUANT_TBL *quant_ptr;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   INPUT_2BYTES(cinfo, length, return FALSE);
   length -= 2;
@@ -545,12 +572,13 @@ get_dqt (j_decompress_ptr cinfo)
 
 
 LOCAL(boolean)
-get_dri (j_decompress_ptr cinfo)
+get_dri_xp (j_decompress_ptr cinfo)
 /* Process a DRI marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 length;
   unsigned int tmp;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   INPUT_2BYTES(cinfo, length, return FALSE);
   
@@ -581,7 +609,7 @@ get_dri (j_decompress_ptr cinfo)
 
 
 LOCAL(void)
-examine_app0 (j_decompress_ptr cinfo, JOCTET FAR * data,
+examine_app0_xp (j_decompress_ptr cinfo, JOCTET FAR * data,
 	      unsigned int datalen, INT32 remaining)
 /* Examine first few bytes from an APP0.
  * Take appropriate action if it is a JFIF marker.
@@ -657,7 +685,7 @@ examine_app0 (j_decompress_ptr cinfo, JOCTET FAR * data,
 
 
 LOCAL(void)
-examine_app14 (j_decompress_ptr cinfo, JOCTET FAR * data,
+examine_app14_xp (j_decompress_ptr cinfo, JOCTET FAR * data,
 	       unsigned int datalen, INT32 remaining)
 /* Examine first few bytes from an APP14.
  * Take appropriate action if it is an Adobe marker.
@@ -688,13 +716,14 @@ examine_app14 (j_decompress_ptr cinfo, JOCTET FAR * data,
 
 
 METHODDEF(boolean)
-get_interesting_appn (j_decompress_ptr cinfo)
+get_interesting_appn_xp (j_decompress_ptr cinfo)
 /* Process an APP0 or APP14 marker without saving it */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 length;
   JOCTET b[APPN_DATA_LEN];
   unsigned int i, numtoread;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   INPUT_2BYTES(cinfo, length, return FALSE);
   length -= 2;
@@ -713,10 +742,10 @@ get_interesting_appn (j_decompress_ptr cinfo)
   /* process it */
   switch (cinfo->unread_marker) {
   case M_APP0:
-    examine_app0(cinfo, (JOCTET FAR *) b, numtoread, length);
+    examine_app0_xp(cinfo, (JOCTET FAR *) b, numtoread, length);
     break;
   case M_APP14:
-    examine_app14(cinfo, (JOCTET FAR *) b, numtoread, length);
+    examine_app14_xp(cinfo, (JOCTET FAR *) b, numtoread, length);
     break;
   default:
     /* can't get here unless jpeg_save_markers chooses wrong processor */
@@ -727,7 +756,7 @@ get_interesting_appn (j_decompress_ptr cinfo)
   /* skip any remaining data -- could be lots */
   INPUT_SYNC(cinfo);
   if (length > 0)
-    (*cinfo->src->skip_input_data) (cinfo, (long) length);
+    (*xinfo->src_xp->skip_input_data) (cinfo, (long) length);
 
   return TRUE;
 }
@@ -736,15 +765,16 @@ get_interesting_appn (j_decompress_ptr cinfo)
 #ifdef SAVE_MARKERS_SUPPORTED
 
 METHODDEF(boolean)
-save_marker (j_decompress_ptr cinfo)
+save_marker_xp (j_decompress_ptr cinfo)
 /* Save an APPn or COM marker into the marker list */
 {
-  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_marker_ptr marker = (my_marker_ptr) xinfo->marker_xp;
   jpeg_saved_marker_ptr cur_marker = marker->cur_marker;
   unsigned int bytes_read, data_length;
   JOCTET FAR * data;
   INT32 length = 0;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   if (cur_marker == NULL) {
     /* begin reading a marker */
@@ -819,10 +849,10 @@ save_marker (j_decompress_ptr cinfo)
   /* Process the marker if interesting; else just make a generic trace msg */
   switch (cinfo->unread_marker) {
   case M_APP0:
-    examine_app0(cinfo, data, data_length, length);
+    examine_app0_xp(cinfo, data, data_length, length);
     break;
   case M_APP14:
-    examine_app14(cinfo, data, data_length, length);
+    examine_app14_xp(cinfo, data, data_length, length);
     break;
   default:
     TRACEMS2(cinfo, 1, JTRC_MISC_MARKER, cinfo->unread_marker,
@@ -833,7 +863,7 @@ save_marker (j_decompress_ptr cinfo)
   /* skip any remaining data -- could be lots */
   INPUT_SYNC(cinfo);		/* do before skip_input_data */
   if (length > 0)
-    (*cinfo->src->skip_input_data) (cinfo, (long) length);
+    (*xinfo->src_xp->skip_input_data) (cinfo, (long) length);
 
   return TRUE;
 }
@@ -842,11 +872,12 @@ save_marker (j_decompress_ptr cinfo)
 
 
 METHODDEF(boolean)
-skip_variable (j_decompress_ptr cinfo)
+skip_variable_xp (j_decompress_ptr cinfo)
 /* Skip over an unknown or uninteresting variable-length marker */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 length;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   INPUT_2BYTES(cinfo, length, return FALSE);
   length -= 2;
@@ -855,7 +886,7 @@ skip_variable (j_decompress_ptr cinfo)
 
   INPUT_SYNC(cinfo);		/* do before skip_input_data */
   if (length > 0)
-    (*cinfo->src->skip_input_data) (cinfo, (long) length);
+    (*xinfo->src_xp->skip_input_data) (cinfo, (long) length);
 
   return TRUE;
 }
@@ -871,10 +902,11 @@ skip_variable (j_decompress_ptr cinfo)
  */
 
 LOCAL(boolean)
-next_marker (j_decompress_ptr cinfo)
+next_marker_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int c;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   for (;;) {
     INPUT_BYTE(cinfo, c, return FALSE);
@@ -884,7 +916,7 @@ next_marker (j_decompress_ptr cinfo)
      * can discard the byte from its buffer.
      */
     while (c != 0xFF) {
-      cinfo->marker->discarded_bytes++;
+      xinfo->marker_xp->discarded_bytes++;
       INPUT_SYNC(cinfo);
       INPUT_BYTE(cinfo, c, return FALSE);
     }
@@ -901,13 +933,13 @@ next_marker (j_decompress_ptr cinfo)
     /* Reach here if we found a stuffed-zero data sequence (FF/00).
      * Discard it and loop back to try again.
      */
-    cinfo->marker->discarded_bytes += 2;
+    xinfo->marker_xp->discarded_bytes += 2;
     INPUT_SYNC(cinfo);
   }
 
-  if (cinfo->marker->discarded_bytes != 0) {
-    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, cinfo->marker->discarded_bytes, c);
-    cinfo->marker->discarded_bytes = 0;
+  if (xinfo->marker_xp->discarded_bytes != 0) {
+    WARNMS2(cinfo, JWRN_EXTRANEOUS_DATA, xinfo->marker_xp->discarded_bytes, c);
+    xinfo->marker_xp->discarded_bytes = 0;
   }
 
   cinfo->unread_marker = c;
@@ -918,7 +950,7 @@ next_marker (j_decompress_ptr cinfo)
 
 
 LOCAL(boolean)
-first_marker (j_decompress_ptr cinfo)
+first_marker_xp (j_decompress_ptr cinfo)
 /* Like next_marker, but used to obtain the initial SOI marker. */
 /* For this marker, we do not allow preceding garbage or fill; otherwise,
  * we might well scan an entire input file before realizing it ain't JPEG.
@@ -926,8 +958,9 @@ first_marker (j_decompress_ptr cinfo)
  * SOI before calling the JPEG library.
  */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int c, c2;
-  INPUT_VARS(cinfo);
+  INPUT_VARS(xinfo);
 
   INPUT_BYTE(cinfo, c, return FALSE);
   INPUT_BYTE(cinfo, c2, return FALSE);
@@ -949,18 +982,19 @@ first_marker (j_decompress_ptr cinfo)
  */
 
 METHODDEF(int)
-read_markers (j_decompress_ptr cinfo)
+read_markers_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   /* Outer loop repeats once for each marker. */
   for (;;) {
     /* Collect the marker proper, unless we already did. */
     /* NB: first_marker() enforces the requirement that SOI appear first. */
     if (cinfo->unread_marker == 0) {
-      if (! cinfo->marker->saw_SOI) {
-	if (! first_marker(cinfo))
+      if (! xinfo->marker_xp->saw_SOI) {
+	if (! first_marker_xp(cinfo))
 	  return JPEG_SUSPENDED;
       } else {
-	if (! next_marker(cinfo))
+	if (! next_marker_xp(cinfo))
 	  return JPEG_SUSPENDED;
       }
     }
@@ -970,38 +1004,46 @@ read_markers (j_decompress_ptr cinfo)
      */
     switch (cinfo->unread_marker) {
     case M_SOI:
-      if (! get_soi(cinfo))
+      if (! get_soi_xp(cinfo))
 	return JPEG_SUSPENDED;
       break;
 
     case M_SOF0:		/* Baseline */
     case M_SOF1:		/* Extended sequential, Huffman */
-      if (! get_sof(cinfo, FALSE, FALSE))
+      if (! get_sof_xp(cinfo, JPROC_SEQUENTIAL, FALSE, DCTSIZE))
 	return JPEG_SUSPENDED;
       break;
 
     case M_SOF2:		/* Progressive, Huffman */
-      if (! get_sof(cinfo, TRUE, FALSE))
+      if (! get_sof_xp(cinfo, JPROC_PROGRESSIVE, FALSE, DCTSIZE))
+	return JPEG_SUSPENDED;
+      break;
+
+    case M_SOF3:		/* Lossless, Huffman */
+      if (! get_sof_xp(cinfo, JPROC_LOSSLESS, FALSE, 1))
 	return JPEG_SUSPENDED;
       break;
 
     case M_SOF9:		/* Extended sequential, arithmetic */
-      if (! get_sof(cinfo, FALSE, TRUE))
+      if (! get_sof_xp(cinfo, JPROC_SEQUENTIAL, TRUE, DCTSIZE))
 	return JPEG_SUSPENDED;
       break;
 
     case M_SOF10:		/* Progressive, arithmetic */
-      if (! get_sof(cinfo, TRUE, TRUE))
+      if (! get_sof_xp(cinfo, JPROC_PROGRESSIVE, TRUE, DCTSIZE))
+	return JPEG_SUSPENDED;
+      break;
+
+    case M_SOF11:		/* Lossless, arithmetic */
+      if (! get_sof_xp(cinfo, JPROC_LOSSLESS, TRUE, 1))
 	return JPEG_SUSPENDED;
       break;
 
     /* Currently unsupported SOFn types */
-    case M_SOF3:		/* Lossless, Huffman */
     case M_SOF5:		/* Differential sequential, Huffman */
     case M_SOF6:		/* Differential progressive, Huffman */
     case M_SOF7:		/* Differential lossless, Huffman */
     case M_JPG:			/* Reserved for JPEG extensions */
-    case M_SOF11:		/* Lossless, arithmetic */
     case M_SOF13:		/* Differential sequential, arithmetic */
     case M_SOF14:		/* Differential progressive, arithmetic */
     case M_SOF15:		/* Differential lossless, arithmetic */
@@ -1009,7 +1051,7 @@ read_markers (j_decompress_ptr cinfo)
       break;
 
     case M_SOS:
-      if (! get_sos(cinfo))
+      if (! get_sos_xp(cinfo))
 	return JPEG_SUSPENDED;
       cinfo->unread_marker = 0;	/* processed the marker */
       return JPEG_REACHED_SOS;
@@ -1020,22 +1062,22 @@ read_markers (j_decompress_ptr cinfo)
       return JPEG_REACHED_EOI;
       
     case M_DAC:
-      if (! get_dac(cinfo))
+      if (! get_dac_xp(cinfo))
 	return JPEG_SUSPENDED;
       break;
       
     case M_DHT:
-      if (! get_dht(cinfo))
+      if (! get_dht_xp(cinfo))
 	return JPEG_SUSPENDED;
       break;
       
     case M_DQT:
-      if (! get_dqt(cinfo))
+      if (! get_dqt_xp(cinfo))
 	return JPEG_SUSPENDED;
       break;
       
     case M_DRI:
-      if (! get_dri(cinfo))
+      if (! get_dri_xp(cinfo))
 	return JPEG_SUSPENDED;
       break;
       
@@ -1055,13 +1097,13 @@ read_markers (j_decompress_ptr cinfo)
     case M_APP13:
     case M_APP14:
     case M_APP15:
-      if (! (*((my_marker_ptr) cinfo->marker)->process_APPn[
+      if (! (*((my_marker_ptr) xinfo->marker_xp)->process_APPn[
 		cinfo->unread_marker - (int) M_APP0]) (cinfo))
 	return JPEG_SUSPENDED;
       break;
       
     case M_COM:
-      if (! (*((my_marker_ptr) cinfo->marker)->process_COM) (cinfo))
+      if (! (*((my_marker_ptr) xinfo->marker_xp)->process_COM) (cinfo))
 	return JPEG_SUSPENDED;
       break;
 
@@ -1078,7 +1120,7 @@ read_markers (j_decompress_ptr cinfo)
       break;
 
     case M_DNL:			/* Ignore DNL ... perhaps the wrong thing */
-      if (! skip_variable(cinfo))
+      if (! skip_variable_xp(cinfo))
 	return JPEG_SUSPENDED;
       break;
 
@@ -1110,30 +1152,31 @@ read_markers (j_decompress_ptr cinfo)
  */
 
 METHODDEF(boolean)
-read_restart_marker (j_decompress_ptr cinfo)
+read_restart_marker_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   /* Obtain a marker unless we already did. */
   /* Note that next_marker will complain if it skips any data. */
   if (cinfo->unread_marker == 0) {
-    if (! next_marker(cinfo))
+    if (! next_marker_xp(cinfo))
       return FALSE;
   }
 
   if (cinfo->unread_marker ==
-      ((int) M_RST0 + cinfo->marker->next_restart_num)) {
+      ((int) M_RST0 + xinfo->marker_xp->next_restart_num)) {
     /* Normal case --- swallow the marker and let entropy decoder continue */
-    TRACEMS1(cinfo, 3, JTRC_RST, cinfo->marker->next_restart_num);
+    TRACEMS1(cinfo, 3, JTRC_RST, xinfo->marker_xp->next_restart_num);
     cinfo->unread_marker = 0;
   } else {
     /* Uh-oh, the restart markers have been messed up. */
     /* Let the data source manager determine how to resync. */
-    if (! (*cinfo->src->resync_to_restart) (cinfo,
-					    cinfo->marker->next_restart_num))
+    if (! (*xinfo->src_xp->resync_to_restart_xp) (cinfo,
+					    xinfo->marker_xp->next_restart_num))
       return FALSE;
   }
 
   /* Update next-restart state */
-  cinfo->marker->next_restart_num = (cinfo->marker->next_restart_num + 1) & 7;
+  xinfo->marker_xp->next_restart_num = (xinfo->marker_xp->next_restart_num + 1) & 7;
 
   return TRUE;
 }
@@ -1189,7 +1232,7 @@ read_restart_marker (j_decompress_ptr cinfo)
  */
 
 GLOBAL(boolean)
-jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
+jpeg_resync_to_restart_xp (j_decompress_ptr cinfo, int desired)
 {
   int marker = cinfo->unread_marker;
   int action = 1;
@@ -1221,7 +1264,7 @@ jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
       return TRUE;
     case 2:
       /* Scan to the next marker, and repeat the decision loop. */
-      if (! next_marker(cinfo))
+      if (! next_marker_xp(cinfo))
 	return FALSE;
       marker = cinfo->unread_marker;
       break;
@@ -1239,9 +1282,10 @@ jpeg_resync_to_restart (j_decompress_ptr cinfo, int desired)
  */
 
 METHODDEF(void)
-reset_marker_reader (j_decompress_ptr cinfo)
+reset_marker_reader_xp (j_decompress_ptr cinfo)
 {
-  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_marker_ptr marker = (my_marker_ptr) xinfo->marker_xp;
 
   cinfo->comp_info = NULL;		/* until allocated by get_sof */
   cinfo->input_scan_number = 0;		/* no SOS seen yet */
@@ -1259,8 +1303,9 @@ reset_marker_reader (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_marker_reader (j_decompress_ptr cinfo)
+jinit_marker_reader_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_marker_ptr marker;
   int i;
 
@@ -1268,25 +1313,25 @@ jinit_marker_reader (j_decompress_ptr cinfo)
   marker = (my_marker_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_PERMANENT,
 				SIZEOF(my_marker_reader));
-  cinfo->marker = (struct jpeg_marker_reader *) marker;
+  xinfo->marker_xp = (struct jpeg_marker_reader_xp *) marker;
   /* Initialize public method pointers */
-  marker->pub.reset_marker_reader = reset_marker_reader;
-  marker->pub.read_markers = read_markers;
-  marker->pub.read_restart_marker = read_restart_marker;
+  marker->pub.reset_marker_reader_xp = reset_marker_reader_xp;
+  marker->pub.read_markers_xp = read_markers_xp;
+  marker->pub.read_restart_marker = read_restart_marker_xp;
   /* Initialize COM/APPn processing.
    * By default, we examine and then discard APP0 and APP14,
    * but simply discard COM and all other APPn.
    */
-  marker->process_COM = skip_variable;
+  marker->process_COM = skip_variable_xp;
   marker->length_limit_COM = 0;
   for (i = 0; i < 16; i++) {
-    marker->process_APPn[i] = skip_variable;
+    marker->process_APPn[i] = skip_variable_xp;
     marker->length_limit_APPn[i] = 0;
   }
-  marker->process_APPn[0] = get_interesting_appn;
-  marker->process_APPn[14] = get_interesting_appn;
+  marker->process_APPn[0] = get_interesting_appn_xp;
+  marker->process_APPn[14] = get_interesting_appn_xp;
   /* Reset marker processing state */
-  reset_marker_reader(cinfo);
+  reset_marker_reader_xp(cinfo);
 }
 
 
@@ -1297,12 +1342,13 @@ jinit_marker_reader (j_decompress_ptr cinfo)
 #ifdef SAVE_MARKERS_SUPPORTED
 
 GLOBAL(void)
-jpeg_save_markers (j_decompress_ptr cinfo, int marker_code,
+jpeg_save_markers_xp (j_decompress_ptr cinfo, int marker_code,
 		   unsigned int length_limit)
 {
-  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_marker_ptr marker = (my_marker_ptr) xinfo->marker_xp;
   long maxlength;
-  jpeg_marker_parser_method processor;
+  jpeg_marker_parser_method_xp processor;
 
   /* Length limit mustn't be larger than what we can allocate
    * (should only be a concern in a 16-bit environment).
@@ -1315,17 +1361,17 @@ jpeg_save_markers (j_decompress_ptr cinfo, int marker_code,
    * APP0/APP14 have special requirements.
    */
   if (length_limit) {
-    processor = save_marker;
+    processor = save_marker_xp;
     /* If saving APP0/APP14, save at least enough for our internal use. */
     if (marker_code == (int) M_APP0 && length_limit < APP0_DATA_LEN)
       length_limit = APP0_DATA_LEN;
     else if (marker_code == (int) M_APP14 && length_limit < APP14_DATA_LEN)
       length_limit = APP14_DATA_LEN;
   } else {
-    processor = skip_variable;
+    processor = skip_variable_xp;
     /* If discarding APP0/APP14, use our regular on-the-fly processor. */
     if (marker_code == (int) M_APP0 || marker_code == (int) M_APP14)
-      processor = get_interesting_appn;
+      processor = get_interesting_appn_xp;
   }
 
   if (marker_code == (int) M_COM) {
@@ -1346,10 +1392,11 @@ jpeg_save_markers (j_decompress_ptr cinfo, int marker_code,
  */
 
 GLOBAL(void)
-jpeg_set_marker_processor (j_decompress_ptr cinfo, int marker_code,
-			   jpeg_marker_parser_method routine)
+jpeg_set_marker_processor_xp (j_decompress_ptr cinfo, int marker_code,
+                                 jpeg_marker_parser_method_xp routine)
 {
-  my_marker_ptr marker = (my_marker_ptr) cinfo->marker;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_marker_ptr marker = (my_marker_ptr) xinfo->marker_xp;
 
   if (marker_code == (int) M_COM)
     marker->process_COM = routine;
diff --git a/jdmaster.c b/xjdmaster.c
similarity index 63%
rename from jdmaster.c
rename to xjdmaster.c
index 2802c5b..bc5e095 100644
--- a/jdmaster.c
+++ b/xjdmaster.c
@@ -1,5 +1,5 @@
 /*
- * jdmaster.c
+ * xjdmaster.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -13,13 +13,13 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Private state */
 
 typedef struct {
-  struct jpeg_decomp_master pub; /* public fields */
+  struct jpeg_decomp_master_xp pub; /* public fields */
 
   int pass_number;		/* # of passes completed */
 
@@ -28,8 +28,8 @@ typedef struct {
   /* Saved references to initialized quantizer modules,
    * in case we need to switch modes.
    */
-  struct jpeg_color_quantizer * quantizer_1pass;
-  struct jpeg_color_quantizer * quantizer_2pass;
+  struct jpeg_color_quantizer_xp * quantizer_1pass;
+  struct jpeg_color_quantizer_xp * quantizer_2pass;
 } my_decomp_master;
 
 typedef my_decomp_master * my_master_ptr;
@@ -41,7 +41,7 @@ typedef my_decomp_master * my_master_ptr;
  */
 
 LOCAL(boolean)
-use_merged_upsample (j_decompress_ptr cinfo)
+use_merged_upsample_xp (j_decompress_ptr cinfo)
 {
 #ifdef UPSAMPLE_MERGING_SUPPORTED
   /* Merging is the equivalent of plain box-filter upsampling */
@@ -81,9 +81,10 @@ use_merged_upsample (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
+jpeg_calc_output_dimensions_xp (j_decompress_ptr cinfo)
 /* Do computations that are needed before master selection phase */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
 #ifdef IDCT_SCALING_SUPPORTED
   int ci;
   jpeg_component_info *compptr;
@@ -93,80 +94,87 @@ jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
   if (cinfo->global_state != DSTATE_READY)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
+  if (xinfo->lossless_xp)
+  {
+    (*xinfo->codec_xp->calc_output_dimensions) (cinfo);
+  }
+  else
+  {
 #ifdef IDCT_SCALING_SUPPORTED
 
-  /* Compute actual output image dimensions and DCT scaling choices. */
-  if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
-    /* Provide 1/8 scaling */
-    cinfo->output_width = (JDIMENSION)
-      jdiv_round_up((long) cinfo->image_width, 8L);
-    cinfo->output_height = (JDIMENSION)
-      jdiv_round_up((long) cinfo->image_height, 8L);
-    cinfo->min_DCT_scaled_size = 1;
-  } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
-    /* Provide 1/4 scaling */
-    cinfo->output_width = (JDIMENSION)
-      jdiv_round_up((long) cinfo->image_width, 4L);
-    cinfo->output_height = (JDIMENSION)
-      jdiv_round_up((long) cinfo->image_height, 4L);
-    cinfo->min_DCT_scaled_size = 2;
-  } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
-    /* Provide 1/2 scaling */
-    cinfo->output_width = (JDIMENSION)
-      jdiv_round_up((long) cinfo->image_width, 2L);
-    cinfo->output_height = (JDIMENSION)
-      jdiv_round_up((long) cinfo->image_height, 2L);
-    cinfo->min_DCT_scaled_size = 4;
-  } else {
-    /* Provide 1/1 scaling */
-    cinfo->output_width = cinfo->image_width;
-    cinfo->output_height = cinfo->image_height;
-    cinfo->min_DCT_scaled_size = DCTSIZE;
-  }
-  /* In selecting the actual DCT scaling for each component, we try to
-   * scale up the chroma components via IDCT scaling rather than upsampling.
-   * This saves time if the upsampler gets to use 1:1 scaling.
-   * Note this code assumes that the supported DCT scalings are powers of 2.
-   */
-  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
-       ci++, compptr++) {
-    int ssize = cinfo->min_DCT_scaled_size;
-    while (ssize < DCTSIZE &&
-	   (compptr->h_samp_factor * ssize * 2 <=
-	    cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
-	   (compptr->v_samp_factor * ssize * 2 <=
-	    cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
-      ssize = ssize * 2;
+    /* Compute actual output image dimensions and DCT scaling choices. */
+    if (cinfo->scale_num * 8 <= cinfo->scale_denom) {
+      /* Provide 1/8 scaling */
+      cinfo->output_width = (JDIMENSION)
+        jdiv_round_up((long) cinfo->image_width, 8L);
+      cinfo->output_height = (JDIMENSION)
+        jdiv_round_up((long) cinfo->image_height, 8L);
+      cinfo->min_DCT_scaled_size = 1;
+    } else if (cinfo->scale_num * 4 <= cinfo->scale_denom) {
+      /* Provide 1/4 scaling */
+      cinfo->output_width = (JDIMENSION)
+        jdiv_round_up((long) cinfo->image_width, 4L);
+      cinfo->output_height = (JDIMENSION)
+        jdiv_round_up((long) cinfo->image_height, 4L);
+      cinfo->min_DCT_scaled_size = 2;
+    } else if (cinfo->scale_num * 2 <= cinfo->scale_denom) {
+      /* Provide 1/2 scaling */
+      cinfo->output_width = (JDIMENSION)
+        jdiv_round_up((long) cinfo->image_width, 2L);
+      cinfo->output_height = (JDIMENSION)
+        jdiv_round_up((long) cinfo->image_height, 2L);
+      cinfo->min_DCT_scaled_size = 4;
+    } else {
+      /* Provide 1/1 scaling */
+      cinfo->output_width = cinfo->image_width;
+      cinfo->output_height = cinfo->image_height;
+      cinfo->min_DCT_scaled_size = DCTSIZE;
+    }
+    /* In selecting the actual DCT scaling for each component, we try to
+     * scale up the chroma components via IDCT scaling rather than upsampling.
+     * This saves time if the upsampler gets to use 1:1 scaling.
+     * Note this code assumes that the supported DCT scalings are powers of 2.
+     */
+    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+         ci++, compptr++) {
+      int ssize = cinfo->min_DCT_scaled_size;
+      while (ssize < DCTSIZE &&
+	     (compptr->h_samp_factor * ssize * 2 <=
+	      cinfo->max_h_samp_factor * cinfo->min_DCT_scaled_size) &&
+	     (compptr->v_samp_factor * ssize * 2 <=
+	      cinfo->max_v_samp_factor * cinfo->min_DCT_scaled_size)) {
+        ssize = ssize * 2;
+      }
+      compptr->DCT_scaled_size = ssize;
     }
-    compptr->DCT_scaled_size = ssize;
-  }
 
-  /* Recompute downsampled dimensions of components;
-   * application needs to know these if using raw downsampled data.
-   */
-  for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
-       ci++, compptr++) {
-    /* Size in samples, after IDCT scaling */
-    compptr->downsampled_width = (JDIMENSION)
-      jdiv_round_up((long) cinfo->image_width *
-		    (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
-		    (long) (cinfo->max_h_samp_factor * DCTSIZE));
-    compptr->downsampled_height = (JDIMENSION)
-      jdiv_round_up((long) cinfo->image_height *
-		    (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
-		    (long) (cinfo->max_v_samp_factor * DCTSIZE));
-  }
+    /* Recompute downsampled dimensions of components;
+     * application needs to know these if using raw downsampled data.
+     */
+    for (ci = 0, compptr = cinfo->comp_info; ci < cinfo->num_components;
+         ci++, compptr++) {
+      /* Size in samples, after IDCT scaling */
+      compptr->downsampled_width = (JDIMENSION)
+        jdiv_round_up((long) cinfo->image_width *
+		      (long) (compptr->h_samp_factor * compptr->DCT_scaled_size),
+		      (long) (cinfo->max_h_samp_factor * DCTSIZE));
+      compptr->downsampled_height = (JDIMENSION)
+        jdiv_round_up((long) cinfo->image_height *
+		      (long) (compptr->v_samp_factor * compptr->DCT_scaled_size),
+		      (long) (cinfo->max_v_samp_factor * DCTSIZE));
+    }
 
 #else /* !IDCT_SCALING_SUPPORTED */
 
-  /* Hardwire it to "no scaling" */
-  cinfo->output_width = cinfo->image_width;
-  cinfo->output_height = cinfo->image_height;
-  /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
-   * and has computed unscaled downsampled_width and downsampled_height.
-   */
+    /* Hardwire it to "no scaling" */
+    cinfo->output_width = cinfo->image_width;
+    cinfo->output_height = cinfo->image_height;
+    /* jdinput.c has already initialized DCT_scaled_size to DCTSIZE,
+     * and has computed unscaled downsampled_width and downsampled_height.
+     */
 
 #endif /* IDCT_SCALING_SUPPORTED */
+  }
 
   /* Report number of components in selected colorspace. */
   /* Probably this should be in the color conversion module... */
@@ -194,7 +202,7 @@ jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
 			      cinfo->out_color_components);
 
   /* See if upsampler will want to emit more than one row at a time */
-  if (use_merged_upsample(cinfo))
+  if (use_merged_upsample_xp(cinfo))
     cinfo->rec_outbuf_height = cinfo->max_v_samp_factor;
   else
     cinfo->rec_outbuf_height = 1;
@@ -245,31 +253,34 @@ jpeg_calc_output_dimensions (j_decompress_ptr cinfo)
  */
 
 LOCAL(void)
-prepare_range_limit_table (j_decompress_ptr cinfo)
+prepare_range_limit_table_xp (j_decompress_ptr cinfo)
 /* Allocate and fill in the sample_range_limit table */
 {
-  JSAMPLE * table;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  const JSAMPLEXP MAXJSAMPLEXP = xinfo->max_JSAMPLEXP;
+  const JSAMPLEXP CENTERJSAMPLEXP = xinfo->center_JSAMPLEXP;
+  JSAMPLEXP * table;
   int i;
 
-  table = (JSAMPLE *)
+  table = (JSAMPLEXP *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-		(5 * (MAXJSAMPLE+1) + CENTERJSAMPLE) * SIZEOF(JSAMPLE));
-  table += (MAXJSAMPLE+1);	/* allow negative subscripts of simple table */
-  cinfo->sample_range_limit = table;
+		(5 * (MAXJSAMPLEXP+1) + CENTERJSAMPLEXP) * SIZEOF(JSAMPLEXP));
+  table += (MAXJSAMPLEXP+1);	/* allow negative subscripts of simple table */
+  xinfo->sample_range_limit_xp = table;
   /* First segment of "simple" table: limit[x] = 0 for x < 0 */
-  MEMZERO(table - (MAXJSAMPLE+1), (MAXJSAMPLE+1) * SIZEOF(JSAMPLE));
+  MEMZERO(table - (MAXJSAMPLEXP+1), (MAXJSAMPLEXP+1) * SIZEOF(JSAMPLEXP));
   /* Main part of "simple" table: limit[x] = x */
-  for (i = 0; i <= MAXJSAMPLE; i++)
-    table[i] = (JSAMPLE) i;
-  table += CENTERJSAMPLE;	/* Point to where post-IDCT table starts */
+  for (i = 0; i <= MAXJSAMPLEXP; i++)
+    table[i] = (JSAMPLEXP) i;
+  table += CENTERJSAMPLEXP;	/* Point to where post-IDCT table starts */
   /* End of simple table, rest of first half of post-IDCT table */
-  for (i = CENTERJSAMPLE; i < 2*(MAXJSAMPLE+1); i++)
-    table[i] = MAXJSAMPLE;
+  for (i = CENTERJSAMPLEXP; i < 2*(MAXJSAMPLEXP+1); i++)
+    table[i] = MAXJSAMPLEXP;
   /* Second half of post-IDCT table */
-  MEMZERO(table + (2 * (MAXJSAMPLE+1)),
-	  (2 * (MAXJSAMPLE+1) - CENTERJSAMPLE) * SIZEOF(JSAMPLE));
-  MEMCOPY(table + (4 * (MAXJSAMPLE+1) - CENTERJSAMPLE),
-	  cinfo->sample_range_limit, CENTERJSAMPLE * SIZEOF(JSAMPLE));
+  MEMZERO(table + (2 * (MAXJSAMPLEXP+1)),
+	  (2 * (MAXJSAMPLEXP+1) - CENTERJSAMPLEXP) * SIZEOF(JSAMPLEXP));
+  MEMCOPY(table + (4 * (MAXJSAMPLEXP+1) - CENTERJSAMPLEXP),
+	  xinfo->sample_range_limit_xp, CENTERJSAMPLEXP * SIZEOF(JSAMPLEXP));
 }
 
 
@@ -285,16 +296,17 @@ prepare_range_limit_table (j_decompress_ptr cinfo)
  */
 
 LOCAL(void)
-master_selection (j_decompress_ptr cinfo)
+master_selection_xp (j_decompress_ptr cinfo)
 {
-  my_master_ptr master = (my_master_ptr) cinfo->master;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_master_ptr master = (my_master_ptr) xinfo->master_xp;
   boolean use_c_buffer;
   long samplesperrow;
   JDIMENSION jd_samplesperrow;
 
   /* Initialize dimensions and other stuff */
-  jpeg_calc_output_dimensions(cinfo);
-  prepare_range_limit_table(cinfo);
+  jpeg_calc_output_dimensions_xp(cinfo);
+  prepare_range_limit_table_xp(cinfo);
 
   /* Width of an output scanline must be representable as JDIMENSION. */
   samplesperrow = (long) cinfo->output_width * (long) cinfo->out_color_components;
@@ -304,7 +316,7 @@ master_selection (j_decompress_ptr cinfo)
 
   /* Initialize my private state */
   master->pass_number = 0;
-  master->using_merged_upsample = use_merged_upsample(cinfo);
+  master->using_merged_upsample = use_merged_upsample_xp(cinfo);
 
   /* Color quantizer selection */
   master->quantizer_1pass = NULL;
@@ -323,8 +335,8 @@ master_selection (j_decompress_ptr cinfo)
       cinfo->enable_1pass_quant = TRUE;
       cinfo->enable_external_quant = FALSE;
       cinfo->enable_2pass_quant = FALSE;
-      cinfo->colormap = NULL;
-    } else if (cinfo->colormap != NULL) {
+      xinfo->colormap_xp = NULL;
+    } else if (xinfo->colormap_xp != NULL) {
       cinfo->enable_external_quant = TRUE;
     } else if (cinfo->two_pass_quantize) {
       cinfo->enable_2pass_quant = TRUE;
@@ -334,8 +346,8 @@ master_selection (j_decompress_ptr cinfo)
 
     if (cinfo->enable_1pass_quant) {
 #ifdef QUANT_1PASS_SUPPORTED
-      jinit_1pass_quantizer(cinfo);
-      master->quantizer_1pass = cinfo->cquantize;
+      jinit_1pass_quantizer_xp(cinfo);
+      master->quantizer_1pass = xinfo->cquantize_xp;
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
@@ -344,8 +356,8 @@ master_selection (j_decompress_ptr cinfo)
     /* We use the 2-pass code to map to external colormaps. */
     if (cinfo->enable_2pass_quant || cinfo->enable_external_quant) {
 #ifdef QUANT_2PASS_SUPPORTED
-      jinit_2pass_quantizer(cinfo);
-      master->quantizer_2pass = cinfo->cquantize;
+      jinit_2pass_quantizer_xp(cinfo);
+      master->quantizer_2pass = xinfo->cquantize_xp;
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
@@ -359,44 +371,44 @@ master_selection (j_decompress_ptr cinfo)
   if (! cinfo->raw_data_out) {
     if (master->using_merged_upsample) {
 #ifdef UPSAMPLE_MERGING_SUPPORTED
-      jinit_merged_upsampler(cinfo); /* does color conversion too */
+      jinit_merged_upsampler_xp(cinfo); /* does color conversion too */
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
     } else {
-      jinit_color_deconverter(cinfo);
-      jinit_upsampler(cinfo);
+      jinit_color_deconverter_xp(cinfo);
+      jinit_upsampler_xp(cinfo);
     }
-    jinit_d_post_controller(cinfo, cinfo->enable_2pass_quant);
+    jinit_d_post_controller_xp(cinfo, cinfo->enable_2pass_quant);
   }
   /* Inverse DCT */
-  jinit_inverse_dct(cinfo);
+  jinit_inverse_dct_xp(cinfo);
   /* Entropy decoding: either Huffman or arithmetic coding. */
   if (cinfo->arith_code) {
     ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
   } else {
     if (cinfo->progressive_mode) {
 #ifdef D_PROGRESSIVE_SUPPORTED
-      jinit_phuff_decoder(cinfo);
+      jinit_phuff_decoder_xp(cinfo);
 #else
       ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
     } else
-      jinit_huff_decoder(cinfo);
+      jinit_huff_decoder_xp(cinfo);
   }
 
   /* Initialize principal buffer controllers. */
-  use_c_buffer = cinfo->inputctl->has_multiple_scans || cinfo->buffered_image;
-  jinit_d_coef_controller(cinfo, use_c_buffer);
+  use_c_buffer = xinfo->inputctl_xp->has_multiple_scans || cinfo->buffered_image;
+  jinit_d_coef_controller_xp(cinfo, use_c_buffer);
 
   if (! cinfo->raw_data_out)
-    jinit_d_main_controller(cinfo, FALSE /* never need full buffer here */);
+    jinit_d_main_controller_xp(cinfo, FALSE /* never need full buffer here */);
 
   /* We can now tell the memory manager to allocate virtual arrays. */
-  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
+  (*cinfo->mem->realize_virt_arrays_xp) ((j_common_ptr) cinfo);
 
   /* Initialize input side of decompressor to consume first scan. */
-  (*cinfo->inputctl->start_input_pass) (cinfo);
+  (*xinfo->inputctl_xp->start_input_pass_xp) (cinfo);
 
 #ifdef D_MULTISCAN_FILES_SUPPORTED
   /* If jpeg_start_decompress will read the whole file, initialize
@@ -404,7 +416,7 @@ master_selection (j_decompress_ptr cinfo)
    * as one pass.
    */
   if (cinfo->progress != NULL && ! cinfo->buffered_image &&
-      cinfo->inputctl->has_multiple_scans) {
+      xinfo->inputctl_xp->has_multiple_scans) {
     int nscans;
     /* Estimate number of scans to set pass_limit. */
     if (cinfo->progressive_mode) {
@@ -435,43 +447,51 @@ master_selection (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-prepare_for_output_pass (j_decompress_ptr cinfo)
+prepare_for_output_pass_xp (j_decompress_ptr cinfo)
 {
-  my_master_ptr master = (my_master_ptr) cinfo->master;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_master_ptr master = (my_master_ptr) xinfo->master_xp;
 
   if (master->pub.is_dummy_pass) {
 #ifdef QUANT_2PASS_SUPPORTED
     /* Final pass of 2-pass quantization */
     master->pub.is_dummy_pass = FALSE;
-    (*cinfo->cquantize->start_pass) (cinfo, FALSE);
-    (*cinfo->post->start_pass) (cinfo, JBUF_CRANK_DEST);
-    (*cinfo->main->start_pass) (cinfo, JBUF_CRANK_DEST);
+    (*xinfo->cquantize_xp->start_pass_xp) (cinfo, FALSE);
+    (*xinfo->post_xp->start_pass_xp) (cinfo, JBUF_CRANK_DEST);
+    (*xinfo->main_xp->start_pass_xp) (cinfo, JBUF_CRANK_DEST);
 #else
     ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif /* QUANT_2PASS_SUPPORTED */
   } else {
-    if (cinfo->quantize_colors && cinfo->colormap == NULL) {
+    if (cinfo->quantize_colors && xinfo->colormap_xp == NULL) {
       /* Select new quantization method */
       if (cinfo->two_pass_quantize && cinfo->enable_2pass_quant) {
-	cinfo->cquantize = master->quantizer_2pass;
+	xinfo->cquantize_xp = master->quantizer_2pass;
 	master->pub.is_dummy_pass = TRUE;
       } else if (cinfo->enable_1pass_quant) {
-	cinfo->cquantize = master->quantizer_1pass;
+	xinfo->cquantize_xp = master->quantizer_1pass;
       } else {
 	ERREXIT(cinfo, JERR_MODE_CHANGE);
       }
     }
-    (*cinfo->idct->start_pass) (cinfo);
-    (*cinfo->coef->start_output_pass) (cinfo);
+    if (xinfo->lossless_xp)
+    {
+      (*xinfo->codec_xp->start_output_pass) (cinfo);
+    }
+    else
+    {
+      (*xinfo->idct_xp->start_pass_xp) (cinfo);
+      (*xinfo->coef_xp->start_output_pass_xp) (cinfo);
+    }
     if (! cinfo->raw_data_out) {
       if (! master->using_merged_upsample)
-	(*cinfo->cconvert->start_pass) (cinfo);
-      (*cinfo->upsample->start_pass) (cinfo);
+	(*xinfo->cconvert_xp->start_pass_xp) (cinfo);
+      (*xinfo->upsample_xp->start_pass_xp) (cinfo);
       if (cinfo->quantize_colors)
-	(*cinfo->cquantize->start_pass) (cinfo, master->pub.is_dummy_pass);
-      (*cinfo->post->start_pass) (cinfo,
+	(*xinfo->cquantize_xp->start_pass_xp) (cinfo, master->pub.is_dummy_pass);
+      (*xinfo->post_xp->start_pass_xp) (cinfo,
 	    (master->pub.is_dummy_pass ? JBUF_SAVE_AND_PASS : JBUF_PASS_THRU));
-      (*cinfo->main->start_pass) (cinfo, JBUF_PASS_THRU);
+      (*xinfo->main_xp->start_pass_xp) (cinfo, JBUF_PASS_THRU);
     }
   }
 
@@ -483,7 +503,7 @@ prepare_for_output_pass (j_decompress_ptr cinfo)
     /* In buffered-image mode, we assume one more output pass if EOI not
      * yet reached, but no more passes if EOI has been reached.
      */
-    if (cinfo->buffered_image && ! cinfo->inputctl->eoi_reached) {
+    if (cinfo->buffered_image && ! xinfo->inputctl_xp->eoi_reached) {
       cinfo->progress->total_passes += (cinfo->enable_2pass_quant ? 2 : 1);
     }
   }
@@ -495,12 +515,13 @@ prepare_for_output_pass (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-finish_output_pass (j_decompress_ptr cinfo)
+finish_output_pass_xp (j_decompress_ptr cinfo)
 {
-  my_master_ptr master = (my_master_ptr) cinfo->master;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_master_ptr master = (my_master_ptr) xinfo->master_xp;
 
   if (cinfo->quantize_colors)
-    (*cinfo->cquantize->finish_pass) (cinfo);
+    (*xinfo->cquantize_xp->finish_pass_xp) (cinfo);
   master->pass_number++;
 }
 
@@ -512,20 +533,21 @@ finish_output_pass (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jpeg_new_colormap (j_decompress_ptr cinfo)
+jpeg_new_colormap_xp (j_decompress_ptr cinfo)
 {
-  my_master_ptr master = (my_master_ptr) cinfo->master;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_master_ptr master = (my_master_ptr) xinfo->master_xp;
 
   /* Prevent application from calling me at wrong times */
   if (cinfo->global_state != DSTATE_BUFIMAGE)
     ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
 
   if (cinfo->quantize_colors && cinfo->enable_external_quant &&
-      cinfo->colormap != NULL) {
+      xinfo->colormap_xp != NULL) {
     /* Select 2-pass quantizer for external colormap use */
-    cinfo->cquantize = master->quantizer_2pass;
+    xinfo->cquantize_xp = master->quantizer_2pass;
     /* Notify quantizer of colormap change */
-    (*cinfo->cquantize->new_color_map) (cinfo);
+    (*xinfo->cquantize_xp->new_color_map_xp) (cinfo);
     master->pub.is_dummy_pass = FALSE; /* just in case */
   } else
     ERREXIT(cinfo, JERR_MODE_CHANGE);
@@ -540,18 +562,19 @@ jpeg_new_colormap (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_master_decompress (j_decompress_ptr cinfo)
+jinit_master_decompress_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_master_ptr master;
 
   master = (my_master_ptr)
       (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				  SIZEOF(my_decomp_master));
-  cinfo->master = (struct jpeg_decomp_master *) master;
-  master->pub.prepare_for_output_pass = prepare_for_output_pass;
-  master->pub.finish_output_pass = finish_output_pass;
+  xinfo->master_xp = (struct jpeg_decomp_master_xp *) master;
+  master->pub.prepare_for_output_pass_xp = prepare_for_output_pass_xp;
+  master->pub.finish_output_pass_xp = finish_output_pass_xp;
 
   master->pub.is_dummy_pass = FALSE;
 
-  master_selection(cinfo);
+  master_selection_xp(cinfo);
 }
diff --git a/jdmerge.c b/xjdmerge.c
similarity index 79%
rename from jdmerge.c
rename to xjdmerge.c
index 3744446..50c1c34 100644
--- a/jdmerge.c
+++ b/xjdmerge.c
@@ -1,5 +1,5 @@
 /*
- * jdmerge.c
+ * xjdmerge.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -34,7 +34,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 #ifdef UPSAMPLE_MERGING_SUPPORTED
 
@@ -42,12 +42,12 @@
 /* Private subobject */
 
 typedef struct {
-  struct jpeg_upsampler pub;	/* public fields */
+  struct jpeg_upsampler_xp pub;	/* public fields */
 
   /* Pointer to routine to do actual upsampling/conversion of one row group */
   JMETHOD(void, upmethod, (j_decompress_ptr cinfo,
-			   JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
-			   JSAMPARRAY output_buf));
+			   JSAMPIMAGEXP input_buf, JDIMENSION in_row_group_ctr,
+			   JSAMPARRAYXP output_buf));
 
   /* Private state for YCC->RGB conversion */
   int * Cr_r_tab;		/* => table for Cr to R conversion */
@@ -60,7 +60,7 @@ typedef struct {
    * application provides just a one-row buffer; we also use the spare
    * to discard the dummy last row if the image height is odd.
    */
-  JSAMPROW spare_row;
+  JSAMPROWXP spare_row;
   boolean spare_full;		/* T if spare buffer is occupied */
 
   JDIMENSION out_row_width;	/* samples per output row */
@@ -80,27 +80,30 @@ typedef my_upsampler * my_upsample_ptr;
  */
 
 LOCAL(void)
-build_ycc_rgb_table (j_decompress_ptr cinfo)
+build_ycc_rgb_table_xp (j_decompress_ptr cinfo)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
+  const JSAMPLEXP MAXJSAMPLEXP = xinfo->max_JSAMPLEXP;
+  const JSAMPLEXP CENTERJSAMPLEXP = xinfo->center_JSAMPLEXP;
   int i;
   INT32 x;
   SHIFT_TEMPS
 
   upsample->Cr_r_tab = (int *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				(MAXJSAMPLE+1) * SIZEOF(int));
+				(MAXJSAMPLEXP+1) * SIZEOF(int));
   upsample->Cb_b_tab = (int *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				(MAXJSAMPLE+1) * SIZEOF(int));
+				(MAXJSAMPLEXP+1) * SIZEOF(int));
   upsample->Cr_g_tab = (INT32 *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				(MAXJSAMPLE+1) * SIZEOF(INT32));
+				(MAXJSAMPLEXP+1) * SIZEOF(INT32));
   upsample->Cb_g_tab = (INT32 *)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-				(MAXJSAMPLE+1) * SIZEOF(INT32));
+				(MAXJSAMPLEXP+1) * SIZEOF(INT32));
 
-  for (i = 0, x = -CENTERJSAMPLE; i <= MAXJSAMPLE; i++, x++) {
+  for (i = 0, x = -CENTERJSAMPLEXP; i <= MAXJSAMPLEXP; i++, x++) {
     /* i is the actual input pixel value, in the range 0..MAXJSAMPLE */
     /* The Cb or Cr value we are thinking of is x = i - CENTERJSAMPLE */
     /* Cr=>R value is nearest int to 1.40200 * x */
@@ -123,9 +126,10 @@ build_ycc_rgb_table (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_pass_merged_upsample (j_decompress_ptr cinfo)
+start_pass_merged_upsample_xp (j_decompress_ptr cinfo)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
 
   /* Mark the spare buffer empty */
   upsample->spare_full = FALSE;
@@ -141,20 +145,21 @@ start_pass_merged_upsample (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-merged_2v_upsample (j_decompress_ptr cinfo,
-		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+merged_2v_upsample_xp (j_decompress_ptr cinfo,
+		    JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 		    JDIMENSION in_row_groups_avail,
-		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+		    JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 		    JDIMENSION out_rows_avail)
 /* 2:1 vertical sampling case: may need a spare row. */
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
-  JSAMPROW work_ptrs[2];
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
+  JSAMPROWXP work_ptrs[2];
   JDIMENSION num_rows;		/* number of rows returned to caller */
 
   if (upsample->spare_full) {
     /* If we have a spare row saved from a previous cycle, just return it. */
-    jcopy_sample_rows(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
+    jcopy_sample_rows_xp(& upsample->spare_row, 0, output_buf + *out_row_ctr, 0,
 		      1, upsample->out_row_width);
     num_rows = 1;
     upsample->spare_full = FALSE;
@@ -190,14 +195,15 @@ merged_2v_upsample (j_decompress_ptr cinfo,
 
 
 METHODDEF(void)
-merged_1v_upsample (j_decompress_ptr cinfo,
-		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+merged_1v_upsample_xp (j_decompress_ptr cinfo,
+		    JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 		    JDIMENSION in_row_groups_avail,
-		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+		    JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 		    JDIMENSION out_rows_avail)
 /* 1:1 vertical sampling case: much easier, never need a spare row. */
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
 
   /* Just do the upsampling. */
   (*upsample->upmethod) (cinfo, input_buf, *in_row_group_ctr,
@@ -223,18 +229,19 @@ merged_1v_upsample (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-h2v1_merged_upsample (j_decompress_ptr cinfo,
-		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
-		      JSAMPARRAY output_buf)
+h2v1_merged_upsample_xp (j_decompress_ptr cinfo,
+		      JSAMPIMAGEXP input_buf, JDIMENSION in_row_group_ctr,
+		      JSAMPARRAYXP output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
   register int y, cred, cgreen, cblue;
   int cb, cr;
-  register JSAMPROW outptr;
-  JSAMPROW inptr0, inptr1, inptr2;
+  register JSAMPROWXP outptr;
+  JSAMPROWXP inptr0, inptr1, inptr2;
   JDIMENSION col;
   /* copy these pointers into registers if possible */
-  register JSAMPLE * range_limit = cinfo->sample_range_limit;
+  register JSAMPLEXP * range_limit = xinfo->sample_range_limit_xp;
   int * Crrtab = upsample->Cr_r_tab;
   int * Cbbtab = upsample->Cb_b_tab;
   INT32 * Crgtab = upsample->Cr_g_tab;
@@ -285,18 +292,19 @@ h2v1_merged_upsample (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-h2v2_merged_upsample (j_decompress_ptr cinfo,
-		      JSAMPIMAGE input_buf, JDIMENSION in_row_group_ctr,
-		      JSAMPARRAY output_buf)
+h2v2_merged_upsample_xp (j_decompress_ptr cinfo,
+		      JSAMPIMAGEXP input_buf, JDIMENSION in_row_group_ctr,
+		      JSAMPARRAYXP output_buf)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
   register int y, cred, cgreen, cblue;
   int cb, cr;
-  register JSAMPROW outptr0, outptr1;
-  JSAMPROW inptr00, inptr01, inptr1, inptr2;
+  register JSAMPROWXP outptr0, outptr1;
+  JSAMPROWXP inptr00, inptr01, inptr1, inptr2;
   JDIMENSION col;
   /* copy these pointers into registers if possible */
-  register JSAMPLE * range_limit = cinfo->sample_range_limit;
+  register JSAMPLEXP * range_limit = xinfo->sample_range_limit_xp;
   int * Crrtab = upsample->Cr_r_tab;
   int * Cbbtab = upsample->Cb_b_tab;
   INT32 * Crgtab = upsample->Cr_g_tab;
@@ -367,34 +375,35 @@ h2v2_merged_upsample (j_decompress_ptr cinfo,
  */
 
 GLOBAL(void)
-jinit_merged_upsampler (j_decompress_ptr cinfo)
+jinit_merged_upsampler_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_upsample_ptr upsample;
 
   upsample = (my_upsample_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_upsampler));
-  cinfo->upsample = (struct jpeg_upsampler *) upsample;
-  upsample->pub.start_pass = start_pass_merged_upsample;
+  xinfo->upsample_xp = (struct jpeg_upsampler_xp *) upsample;
+  upsample->pub.start_pass_xp = start_pass_merged_upsample_xp;
   upsample->pub.need_context_rows = FALSE;
 
   upsample->out_row_width = cinfo->output_width * cinfo->out_color_components;
 
   if (cinfo->max_v_samp_factor == 2) {
-    upsample->pub.upsample = merged_2v_upsample;
-    upsample->upmethod = h2v2_merged_upsample;
+    upsample->pub.upsample_xp = merged_2v_upsample_xp;
+    upsample->upmethod = h2v2_merged_upsample_xp;
     /* Allocate a spare row buffer */
-    upsample->spare_row = (JSAMPROW)
+    upsample->spare_row = (JSAMPROWXP)
       (*cinfo->mem->alloc_large) ((j_common_ptr) cinfo, JPOOL_IMAGE,
-		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLE)));
+		(size_t) (upsample->out_row_width * SIZEOF(JSAMPLEXP)));
   } else {
-    upsample->pub.upsample = merged_1v_upsample;
-    upsample->upmethod = h2v1_merged_upsample;
+    upsample->pub.upsample_xp = merged_1v_upsample_xp;
+    upsample->upmethod = h2v1_merged_upsample_xp;
     /* No spare row needed */
     upsample->spare_row = NULL;
   }
 
-  build_ycc_rgb_table(cinfo);
+  build_ycc_rgb_table_xp(cinfo);
 }
 
 #endif /* UPSAMPLE_MERGING_SUPPORTED */
diff --git a/jdphuff.c b/xjdphuff.c
similarity index 87%
rename from jdphuff.c
rename to xjdphuff.c
index 2267809..bdec2a3 100644
--- a/jdphuff.c
+++ b/xjdphuff.c
@@ -1,5 +1,5 @@
 /*
- * jdphuff.c
+ * xjdphuff.c
  *
  * Copyright (C) 1995-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -16,8 +16,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdhuff.h"		/* Declarations shared with jdhuff.c */
+#include "xjpeglib.h"
+#include "xjdhuff.h"		/* Declarations shared with jdhuff.c */
 
 
 #ifdef D_PROGRESSIVE_SUPPORTED
@@ -54,7 +54,7 @@ typedef struct {
 
 
 typedef struct {
-  struct jpeg_entropy_decoder pub; /* public fields */
+  struct jpeg_entropy_decoder_xp pub; /* public fields */
 
   /* These fields are loaded into local variables at start of each MCU.
    * In case of suspension, we exit WITHOUT updating them.
@@ -74,13 +74,13 @@ typedef struct {
 typedef phuff_entropy_decoder * phuff_entropy_ptr;
 
 /* Forward declarations */
-METHODDEF(boolean) decode_mcu_DC_first JPP((j_decompress_ptr cinfo,
+METHODDEF(boolean) decode_mcu_DC_first_xp JPP((j_decompress_ptr cinfo,
 					    JBLOCKROW *MCU_data));
-METHODDEF(boolean) decode_mcu_AC_first JPP((j_decompress_ptr cinfo,
+METHODDEF(boolean) decode_mcu_AC_first_xp JPP((j_decompress_ptr cinfo,
 					    JBLOCKROW *MCU_data));
-METHODDEF(boolean) decode_mcu_DC_refine JPP((j_decompress_ptr cinfo,
+METHODDEF(boolean) decode_mcu_DC_refine_xp JPP((j_decompress_ptr cinfo,
 					     JBLOCKROW *MCU_data));
-METHODDEF(boolean) decode_mcu_AC_refine JPP((j_decompress_ptr cinfo,
+METHODDEF(boolean) decode_mcu_AC_refine_xp JPP((j_decompress_ptr cinfo,
 					     JBLOCKROW *MCU_data));
 
 
@@ -89,9 +89,10 @@ METHODDEF(boolean) decode_mcu_AC_refine JPP((j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-start_pass_phuff_decoder (j_decompress_ptr cinfo)
+start_pass_phuff_decoder_xp (j_decompress_ptr cinfo)
 {
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   boolean is_DC_band, bad;
   int ci, coefi, tbl;
   int *coef_bit_ptr;
@@ -148,14 +149,14 @@ start_pass_phuff_decoder (j_decompress_ptr cinfo)
   /* Select MCU decoding routine */
   if (cinfo->Ah == 0) {
     if (is_DC_band)
-      entropy->pub.decode_mcu = decode_mcu_DC_first;
+      entropy->pub.decode_mcu_xp = decode_mcu_DC_first_xp;
     else
-      entropy->pub.decode_mcu = decode_mcu_AC_first;
+      entropy->pub.decode_mcu_xp = decode_mcu_AC_first_xp;
   } else {
     if (is_DC_band)
-      entropy->pub.decode_mcu = decode_mcu_DC_refine;
+      entropy->pub.decode_mcu_xp = decode_mcu_DC_refine_xp;
     else
-      entropy->pub.decode_mcu = decode_mcu_AC_refine;
+      entropy->pub.decode_mcu_xp = decode_mcu_AC_refine_xp;
   }
 
   for (ci = 0; ci < cinfo->comps_in_scan; ci++) {
@@ -166,12 +167,12 @@ start_pass_phuff_decoder (j_decompress_ptr cinfo)
     if (is_DC_band) {
       if (cinfo->Ah == 0) {	/* DC refinement needs no table */
 	tbl = compptr->dc_tbl_no;
-	jpeg_make_d_derived_tbl(cinfo, TRUE, tbl,
+	jpeg_make_d_derived_tbl_xp(cinfo, TRUE, tbl,
 				& entropy->derived_tbls[tbl]);
       }
     } else {
       tbl = compptr->ac_tbl_no;
-      jpeg_make_d_derived_tbl(cinfo, FALSE, tbl,
+      jpeg_make_d_derived_tbl_xp(cinfo, FALSE, tbl,
 			      & entropy->derived_tbls[tbl]);
       /* remember the single active table */
       entropy->ac_derived_tbl = entropy->derived_tbls[tbl];
@@ -225,18 +226,19 @@ static const int extend_offset[16] = /* entry n is (-1 << n) + 1 */
  */
 
 LOCAL(boolean)
-process_restart (j_decompress_ptr cinfo)
+process_restart_xp (j_decompress_ptr cinfo)
 {
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   int ci;
 
   /* Throw away any unused bits remaining in bit buffer; */
   /* include any full bytes in next_marker's count of discarded bytes */
-  cinfo->marker->discarded_bytes += entropy->bitstate.bits_left / 8;
+  xinfo->marker_xp->discarded_bytes += entropy->bitstate.bits_left / 8;
   entropy->bitstate.bits_left = 0;
 
   /* Advance past the RSTn marker */
-  if (! (*cinfo->marker->read_restart_marker) (cinfo))
+  if (! (*xinfo->marker_xp->read_restart_marker) (cinfo))
     return FALSE;
 
   /* Re-initialize DC predictions to 0 */
@@ -283,9 +285,10 @@ process_restart (j_decompress_ptr cinfo)
  */
 
 METHODDEF(boolean)
-decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+decode_mcu_DC_first_xp (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {   
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   int Al = cinfo->Al;
   register int s, r;
   int blkn, ci;
@@ -298,7 +301,7 @@ decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
-      if (! process_restart(cinfo))
+      if (! process_restart_xp(cinfo))
 	return FALSE;
   }
 
@@ -322,7 +325,7 @@ decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
       /* Decode a single block's worth of coefficients */
 
       /* Section F.2.2.1: decode the DC coefficient difference */
-      HUFF_DECODE(s, br_state, tbl, return FALSE, label1);
+      HUFF_DECODE_XP(s, br_state, tbl, return FALSE, label1);
       if (s) {
 	CHECK_BIT_BUFFER(br_state, s, return FALSE);
 	r = GET_BITS(s);
@@ -354,9 +357,10 @@ decode_mcu_DC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 METHODDEF(boolean)
-decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+decode_mcu_AC_first_xp (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {   
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   int Se = cinfo->Se;
   int Al = cinfo->Al;
   register int s, k, r;
@@ -368,7 +372,7 @@ decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
-      if (! process_restart(cinfo))
+      if (! process_restart_xp(cinfo))
 	return FALSE;
   }
 
@@ -392,7 +396,7 @@ decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
       tbl = entropy->ac_derived_tbl;
 
       for (k = cinfo->Ss; k <= Se; k++) {
-	HUFF_DECODE(s, br_state, tbl, return FALSE, label2);
+	HUFF_DECODE_XP(s, br_state, tbl, return FALSE, label2);
 	r = s >> 4;
 	s &= 15;
 	if (s) {
@@ -439,9 +443,10 @@ decode_mcu_AC_first (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 METHODDEF(boolean)
-decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+decode_mcu_DC_refine_xp (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {   
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
   int blkn;
   JBLOCKROW block;
@@ -450,7 +455,7 @@ decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
-      if (! process_restart(cinfo))
+      if (! process_restart_xp(cinfo))
 	return FALSE;
   }
 
@@ -488,9 +493,10 @@ decode_mcu_DC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
  */
 
 METHODDEF(boolean)
-decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
+decode_mcu_AC_refine_xp (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 {   
-  phuff_entropy_ptr entropy = (phuff_entropy_ptr) cinfo->entropy;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  phuff_entropy_ptr entropy = (phuff_entropy_ptr) xinfo->entropy_xp;
   int Se = cinfo->Se;
   int p1 = 1 << cinfo->Al;	/* 1 in the bit position being coded */
   int m1 = (-1) << cinfo->Al;	/* -1 in the bit position being coded */
@@ -506,7 +512,7 @@ decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
   /* Process restart marker if needed; may have to suspend */
   if (cinfo->restart_interval) {
     if (entropy->restarts_to_go == 0)
-      if (! process_restart(cinfo))
+      if (! process_restart_xp(cinfo))
 	return FALSE;
   }
 
@@ -535,7 +541,7 @@ decode_mcu_AC_refine (j_decompress_ptr cinfo, JBLOCKROW *MCU_data)
 
     if (EOBRUN == 0) {
       for (; k <= Se; k++) {
-	HUFF_DECODE(s, br_state, tbl, goto undoit, label3);
+	HUFF_DECODE_XP(s, br_state, tbl, goto undoit, label3);
 	r = s >> 4;
 	s &= 15;
 	if (s) {
@@ -638,8 +644,9 @@ undoit:
  */
 
 GLOBAL(void)
-jinit_phuff_decoder (j_decompress_ptr cinfo)
+jinit_phuff_decoder_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   phuff_entropy_ptr entropy;
   int *coef_bit_ptr;
   int ci, i;
@@ -647,8 +654,8 @@ jinit_phuff_decoder (j_decompress_ptr cinfo)
   entropy = (phuff_entropy_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(phuff_entropy_decoder));
-  cinfo->entropy = (struct jpeg_entropy_decoder *) entropy;
-  entropy->pub.start_pass = start_pass_phuff_decoder;
+  xinfo->entropy_xp = (struct jpeg_entropy_decoder_xp *) entropy;
+  entropy->pub.start_pass_xp = start_pass_phuff_decoder_xp;
 
   /* Mark derived tables unallocated */
   for (i = 0; i < NUM_HUFF_TBLS; i++) {
diff --git a/jdpostct.c b/xjdpostct.c
similarity index 73%
rename from jdpostct.c
rename to xjdpostct.c
index 571563d..b293233 100644
--- a/jdpostct.c
+++ b/xjdpostct.c
@@ -1,5 +1,5 @@
 /*
- * jdpostct.c
+ * xjdpostct.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -18,13 +18,13 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Private buffer controller object */
 
 typedef struct {
-  struct jpeg_d_post_controller pub; /* public fields */
+  struct jpeg_d_post_controller_xp pub; /* public fields */
 
   /* Color quantization source buffer: this holds output data from
    * the upsample/color conversion step to be passed to the quantizer.
@@ -32,7 +32,7 @@ typedef struct {
    * for one-pass operation, a strip buffer is sufficient.
    */
   jvirt_sarray_ptr whole_image;	/* virtual array, or NULL if one-pass */
-  JSAMPARRAY buffer;		/* strip buffer, or current strip of virtual */
+  JSAMPARRAYXP buffer;		/* strip buffer, or current strip of virtual */
   JDIMENSION strip_height;	/* buffer size in rows */
   /* for two-pass mode only: */
   JDIMENSION starting_row;	/* row # of first row in current strip */
@@ -43,24 +43,24 @@ typedef my_post_controller * my_post_ptr;
 
 
 /* Forward declarations */
-METHODDEF(void) post_process_1pass
+METHODDEF(void) post_process_1pass_xp
 	JPP((j_decompress_ptr cinfo,
-	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+	     JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 	     JDIMENSION in_row_groups_avail,
-	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+	     JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 	     JDIMENSION out_rows_avail));
 #ifdef QUANT_2PASS_SUPPORTED
-METHODDEF(void) post_process_prepass
+METHODDEF(void) post_process_prepass_xp
 	JPP((j_decompress_ptr cinfo,
-	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+	     JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 	     JDIMENSION in_row_groups_avail,
-	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+	     JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 	     JDIMENSION out_rows_avail));
-METHODDEF(void) post_process_2pass
+METHODDEF(void) post_process_2pass_xp
 	JPP((j_decompress_ptr cinfo,
-	     JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+	     JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 	     JDIMENSION in_row_groups_avail,
-	     JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+	     JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 	     JDIMENSION out_rows_avail));
 #endif
 
@@ -70,21 +70,22 @@ METHODDEF(void) post_process_2pass
  */
 
 METHODDEF(void)
-start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
+start_pass_dpost_xp (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
 {
-  my_post_ptr post = (my_post_ptr) cinfo->post;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_post_ptr post = (my_post_ptr) xinfo->post_xp;
 
   switch (pass_mode) {
   case JBUF_PASS_THRU:
     if (cinfo->quantize_colors) {
       /* Single-pass processing with color quantization. */
-      post->pub.post_process_data = post_process_1pass;
+      post->pub.post_process_data_xp = post_process_1pass_xp;
       /* We could be doing buffered-image output before starting a 2-pass
        * color quantization; in that case, jinit_d_post_controller did not
        * allocate a strip buffer.  Use the virtual-array buffer as workspace.
        */
       if (post->buffer == NULL) {
-	post->buffer = (*cinfo->mem->access_virt_sarray)
+	post->buffer = (*cinfo->mem->access_virt_sarray_xp)
 	  ((j_common_ptr) cinfo, post->whole_image,
 	   (JDIMENSION) 0, post->strip_height, TRUE);
       }
@@ -92,7 +93,7 @@ start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
       /* For single-pass processing without color quantization,
        * I have no work to do; just call the upsampler directly.
        */
-      post->pub.post_process_data = cinfo->upsample->upsample;
+      post->pub.post_process_data_xp = xinfo->upsample_xp->upsample_xp;
     }
     break;
 #ifdef QUANT_2PASS_SUPPORTED
@@ -100,13 +101,13 @@ start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
     /* First pass of 2-pass quantization */
     if (post->whole_image == NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
-    post->pub.post_process_data = post_process_prepass;
+    post->pub.post_process_data_xp = post_process_prepass_xp;
     break;
   case JBUF_CRANK_DEST:
     /* Second pass of 2-pass quantization */
     if (post->whole_image == NULL)
       ERREXIT(cinfo, JERR_BAD_BUFFER_MODE);
-    post->pub.post_process_data = post_process_2pass;
+    post->pub.post_process_data_xp = post_process_2pass_xp;
     break;
 #endif /* QUANT_2PASS_SUPPORTED */
   default:
@@ -123,13 +124,14 @@ start_pass_dpost (j_decompress_ptr cinfo, J_BUF_MODE pass_mode)
  */
 
 METHODDEF(void)
-post_process_1pass (j_decompress_ptr cinfo,
-		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+post_process_1pass_xp (j_decompress_ptr cinfo,
+		    JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 		    JDIMENSION in_row_groups_avail,
-		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+		    JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 		    JDIMENSION out_rows_avail)
 {
-  my_post_ptr post = (my_post_ptr) cinfo->post;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_post_ptr post = (my_post_ptr) xinfo->post_xp;
   JDIMENSION num_rows, max_rows;
 
   /* Fill the buffer, but not more than what we can dump out in one go. */
@@ -138,11 +140,11 @@ post_process_1pass (j_decompress_ptr cinfo,
   if (max_rows > post->strip_height)
     max_rows = post->strip_height;
   num_rows = 0;
-  (*cinfo->upsample->upsample) (cinfo,
+  (*xinfo->upsample_xp->upsample_xp) (cinfo,
 		input_buf, in_row_group_ctr, in_row_groups_avail,
 		post->buffer, &num_rows, max_rows);
   /* Quantize and emit data. */
-  (*cinfo->cquantize->color_quantize) (cinfo,
+  (*xinfo->cquantize_xp->color_quantize_xp) (cinfo,
 		post->buffer, output_buf + *out_row_ctr, (int) num_rows);
   *out_row_ctr += num_rows;
 }
@@ -155,25 +157,26 @@ post_process_1pass (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-post_process_prepass (j_decompress_ptr cinfo,
-		      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+post_process_prepass_xp (j_decompress_ptr cinfo,
+		      JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 		      JDIMENSION in_row_groups_avail,
-		      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+		      JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 		      JDIMENSION out_rows_avail)
 {
-  my_post_ptr post = (my_post_ptr) cinfo->post;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_post_ptr post = (my_post_ptr) xinfo->post_xp;
   JDIMENSION old_next_row, num_rows;
 
   /* Reposition virtual buffer if at start of strip. */
   if (post->next_row == 0) {
-    post->buffer = (*cinfo->mem->access_virt_sarray)
+    post->buffer = (*cinfo->mem->access_virt_sarray_xp)
 	((j_common_ptr) cinfo, post->whole_image,
 	 post->starting_row, post->strip_height, TRUE);
   }
 
   /* Upsample some data (up to a strip height's worth). */
   old_next_row = post->next_row;
-  (*cinfo->upsample->upsample) (cinfo,
+  (*xinfo->upsample_xp->upsample_xp) (cinfo,
 		input_buf, in_row_group_ctr, in_row_groups_avail,
 		post->buffer, &post->next_row, post->strip_height);
 
@@ -181,8 +184,8 @@ post_process_prepass (j_decompress_ptr cinfo,
   /* but we advance out_row_ctr so outer loop can tell when we're done. */
   if (post->next_row > old_next_row) {
     num_rows = post->next_row - old_next_row;
-    (*cinfo->cquantize->color_quantize) (cinfo, post->buffer + old_next_row,
-					 (JSAMPARRAY) NULL, (int) num_rows);
+    (*xinfo->cquantize_xp->color_quantize_xp) (cinfo, post->buffer + old_next_row,
+					 (JSAMPARRAYXP) NULL, (int) num_rows);
     *out_row_ctr += num_rows;
   }
 
@@ -199,18 +202,19 @@ post_process_prepass (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-post_process_2pass (j_decompress_ptr cinfo,
-		    JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+post_process_2pass_xp (j_decompress_ptr cinfo,
+		    JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 		    JDIMENSION in_row_groups_avail,
-		    JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+		    JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 		    JDIMENSION out_rows_avail)
 {
-  my_post_ptr post = (my_post_ptr) cinfo->post;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_post_ptr post = (my_post_ptr) xinfo->post_xp;
   JDIMENSION num_rows, max_rows;
 
   /* Reposition virtual buffer if at start of strip. */
   if (post->next_row == 0) {
-    post->buffer = (*cinfo->mem->access_virt_sarray)
+    post->buffer = (*cinfo->mem->access_virt_sarray_xp)
 	((j_common_ptr) cinfo, post->whole_image,
 	 post->starting_row, post->strip_height, FALSE);
   }
@@ -226,7 +230,7 @@ post_process_2pass (j_decompress_ptr cinfo,
     num_rows = max_rows;
 
   /* Quantize and emit data. */
-  (*cinfo->cquantize->color_quantize) (cinfo,
+  (*xinfo->cquantize_xp->color_quantize_xp) (cinfo,
 		post->buffer + post->next_row, output_buf + *out_row_ctr,
 		(int) num_rows);
   *out_row_ctr += num_rows;
@@ -247,15 +251,16 @@ post_process_2pass (j_decompress_ptr cinfo,
  */
 
 GLOBAL(void)
-jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
+jinit_d_post_controller_xp (j_decompress_ptr cinfo, boolean need_full_buffer)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_post_ptr post;
 
   post = (my_post_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_post_controller));
-  cinfo->post = (struct jpeg_d_post_controller *) post;
-  post->pub.start_pass = start_pass_dpost;
+  xinfo->post_xp = (struct jpeg_d_post_controller_xp *) post;
+  post->pub.start_pass_xp = start_pass_dpost_xp;
   post->whole_image = NULL;	/* flag for no virtual arrays */
   post->buffer = NULL;		/* flag for no strip buffer */
 
@@ -281,7 +286,7 @@ jinit_d_post_controller (j_decompress_ptr cinfo, boolean need_full_buffer)
 #endif /* QUANT_2PASS_SUPPORTED */
     } else {
       /* One-pass color quantization: just make a strip buffer. */
-      post->buffer = (*cinfo->mem->alloc_sarray)
+      post->buffer = (*cinfo->mem->alloc_sarray_xp)
 	((j_common_ptr) cinfo, JPOOL_IMAGE,
 	 cinfo->output_width * cinfo->out_color_components,
 	 post->strip_height);
diff --git a/jdsample.c b/xjdsample.c
similarity index 76%
rename from jdsample.c
rename to xjdsample.c
index 80ffefb..5fbb4f0 100644
--- a/jdsample.c
+++ b/xjdsample.c
@@ -1,5 +1,5 @@
 /*
- * jdsample.c
+ * xjdsample.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -20,18 +20,18 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 
 /* Pointer to routine to upsample a single component */
 typedef JMETHOD(void, upsample1_ptr,
 		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
-		 JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr));
+		 JSAMPARRAYXP input_data, JSAMPARRAYXP * output_data_ptr));
 
 /* Private subobject */
 
 typedef struct {
-  struct jpeg_upsampler pub;	/* public fields */
+  struct jpeg_upsampler_xp pub;	/* public fields */
 
   /* Color conversion buffer.  When using separate upsampling and color
    * conversion steps, this buffer holds one upsampled row group until it
@@ -40,7 +40,7 @@ typedef struct {
    * ie do not need rescaling.  The corresponding entry of color_buf[] is
    * simply set to point to the input data array, thereby avoiding copying.
    */
-  JSAMPARRAY color_buf[MAX_COMPONENTS];
+  JSAMPARRAYXP color_buf[MAX_COMPONENTS];
 
   /* Per-component upsampling method pointers */
   upsample1_ptr methods[MAX_COMPONENTS];
@@ -66,9 +66,10 @@ typedef my_upsampler * my_upsample_ptr;
  */
 
 METHODDEF(void)
-start_pass_upsample (j_decompress_ptr cinfo)
+start_pass_upsample_xp (j_decompress_ptr cinfo)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
 
   /* Mark the conversion buffer empty */
   upsample->next_row_out = cinfo->max_v_samp_factor;
@@ -86,13 +87,14 @@ start_pass_upsample (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-sep_upsample (j_decompress_ptr cinfo,
-	      JSAMPIMAGE input_buf, JDIMENSION *in_row_group_ctr,
+sep_upsample_xp (j_decompress_ptr cinfo,
+	      JSAMPIMAGEXP input_buf, JDIMENSION *in_row_group_ctr,
 	      JDIMENSION in_row_groups_avail,
-	      JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+	      JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 	      JDIMENSION out_rows_avail)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
   int ci;
   jpeg_component_info * compptr;
   JDIMENSION num_rows;
@@ -125,7 +127,7 @@ sep_upsample (j_decompress_ptr cinfo,
   if (num_rows > out_rows_avail)
     num_rows = out_rows_avail;
 
-  (*cinfo->cconvert->color_convert) (cinfo, upsample->color_buf,
+  (*xinfo->cconvert_xp->color_convert_xp) (cinfo, upsample->color_buf,
 				     (JDIMENSION) upsample->next_row_out,
 				     output_buf + *out_row_ctr,
 				     (int) num_rows);
@@ -154,8 +156,8 @@ sep_upsample (j_decompress_ptr cinfo,
  */
 
 METHODDEF(void)
-fullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-		   JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+fullsize_upsample_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+		   JSAMPARRAYXP input_data, JSAMPARRAYXP * output_data_ptr)
 {
   *output_data_ptr = input_data;
 }
@@ -167,8 +169,8 @@ fullsize_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+noop_upsample_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+	       JSAMPARRAYXP input_data, JSAMPARRAYXP * output_data_ptr)
 {
   *output_data_ptr = NULL;	/* safety check */
 }
@@ -186,15 +188,16 @@ noop_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	      JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+int_upsample_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+	      JSAMPARRAYXP input_data, JSAMPARRAYXP * output_data_ptr)
 {
-  my_upsample_ptr upsample = (my_upsample_ptr) cinfo->upsample;
-  JSAMPARRAY output_data = *output_data_ptr;
-  register JSAMPROW inptr, outptr;
-  register JSAMPLE invalue;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_upsample_ptr upsample = (my_upsample_ptr) xinfo->upsample_xp;
+  JSAMPARRAYXP output_data = *output_data_ptr;
+  register JSAMPROWXP inptr, outptr;
+  register JSAMPLEXP invalue;
   register int h;
-  JSAMPROW outend;
+  JSAMPROWXP outend;
   int h_expand, v_expand;
   int inrow, outrow;
 
@@ -215,7 +218,7 @@ int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
     }
     /* Generate any additional output rows by duplicating the first one */
     if (v_expand > 1) {
-      jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
+      jcopy_sample_rows_xp(output_data, outrow, output_data, outrow+1,
 			v_expand-1, cinfo->output_width);
     }
     inrow++;
@@ -230,13 +233,13 @@ int_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+h2v1_upsample_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+	       JSAMPARRAYXP input_data, JSAMPARRAYXP * output_data_ptr)
 {
-  JSAMPARRAY output_data = *output_data_ptr;
-  register JSAMPROW inptr, outptr;
-  register JSAMPLE invalue;
-  JSAMPROW outend;
+  JSAMPARRAYXP output_data = *output_data_ptr;
+  register JSAMPROWXP inptr, outptr;
+  register JSAMPLEXP invalue;
+  JSAMPROWXP outend;
   int inrow;
 
   for (inrow = 0; inrow < cinfo->max_v_samp_factor; inrow++) {
@@ -258,13 +261,13 @@ h2v1_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-	       JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+h2v2_upsample_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+	       JSAMPARRAYXP input_data, JSAMPARRAYXP * output_data_ptr)
 {
-  JSAMPARRAY output_data = *output_data_ptr;
-  register JSAMPROW inptr, outptr;
-  register JSAMPLE invalue;
-  JSAMPROW outend;
+  JSAMPARRAYXP output_data = *output_data_ptr;
+  register JSAMPROWXP inptr, outptr;
+  register JSAMPLEXP invalue;
+  JSAMPROWXP outend;
   int inrow, outrow;
 
   inrow = outrow = 0;
@@ -277,7 +280,7 @@ h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
       *outptr++ = invalue;
       *outptr++ = invalue;
     }
-    jcopy_sample_rows(output_data, outrow, output_data, outrow+1,
+    jcopy_sample_rows_xp(output_data, outrow, output_data, outrow+1,
 		      1, cinfo->output_width);
     inrow++;
     outrow += 2;
@@ -301,11 +304,11 @@ h2v2_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-h2v1_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-		     JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+h2v1_fancy_upsample_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+		     JSAMPARRAYXP input_data, JSAMPARRAYXP * output_data_ptr)
 {
-  JSAMPARRAY output_data = *output_data_ptr;
-  register JSAMPROW inptr, outptr;
+  JSAMPARRAYXP output_data = *output_data_ptr;
+  register JSAMPROWXP inptr, outptr;
   register int invalue;
   register JDIMENSION colctr;
   int inrow;
@@ -315,20 +318,20 @@ h2v1_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
     outptr = output_data[inrow];
     /* Special case for first column */
     invalue = GETJSAMPLE(*inptr++);
-    *outptr++ = (JSAMPLE) invalue;
-    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(*inptr) + 2) >> 2);
+    *outptr++ = (JSAMPLEXP) invalue;
+    *outptr++ = (JSAMPLEXP) ((invalue * 3 + GETJSAMPLE(*inptr) + 2) >> 2);
 
     for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
       /* General case: 3/4 * nearer pixel + 1/4 * further pixel */
       invalue = GETJSAMPLE(*inptr++) * 3;
-      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(inptr[-2]) + 1) >> 2);
-      *outptr++ = (JSAMPLE) ((invalue + GETJSAMPLE(*inptr) + 2) >> 2);
+      *outptr++ = (JSAMPLEXP) ((invalue + GETJSAMPLE(inptr[-2]) + 1) >> 2);
+      *outptr++ = (JSAMPLEXP) ((invalue + GETJSAMPLE(*inptr) + 2) >> 2);
     }
 
     /* Special case for last column */
     invalue = GETJSAMPLE(*inptr);
-    *outptr++ = (JSAMPLE) ((invalue * 3 + GETJSAMPLE(inptr[-1]) + 1) >> 2);
-    *outptr++ = (JSAMPLE) invalue;
+    *outptr++ = (JSAMPLEXP) ((invalue * 3 + GETJSAMPLE(inptr[-1]) + 1) >> 2);
+    *outptr++ = (JSAMPLEXP) invalue;
   }
 }
 
@@ -342,12 +345,12 @@ h2v1_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 METHODDEF(void)
-h2v2_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
-		     JSAMPARRAY input_data, JSAMPARRAY * output_data_ptr)
+h2v2_fancy_upsample_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+		     JSAMPARRAYXP input_data, JSAMPARRAYXP * output_data_ptr)
 {
-  JSAMPARRAY output_data = *output_data_ptr;
-  register JSAMPROW inptr0, inptr1, outptr;
-#if BITS_IN_JSAMPLE == 8
+  JSAMPARRAYXP output_data = *output_data_ptr;
+  register JSAMPROWXP inptr0, inptr1, outptr;
+#if BITS_IN_JSAMPLE12 == 8
   register int thiscolsum, lastcolsum, nextcolsum;
 #else
   register INT32 thiscolsum, lastcolsum, nextcolsum;
@@ -369,22 +372,22 @@ h2v2_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
       /* Special case for first column */
       thiscolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
       nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
-      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 8) >> 4);
-      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
+      *outptr++ = (JSAMPLEXP) ((thiscolsum * 4 + 8) >> 4);
+      *outptr++ = (JSAMPLEXP) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
       lastcolsum = thiscolsum; thiscolsum = nextcolsum;
 
       for (colctr = compptr->downsampled_width - 2; colctr > 0; colctr--) {
 	/* General case: 3/4 * nearer pixel + 1/4 * further pixel in each */
 	/* dimension, thus 9/16, 3/16, 3/16, 1/16 overall */
 	nextcolsum = GETJSAMPLE(*inptr0++) * 3 + GETJSAMPLE(*inptr1++);
-	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
-	*outptr++ = (JSAMPLE) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
+	*outptr++ = (JSAMPLEXP) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
+	*outptr++ = (JSAMPLEXP) ((thiscolsum * 3 + nextcolsum + 7) >> 4);
 	lastcolsum = thiscolsum; thiscolsum = nextcolsum;
       }
 
       /* Special case for last column */
-      *outptr++ = (JSAMPLE) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
-      *outptr++ = (JSAMPLE) ((thiscolsum * 4 + 7) >> 4);
+      *outptr++ = (JSAMPLEXP) ((thiscolsum * 3 + lastcolsum + 8) >> 4);
+      *outptr++ = (JSAMPLEXP) ((thiscolsum * 4 + 7) >> 4);
     }
     inrow++;
   }
@@ -396,8 +399,9 @@ h2v2_fancy_upsample (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 GLOBAL(void)
-jinit_upsampler (j_decompress_ptr cinfo)
+jinit_upsampler_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_upsample_ptr upsample;
   int ci;
   jpeg_component_info * compptr;
@@ -407,9 +411,9 @@ jinit_upsampler (j_decompress_ptr cinfo)
   upsample = (my_upsample_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_upsampler));
-  cinfo->upsample = (struct jpeg_upsampler *) upsample;
-  upsample->pub.start_pass = start_pass_upsample;
-  upsample->pub.upsample = sep_upsample;
+  xinfo->upsample_xp = (struct jpeg_upsampler_xp *) upsample;
+  upsample->pub.start_pass_xp = start_pass_upsample_xp;
+  upsample->pub.upsample_xp = sep_upsample_xp;
   upsample->pub.need_context_rows = FALSE; /* until we find out differently */
 
   if (cinfo->CCIR601_sampling)	/* this isn't supported */
@@ -438,37 +442,37 @@ jinit_upsampler (j_decompress_ptr cinfo)
     need_buffer = TRUE;
     if (! compptr->component_needed) {
       /* Don't bother to upsample an uninteresting component. */
-      upsample->methods[ci] = noop_upsample;
+      upsample->methods[ci] = noop_upsample_xp;
       need_buffer = FALSE;
     } else if (h_in_group == h_out_group && v_in_group == v_out_group) {
       /* Fullsize components can be processed without any work. */
-      upsample->methods[ci] = fullsize_upsample;
+      upsample->methods[ci] = fullsize_upsample_xp;
       need_buffer = FALSE;
     } else if (h_in_group * 2 == h_out_group &&
 	       v_in_group == v_out_group) {
       /* Special cases for 2h1v upsampling */
       if (do_fancy && compptr->downsampled_width > 2)
-	upsample->methods[ci] = h2v1_fancy_upsample;
+	upsample->methods[ci] = h2v1_fancy_upsample_xp;
       else
-	upsample->methods[ci] = h2v1_upsample;
+	upsample->methods[ci] = h2v1_upsample_xp;
     } else if (h_in_group * 2 == h_out_group &&
 	       v_in_group * 2 == v_out_group) {
       /* Special cases for 2h2v upsampling */
       if (do_fancy && compptr->downsampled_width > 2) {
-	upsample->methods[ci] = h2v2_fancy_upsample;
+	upsample->methods[ci] = h2v2_fancy_upsample_xp;
 	upsample->pub.need_context_rows = TRUE;
       } else
-	upsample->methods[ci] = h2v2_upsample;
+	upsample->methods[ci] = h2v2_upsample_xp;
     } else if ((h_out_group % h_in_group) == 0 &&
 	       (v_out_group % v_in_group) == 0) {
       /* Generic integral-factors upsampling method */
-      upsample->methods[ci] = int_upsample;
+      upsample->methods[ci] = int_upsample_xp;
       upsample->h_expand[ci] = (UINT8) (h_out_group / h_in_group);
       upsample->v_expand[ci] = (UINT8) (v_out_group / v_in_group);
     } else
       ERREXIT(cinfo, JERR_FRACT_SAMPLE_NOTIMPL);
     if (need_buffer) {
-      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray)
+      upsample->color_buf[ci] = (*cinfo->mem->alloc_sarray_xp)
 	((j_common_ptr) cinfo, JPOOL_IMAGE,
 	 (JDIMENSION) jround_up((long) cinfo->output_width,
 				(long) cinfo->max_h_samp_factor),
diff --git a/jdtrans.c b/xjdtrans.c
similarity index 75%
rename from jdtrans.c
rename to xjdtrans.c
index 6c0ab71..8c45d3e 100644
--- a/jdtrans.c
+++ b/xjdtrans.c
@@ -1,5 +1,5 @@
 /*
- * jdtrans.c
+ * xjdtrans.c
  *
  * Copyright (C) 1995-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -12,11 +12,12 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
+#include "xjerror.h"
 
 
 /* Forward declarations */
-LOCAL(void) transdecode_master_selection JPP((j_decompress_ptr cinfo));
+LOCAL(void) transdecode_master_selection_xp JPP((j_decompress_ptr cinfo));
 
 
 /*
@@ -42,11 +43,18 @@ LOCAL(void) transdecode_master_selection JPP((j_decompress_ptr cinfo));
  */
 
 GLOBAL(jvirt_barray_ptr *)
-jpeg_read_coefficients (j_decompress_ptr cinfo)
+jpeg_read_coefficients_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  /* Can't read coefficients from lossless streams */
+  if (xinfo->lossless_xp) {
+    ERREXIT(cinfo, JERR_CANT_TRANSCODE);
+    return NULL;
+  }
+
   if (cinfo->global_state == DSTATE_READY) {
     /* First call: initialize active modules */
-    transdecode_master_selection(cinfo);
+    transdecode_master_selection_xp(cinfo);
     cinfo->global_state = DSTATE_RDCOEFS;
   }
   if (cinfo->global_state == DSTATE_RDCOEFS) {
@@ -57,7 +65,7 @@ jpeg_read_coefficients (j_decompress_ptr cinfo)
       if (cinfo->progress != NULL)
 	(*cinfo->progress->progress_monitor) ((j_common_ptr) cinfo);
       /* Absorb some more input */
-      retcode = (*cinfo->inputctl->consume_input) (cinfo);
+      retcode = (*xinfo->inputctl_xp->consume_input_xp) (cinfo);
       if (retcode == JPEG_SUSPENDED)
 	return NULL;
       if (retcode == JPEG_REACHED_EOI)
@@ -80,7 +88,7 @@ jpeg_read_coefficients (j_decompress_ptr cinfo)
    */
   if ((cinfo->global_state == DSTATE_STOPPING ||
        cinfo->global_state == DSTATE_BUFIMAGE) && cinfo->buffered_image) {
-    return cinfo->coef->coef_arrays;
+    return xinfo->coef_xp->coef_arrays;
   }
   /* Oops, improper usage */
   ERREXIT1(cinfo, JERR_BAD_STATE, cinfo->global_state);
@@ -94,33 +102,42 @@ jpeg_read_coefficients (j_decompress_ptr cinfo)
  */
 
 LOCAL(void)
-transdecode_master_selection (j_decompress_ptr cinfo)
+transdecode_master_selection_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   /* This is effectively a buffered-image operation. */
   cinfo->buffered_image = TRUE;
 
-  /* Entropy decoding: either Huffman or arithmetic coding. */
-  if (cinfo->arith_code) {
-    ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
-  } else {
-    if (cinfo->progressive_mode) {
+  if (xinfo->lossless_xp)
+  {
+    /* Initialize decompression codec */
+    jinit_d_codec_xp(cinfo);
+  }
+  else
+  {
+    /* Entropy decoding: either Huffman or arithmetic coding. */
+    if (cinfo->arith_code) {
+      ERREXIT(cinfo, JERR_ARITH_NOTIMPL);
+    } else {
+      if (cinfo->progressive_mode) {
 #ifdef D_PROGRESSIVE_SUPPORTED
-      jinit_phuff_decoder(cinfo);
+        jinit_phuff_decoder_xp(cinfo);
 #else
-      ERREXIT(cinfo, JERR_NOT_COMPILED);
+        ERREXIT(cinfo, JERR_NOT_COMPILED);
 #endif
-    } else
-      jinit_huff_decoder(cinfo);
-  }
+      } else
+        jinit_huff_decoder_xp(cinfo);
+    }
 
-  /* Always get a full-image coefficient buffer. */
-  jinit_d_coef_controller(cinfo, TRUE);
+    /* Always get a full-image coefficient buffer. */
+    jinit_d_coef_controller_xp(cinfo, TRUE);
+  }
 
   /* We can now tell the memory manager to allocate virtual arrays. */
-  (*cinfo->mem->realize_virt_arrays) ((j_common_ptr) cinfo);
+  (*cinfo->mem->realize_virt_arrays_xp) ((j_common_ptr) cinfo);
 
   /* Initialize input side of decompressor to consume first scan. */
-  (*cinfo->inputctl->start_input_pass) (cinfo);
+  (*xinfo->inputctl_xp->start_input_pass_xp) (cinfo);
 
   /* Initialize progress monitoring. */
   if (cinfo->progress != NULL) {
@@ -129,7 +146,7 @@ transdecode_master_selection (j_decompress_ptr cinfo)
     if (cinfo->progressive_mode) {
       /* Arbitrarily estimate 2 interleaved DC scans + 3 AC scans/component. */
       nscans = 2 + 3 * cinfo->num_components;
-    } else if (cinfo->inputctl->has_multiple_scans) {
+    } else if (xinfo->inputctl_xp->has_multiple_scans) {
       /* For a nonprogressive multiscan file, estimate 1 scan per component. */
       nscans = cinfo->num_components;
     } else {
diff --git a/xjerror.h b/xjerror.h
new file mode 100644
index 0000000..fa27933
--- /dev/null
+++ b/xjerror.h
@@ -0,0 +1,66 @@
+/*
+ * xjerror.h
+ *
+ * Copyright (C) 1994-1997, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file defines extended error and message codes for the JPEG library.
+ * It wasn't working out to add these to jerror.h or to have the jpegxp
+ * library have it's own error header file. The wxjpeg library was causing
+ * too many conflicts.
+ * Edit this file to add new codes, or to translate the message strings to
+ * some other language.
+ */
+
+/*
+ * To define the enum list of message codes, include this file without
+ * defining macro JMESSAGE.  To create a message string table, include it
+ * again with a suitable JMESSAGE definition (see jerror.c for an example).
+ */
+#ifndef JMESSAGE
+#ifndef XJERROR_H
+#define XJERROR_H
+/* First time through, define the enum list */
+#define JMAKE_ENUM_LIST
+#else
+/* Repeated inclusions of this file are no-ops unless JMESSAGE is defined */
+#define JMESSAGE(code,string)
+#endif /* XJERROR_H */
+#endif /* JMESSAGE */
+
+#ifdef JMAKE_ENUM_LIST
+
+typedef enum {
+
+#define JMESSAGE(code,string)	code ,
+
+#endif /* JMAKE_ENUM_LIST */
+
+JMESSAGE(JMSG_FIRSTADDONCODE=1000, NULL) /* Must be first entry! */
+
+JMESSAGE(JERR_BAD_DIFF, "spatial difference out of range")
+JMESSAGE(JERR_BAD_LOSSLESS,
+	 "Invalid lossless parameters Ss=%d Se=%d Ah=%d Al=%d")
+JMESSAGE(JERR_BAD_LOSSLESS_SCRIPT,
+	 "Invalid lossless parameters at scan script entry %d")
+JMESSAGE(JERR_BAD_RESTART, "Invalid restart interval: %d, must be an integer multiple of the number of MCUs in an MCU_row (%d)")
+JMESSAGE(JERR_CANT_TRANSCODE,
+	 "Cannot transcode to/from lossless JPEG datastreams")
+JMESSAGE(JERR_NO_LOSSLESS_SCRIPT, "Lossless encoding was requested but no scan script was supplied")
+JMESSAGE(JTRC_UNKNOWN_LOSSLESS_IDS,
+	 "Unrecognized component IDs %d %d %d, assuming RGB")
+JMESSAGE(JWRN_MUST_DOWNSCALE,
+	 "Must downscale data from %d bits to %d")
+JMESSAGE(JERR_BAD_LOSSLESS_PRECISION, "Unsupported lossless JPEG data precision %d")
+
+#ifdef JMAKE_ENUM_LIST
+
+  JMSG_LASTADDONCODE
+} ADDON_MESSAGE_CODE;
+
+#undef JMAKE_ENUM_LIST
+#endif /* JMAKE_ENUM_LIST */
+
+/* Zap JMESSAGE macro so that future re-inclusions do nothing by default */
+#undef JMESSAGE
diff --git a/jfdctflt.c b/xjfdctflt.c
similarity index 97%
rename from jfdctflt.c
rename to xjfdctflt.c
index 79d7a00..152eee8 100644
--- a/jfdctflt.c
+++ b/xjfdctflt.c
@@ -1,5 +1,5 @@
 /*
- * jfdctflt.c
+ * xjfdctflt.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -36,8 +36,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 #ifdef DCT_FLOAT_SUPPORTED
 
@@ -56,7 +56,7 @@
  */
 
 GLOBAL(void)
-jpeg_fdct_float (FAST_FLOAT * data)
+jpeg_fdct_float_xp (FAST_FLOAT * data)
 {
   FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   FAST_FLOAT tmp10, tmp11, tmp12, tmp13;
diff --git a/jfdctfst.c b/xjfdctfst.c
similarity index 98%
rename from jfdctfst.c
rename to xjfdctfst.c
index ccb378a..b91d1ab 100644
--- a/jfdctfst.c
+++ b/xjfdctfst.c
@@ -1,5 +1,5 @@
 /*
- * jfdctfst.c
+ * xjfdctfst.c
  *
  * Copyright (C) 1994-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -32,8 +32,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 #ifdef DCT_IFAST_SUPPORTED
 
@@ -111,7 +111,7 @@
  */
 
 GLOBAL(void)
-jpeg_fdct_ifast (DCTELEM * data)
+jpeg_fdct_ifast_xp (DCTELEM * data)
 {
   DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   DCTELEM tmp10, tmp11, tmp12, tmp13;
diff --git a/jfdctint.c b/xjfdctint.c
similarity index 98%
rename from jfdctint.c
rename to xjfdctint.c
index 0a78b64..cecc81c 100644
--- a/jfdctint.c
+++ b/xjfdctint.c
@@ -1,5 +1,5 @@
 /*
- * jfdctint.c
+ * xjfdctint.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -25,8 +25,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 #ifdef DCT_ISLOW_SUPPORTED
 
@@ -74,7 +74,7 @@
  * shows that the values given below are the most effective.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define CONST_BITS  13
 #define PASS1_BITS  2
 #else
@@ -125,7 +125,7 @@
  * For 12-bit samples, a full 32-bit multiplication will be needed.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
 #else
 #define MULTIPLY(var,const)  ((var) * (const))
@@ -137,7 +137,7 @@
  */
 
 GLOBAL(void)
-jpeg_fdct_islow (DCTELEM * data)
+jpeg_fdct_islow_xp (DCTELEM * data)
 {
   INT32 tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   INT32 tmp10, tmp11, tmp12, tmp13;
diff --git a/jidctflt.c b/xjidctflt.c
similarity index 95%
rename from jidctflt.c
rename to xjidctflt.c
index 0188ce3..3095f78 100644
--- a/jidctflt.c
+++ b/xjidctflt.c
@@ -1,5 +1,5 @@
 /*
- * jidctflt.c
+ * xjidctflt.c
  *
  * Copyright (C) 1994-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -38,8 +38,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 #ifdef DCT_FLOAT_SUPPORTED
 
@@ -65,18 +65,19 @@
  */
 
 GLOBAL(void)
-jpeg_idct_float (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+jpeg_idct_float_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
 		 JCOEFPTR coef_block,
-		 JSAMPARRAY output_buf, JDIMENSION output_col)
+		 JSAMPARRAYXP output_buf, JDIMENSION output_col)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   FAST_FLOAT tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   FAST_FLOAT tmp10, tmp11, tmp12, tmp13;
   FAST_FLOAT z5, z10, z11, z12, z13;
   JCOEFPTR inptr;
   FLOAT_MULT_TYPE * quantptr;
   FAST_FLOAT * wsptr;
-  JSAMPROW outptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
+  JSAMPROWXP outptr;
+  JSAMPLEXP *range_limit = IDCT_range_limit(xinfo);
   int ctr;
   FAST_FLOAT workspace[DCTSIZE2]; /* buffers data between passes */
   SHIFT_TEMPS
diff --git a/jidctfst.c b/xjidctfst.c
similarity index 96%
rename from jidctfst.c
rename to xjidctfst.c
index dba4216..81ddf1d 100644
--- a/jidctfst.c
+++ b/xjidctfst.c
@@ -1,5 +1,5 @@
 /*
- * jidctfst.c
+ * xjidctfst.c
  *
  * Copyright (C) 1994-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -34,8 +34,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 #ifdef DCT_IFAST_SUPPORTED
 
@@ -73,7 +73,7 @@
  * are fewer one-bits in the constants).
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define CONST_BITS  8
 #define PASS1_BITS  2
 #else
@@ -125,7 +125,7 @@
  * declared INT32, so a 32-bit multiply will be used.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define DEQUANTIZE(coef,quantval)  (((IFAST_MULT_TYPE) (coef)) * (quantval))
 #else
 #define DEQUANTIZE(coef,quantval)  \
@@ -139,7 +139,7 @@
 
 #ifdef RIGHT_SHIFT_IS_UNSIGNED
 #define ISHIFT_TEMPS	DCTELEM ishift_temp;
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define DCTELEMBITS  16		/* DCTELEM may be 16 or 32 bits */
 #else
 #define DCTELEMBITS  32		/* DCTELEM must be 32 bits */
@@ -165,18 +165,19 @@
  */
 
 GLOBAL(void)
-jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+jpeg_idct_ifast_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
 		 JCOEFPTR coef_block,
-		 JSAMPARRAY output_buf, JDIMENSION output_col)
+		 JSAMPARRAYXP output_buf, JDIMENSION output_col)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   DCTELEM tmp0, tmp1, tmp2, tmp3, tmp4, tmp5, tmp6, tmp7;
   DCTELEM tmp10, tmp11, tmp12, tmp13;
   DCTELEM z5, z10, z11, z12, z13;
   JCOEFPTR inptr;
   IFAST_MULT_TYPE * quantptr;
   int * wsptr;
-  JSAMPROW outptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
+  JSAMPROWXP outptr;
+  JSAMPLEXP *range_limit = IDCT_range_limit(xinfo);
   int ctr;
   int workspace[DCTSIZE2];	/* buffers data between passes */
   SHIFT_TEMPS			/* for DESCALE */
@@ -293,7 +294,7 @@ jpeg_idct_ifast (j_decompress_ptr cinfo, jpeg_component_info * compptr,
     if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
       /* AC terms all zero */
-      JSAMPLE dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
+      JSAMPLEXP dcval = range_limit[IDESCALE(wsptr[0], PASS1_BITS+3)
 				  & RANGE_MASK];
       
       outptr[0] = dcval;
diff --git a/jidctint.c b/xjidctint.c
similarity index 96%
rename from jidctint.c
rename to xjidctint.c
index a72b320..fca4652 100644
--- a/jidctint.c
+++ b/xjidctint.c
@@ -1,5 +1,5 @@
 /*
- * jidctint.c
+ * xjidctint.c
  *
  * Copyright (C) 1991-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -27,8 +27,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 #ifdef DCT_ISLOW_SUPPORTED
 
@@ -74,7 +74,7 @@
  * shows that the values given below are the most effective.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define CONST_BITS  13
 #define PASS1_BITS  2
 #else
@@ -125,7 +125,7 @@
  * For 12-bit samples, a full 32-bit multiplication will be needed.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
 #else
 #define MULTIPLY(var,const)  ((var) * (const))
@@ -145,18 +145,19 @@
  */
 
 GLOBAL(void)
-jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+jpeg_idct_islow_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
 		 JCOEFPTR coef_block,
-		 JSAMPARRAY output_buf, JDIMENSION output_col)
+		 JSAMPARRAYXP output_buf, JDIMENSION output_col)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 tmp0, tmp1, tmp2, tmp3;
   INT32 tmp10, tmp11, tmp12, tmp13;
   INT32 z1, z2, z3, z4, z5;
   JCOEFPTR inptr;
   ISLOW_MULT_TYPE * quantptr;
   int * wsptr;
-  JSAMPROW outptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
+  JSAMPROWXP outptr;
+  JSAMPLEXP *range_limit = IDCT_range_limit(xinfo);
   int ctr;
   int workspace[DCTSIZE2];	/* buffers data between passes */
   SHIFT_TEMPS
@@ -288,7 +289,7 @@ jpeg_idct_islow (j_decompress_ptr cinfo, jpeg_component_info * compptr,
     if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 && wsptr[4] == 0 &&
 	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
       /* AC terms all zero */
-      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
+      JSAMPLEXP dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 				  & RANGE_MASK];
       
       outptr[0] = dcval;
diff --git a/jidctred.c b/xjidctred.c
similarity index 91%
rename from jidctred.c
rename to xjidctred.c
index 421f3c7..d1824f1 100644
--- a/jidctred.c
+++ b/xjidctred.c
@@ -1,5 +1,5 @@
 /*
- * jidctred.c
+ * xjidctred.c
  *
  * Copyright (C) 1994-1998, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -22,8 +22,8 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
-#include "jdct.h"		/* Private declarations for DCT subsystem */
+#include "xjpeglib.h"
+#include "xjdct.h"		/* Private declarations for DCT subsystem */
 
 #ifdef IDCT_SCALING_SUPPORTED
 
@@ -39,7 +39,7 @@
 
 /* Scaling is the same as in jidctint.c. */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define CONST_BITS  13
 #define PASS1_BITS  2
 #else
@@ -94,7 +94,7 @@
  * For 12-bit samples, a full 32-bit multiplication will be needed.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 #define MULTIPLY(var,const)  MULTIPLY16C16(var,const)
 #else
 #define MULTIPLY(var,const)  ((var) * (const))
@@ -115,17 +115,18 @@
  */
 
 GLOBAL(void)
-jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+jpeg_idct_4x4_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
 	       JCOEFPTR coef_block,
-	       JSAMPARRAY output_buf, JDIMENSION output_col)
+	       JSAMPARRAYXP output_buf, JDIMENSION output_col)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 tmp0, tmp2, tmp10, tmp12;
   INT32 z1, z2, z3, z4;
   JCOEFPTR inptr;
   ISLOW_MULT_TYPE * quantptr;
   int * wsptr;
-  JSAMPROW outptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
+  JSAMPROWXP outptr;
+  JSAMPLEXP *range_limit = IDCT_range_limit(xinfo);
   int ctr;
   int workspace[DCTSIZE*4];	/* buffers data between passes */
   SHIFT_TEMPS
@@ -202,7 +203,7 @@ jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
     if (wsptr[1] == 0 && wsptr[2] == 0 && wsptr[3] == 0 &&
 	wsptr[5] == 0 && wsptr[6] == 0 && wsptr[7] == 0) {
       /* AC terms all zero */
-      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
+      JSAMPLEXP dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 				  & RANGE_MASK];
       
       outptr[0] = dcval;
@@ -268,16 +269,17 @@ jpeg_idct_4x4 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 GLOBAL(void)
-jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+jpeg_idct_2x2_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
 	       JCOEFPTR coef_block,
-	       JSAMPARRAY output_buf, JDIMENSION output_col)
+	       JSAMPARRAYXP output_buf, JDIMENSION output_col)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   INT32 tmp0, tmp10, z1;
   JCOEFPTR inptr;
   ISLOW_MULT_TYPE * quantptr;
   int * wsptr;
-  JSAMPROW outptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
+  JSAMPROWXP outptr;
+  JSAMPLEXP *range_limit = IDCT_range_limit(xinfo);
   int ctr;
   int workspace[DCTSIZE*2];	/* buffers data between passes */
   SHIFT_TEMPS
@@ -334,7 +336,7 @@ jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
 #ifndef NO_ZERO_ROW_TEST
     if (wsptr[1] == 0 && wsptr[3] == 0 && wsptr[5] == 0 && wsptr[7] == 0) {
       /* AC terms all zero */
-      JSAMPLE dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
+      JSAMPLEXP dcval = range_limit[(int) DESCALE((INT32) wsptr[0], PASS1_BITS+3)
 				  & RANGE_MASK];
       
       outptr[0] = dcval;
@@ -376,13 +378,14 @@ jpeg_idct_2x2 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
  */
 
 GLOBAL(void)
-jpeg_idct_1x1 (j_decompress_ptr cinfo, jpeg_component_info * compptr,
+jpeg_idct_1x1_xp (j_decompress_ptr cinfo, jpeg_component_info * compptr,
 	       JCOEFPTR coef_block,
-	       JSAMPARRAY output_buf, JDIMENSION output_col)
+	       JSAMPARRAYXP output_buf, JDIMENSION output_col)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int dcval;
   ISLOW_MULT_TYPE * quantptr;
-  JSAMPLE *range_limit = IDCT_range_limit(cinfo);
+  JSAMPLEXP *range_limit = IDCT_range_limit(xinfo);
   SHIFT_TEMPS
 
   /* We hardly need an inverse DCT routine for this: just take the
diff --git a/jmemmgr.c b/xjmemmgr.c
similarity index 92%
rename from jmemmgr.c
rename to xjmemmgr.c
index d801b32..6e0571b 100644
--- a/jmemmgr.c
+++ b/xjmemmgr.c
@@ -1,5 +1,5 @@
 /*
- * jmemmgr.c
+ * xjmemmgr.c
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -27,7 +27,7 @@
 #define JPEG_INTERNALS
 #define AM_MEMORY_MANAGER	/* we define jvirt_Xarray_control structs */
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 #include "jmemsys.h"		/* import the system-dependent declarations */
 
 #ifndef NO_GETENV
@@ -42,11 +42,12 @@ extern char * getenv JPP((const char * name));
  *   The allocation routines provided here must never return NULL.
  *   They should exit to error_exit if unsuccessful.
  *
- *   It's not a good idea to try to merge the sarray and barray routines,
- *   even though they are textually almost the same, because samples are
- *   usually stored as bytes while coefficients are shorts or ints.  Thus,
- *   in machines where byte pointers have a different representation from
- *   word pointers, the resulting machine code could not be the same.
+ *   It's not a good idea to try to merge the sarray, barray and darray
+ *   routines, even though they are textually almost the same, because
+ *   samples are usually stored as bytes while coefficients and differenced
+ *   are shorts or ints.  Thus, in machines where byte pointers have a
+ *   different representation from word pointers, the resulting machine
+ *   code could not be the same.
  */
 
 
@@ -148,7 +149,7 @@ typedef my_memory_mgr * my_mem_ptr;
  */
 
 struct jvirt_sarray_control {
-  JSAMPARRAY mem_buffer;	/* => the in-memory buffer */
+  JSAMPARRAYXP mem_buffer;	/* => the in-memory buffer */
   JDIMENSION rows_in_array;	/* total virtual array height */
   JDIMENSION samplesperrow;	/* width of array (and of memory buffer) */
   JDIMENSION maxaccess;		/* max rows accessed by access_virt_sarray */
@@ -391,20 +392,20 @@ alloc_large (j_common_ptr cinfo, int pool_id, size_t sizeofobject)
  * a virtual array.
  */
 
-METHODDEF(JSAMPARRAY)
-alloc_sarray (j_common_ptr cinfo, int pool_id,
+METHODDEF(JSAMPARRAYXP)
+alloc_sarray_xp (j_common_ptr cinfo, int pool_id,
 	      JDIMENSION samplesperrow, JDIMENSION numrows)
 /* Allocate a 2-D sample array */
 {
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
-  JSAMPARRAY result;
-  JSAMPROW workspace;
+  JSAMPARRAYXP result;
+  JSAMPROWXP workspace;
   JDIMENSION rowsperchunk, currow, i;
   long ltemp;
 
   /* Calculate max # of rows allowed in one allocation chunk */
   ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
-	  ((long) samplesperrow * SIZEOF(JSAMPLE));
+          ((long) samplesperrow * SIZEOF(JSAMPLEXP));
   if (ltemp <= 0)
     ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
   if (ltemp < (long) numrows)
@@ -414,16 +415,16 @@ alloc_sarray (j_common_ptr cinfo, int pool_id,
   mem->last_rowsperchunk = rowsperchunk;
 
   /* Get space for row pointers (small object) */
-  result = (JSAMPARRAY) alloc_small(cinfo, pool_id,
-				    (size_t) (numrows * SIZEOF(JSAMPROW)));
+  result = (JSAMPARRAYXP) alloc_small(cinfo, pool_id,
+                                 (size_t) (numrows * SIZEOF(JSAMPROWXP)));
 
   /* Get the rows themselves (large objects) */
   currow = 0;
   while (currow < numrows) {
     rowsperchunk = MIN(rowsperchunk, numrows - currow);
-    workspace = (JSAMPROW) alloc_large(cinfo, pool_id,
+    workspace = (JSAMPROWXP) alloc_large(cinfo, pool_id,
 	(size_t) ((size_t) rowsperchunk * (size_t) samplesperrow
-		  * SIZEOF(JSAMPLE)));
+                  * SIZEOF(JSAMPLEXP)));
     for (i = rowsperchunk; i > 0; i--) {
       result[currow++] = workspace;
       workspace += samplesperrow;
@@ -482,6 +483,58 @@ alloc_barray (j_common_ptr cinfo, int pool_id,
 }
 
 
+#ifdef NEED_DARRAY
+
+/*
+ * Creation of 2-D difference arrays.
+ * This is essentially the same as the code for sample arrays, above.
+ */
+
+METHODDEF(JDIFFARRAY)
+alloc_darray (j_common_ptr cinfo, int pool_id,
+	      JDIMENSION diffsperrow, JDIMENSION numrows)
+/* Allocate a 2-D difference array */
+{
+  my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
+  JDIFFARRAY result;
+  JDIFFROW workspace;
+  JDIMENSION rowsperchunk, currow, i;
+  long ltemp;
+
+  /* Calculate max # of rows allowed in one allocation chunk */
+  ltemp = (MAX_ALLOC_CHUNK-SIZEOF(large_pool_hdr)) /
+	  ((long) diffsperrow * SIZEOF(JDIFF));
+  if (ltemp <= 0)
+    ERREXIT(cinfo, JERR_WIDTH_OVERFLOW);
+  if (ltemp < (long) numrows)
+    rowsperchunk = (JDIMENSION) ltemp;
+  else
+    rowsperchunk = numrows;
+  mem->last_rowsperchunk = rowsperchunk;
+
+  /* Get space for row pointers (small object) */
+  result = (JDIFFARRAY) alloc_small(cinfo, pool_id,
+				    (size_t) (numrows * SIZEOF(JDIFFROW)));
+
+  /* Get the rows themselves (large objects) */
+  currow = 0;
+  while (currow < numrows) {
+    rowsperchunk = MIN(rowsperchunk, numrows - currow);
+    workspace = (JDIFFROW) alloc_large(cinfo, pool_id,
+	(size_t) ((size_t) rowsperchunk * (size_t) diffsperrow
+		  * SIZEOF(JDIFF)));
+    for (i = rowsperchunk; i > 0; i--) {
+      result[currow++] = workspace;
+      workspace += diffsperrow;
+    }
+  }
+
+  return result;
+}
+
+#endif
+
+
 /*
  * About virtual array management:
  *
@@ -580,7 +633,7 @@ request_virt_barray (j_common_ptr cinfo, int pool_id, boolean pre_zero,
 
 
 METHODDEF(void)
-realize_virt_arrays (j_common_ptr cinfo)
+  realize_virt_arrays_xp (j_common_ptr cinfo)
 /* Allocate the in-memory buffers for any unrealized virtual arrays */
 {
   my_mem_ptr mem = (my_mem_ptr) cinfo->mem;
@@ -598,9 +651,9 @@ realize_virt_arrays (j_common_ptr cinfo)
   for (sptr = mem->virt_sarray_list; sptr != NULL; sptr = sptr->next) {
     if (sptr->mem_buffer == NULL) { /* if not realized yet */
       space_per_minheight += (long) sptr->maxaccess *
-			     (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
+                             (long) sptr->samplesperrow * SIZEOF(JSAMPLEXP);
       maximum_space += (long) sptr->rows_in_array *
-		       (long) sptr->samplesperrow * SIZEOF(JSAMPLE);
+                       (long) sptr->samplesperrow * SIZEOF(JSAMPLEXP);
     }
   }
   for (bptr = mem->virt_barray_list; bptr != NULL; bptr = bptr->next) {
@@ -648,10 +701,10 @@ realize_virt_arrays (j_common_ptr cinfo)
 	jpeg_open_backing_store(cinfo, & sptr->b_s_info,
 				(long) sptr->rows_in_array *
 				(long) sptr->samplesperrow *
-				(long) SIZEOF(JSAMPLE));
+				(long) SIZEOF(JSAMPLEXP));
 	sptr->b_s_open = TRUE;
       }
-      sptr->mem_buffer = alloc_sarray(cinfo, JPOOL_IMAGE,
+      sptr->mem_buffer = alloc_sarray_xp(cinfo, JPOOL_IMAGE,
 				      sptr->samplesperrow, sptr->rows_in_mem);
       sptr->rowsperchunk = mem->last_rowsperchunk;
       sptr->cur_start_row = 0;
@@ -692,7 +745,7 @@ do_sarray_io (j_common_ptr cinfo, jvirt_sarray_ptr ptr, boolean writing)
 {
   long bytesperrow, file_offset, byte_count, rows, thisrow, i;
 
-  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLE);
+  bytesperrow = (long) ptr->samplesperrow * SIZEOF(JSAMPLEXP);
   file_offset = ptr->cur_start_row * bytesperrow;
   /* Loop to read or write each allocation chunk in mem_buffer */
   for (i = 0; i < (long) ptr->rows_in_mem; i += ptr->rowsperchunk) {
@@ -752,8 +805,8 @@ do_barray_io (j_common_ptr cinfo, jvirt_barray_ptr ptr, boolean writing)
 }
 
 
-METHODDEF(JSAMPARRAY)
-access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
+METHODDEF(JSAMPARRAYXP)
+access_virt_sarray_xp (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
 		    JDIMENSION start_row, JDIMENSION num_rows,
 		    boolean writable)
 /* Access the part of a virtual sample array starting at start_row */
@@ -817,7 +870,7 @@ access_virt_sarray (j_common_ptr cinfo, jvirt_sarray_ptr ptr,
     if (writable)
       ptr->first_undef_row = end_row;
     if (ptr->pre_zero) {
-      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLE);
+      size_t bytesperrow = (size_t) ptr->samplesperrow * SIZEOF(JSAMPLEXP);
       undef_row -= ptr->cur_start_row; /* make indexes relative to buffer */
       end_row -= ptr->cur_start_row;
       while (undef_row < end_row) {
@@ -1025,7 +1078,7 @@ self_destruct (j_common_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_memory_mgr (j_common_ptr cinfo)
+jinit_memory_mgr_xp (j_common_ptr cinfo)
 {
   my_mem_ptr mem;
   long max_to_use;
@@ -1066,12 +1119,15 @@ jinit_memory_mgr (j_common_ptr cinfo)
   /* OK, fill in the method pointers */
   mem->pub.alloc_small = alloc_small;
   mem->pub.alloc_large = alloc_large;
-  mem->pub.alloc_sarray = alloc_sarray;
+  mem->pub.alloc_sarray_xp = alloc_sarray_xp;
   mem->pub.alloc_barray = alloc_barray;
+#ifdef NEED_DARRAY
+  mem->pub.alloc_darray = alloc_darray;
+#endif
   mem->pub.request_virt_sarray = request_virt_sarray;
   mem->pub.request_virt_barray = request_virt_barray;
-  mem->pub.realize_virt_arrays = realize_virt_arrays;
-  mem->pub.access_virt_sarray = access_virt_sarray;
+  mem->pub.realize_virt_arrays_xp = realize_virt_arrays_xp;
+  mem->pub.access_virt_sarray_xp = access_virt_sarray_xp;
   mem->pub.access_virt_barray = access_virt_barray;
   mem->pub.free_pool = free_pool;
   mem->pub.self_destruct = self_destruct;
diff --git a/jpegint.h b/xjpegint.h
similarity index 53%
rename from jpegint.h
rename to xjpegint.h
index 95b00d4..0a1374d 100644
--- a/jpegint.h
+++ b/xjpegint.h
@@ -1,5 +1,5 @@
 /*
- * jpegint.h
+ * xjpegint.h
  *
  * Copyright (C) 1991-1997, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -42,10 +42,10 @@ typedef enum {			/* Operating modes for buffer controllers */
 /* Declarations for compression modules */
 
 /* Master control module */
-struct jpeg_comp_master {
-  JMETHOD(void, prepare_for_pass, (j_compress_ptr cinfo));
-  JMETHOD(void, pass_startup, (j_compress_ptr cinfo));
-  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
+struct jpeg_comp_master_xp {
+  JMETHOD(void, prepare_for_pass_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, pass_startup_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, finish_pass_xp, (j_compress_ptr cinfo));
 
   /* State variables made visible to other modules */
   boolean call_pass_startup;	/* True if pass_startup must be called */
@@ -53,101 +53,101 @@ struct jpeg_comp_master {
 };
 
 /* Main buffer control (downsampled-data buffer) */
-struct jpeg_c_main_controller {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(void, process_data, (j_compress_ptr cinfo,
-			       JSAMPARRAY input_buf, JDIMENSION *in_row_ctr,
+struct jpeg_c_main_controller_xp {
+  JMETHOD(void, start_pass_xp, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, process_data_xp, (j_compress_ptr cinfo,
+			       JSAMPARRAYXP input_buf, JDIMENSION *in_row_ctr,
 			       JDIMENSION in_rows_avail));
 };
 
 /* Compression preprocessing (downsampling input buffer control) */
-struct jpeg_c_prep_controller {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(void, pre_process_data, (j_compress_ptr cinfo,
-				   JSAMPARRAY input_buf,
+struct jpeg_c_prep_controller_xp {
+  JMETHOD(void, start_pass_xp, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, pre_process_data_xp, (j_compress_ptr cinfo,
+				   JSAMPARRAYXP input_buf,
 				   JDIMENSION *in_row_ctr,
 				   JDIMENSION in_rows_avail,
-				   JSAMPIMAGE output_buf,
+				   JSAMPIMAGEXP output_buf,
 				   JDIMENSION *out_row_group_ctr,
 				   JDIMENSION out_row_groups_avail));
 };
 
 /* Coefficient buffer control */
-struct jpeg_c_coef_controller {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(boolean, compress_data, (j_compress_ptr cinfo,
-				   JSAMPIMAGE input_buf));
+struct jpeg_c_coef_controller_xp {
+  JMETHOD(void, start_pass_xp, (j_compress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(boolean, compress_data_xp, (j_compress_ptr cinfo,
+				   JSAMPIMAGEXP input_buf));
 };
 
 /* Colorspace conversion */
-struct jpeg_color_converter {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
-  JMETHOD(void, color_convert, (j_compress_ptr cinfo,
-				JSAMPARRAY input_buf, JSAMPIMAGE output_buf,
+struct jpeg_color_converter_xp {
+  JMETHOD(void, start_pass_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, color_convert_xp, (j_compress_ptr cinfo,
+				JSAMPARRAYXP input_buf, JSAMPIMAGEXP output_buf,
 				JDIMENSION output_row, int num_rows));
 };
 
 /* Downsampling */
-struct jpeg_downsampler {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
-  JMETHOD(void, downsample, (j_compress_ptr cinfo,
-			     JSAMPIMAGE input_buf, JDIMENSION in_row_index,
-			     JSAMPIMAGE output_buf,
+struct jpeg_downsampler_xp {
+  JMETHOD(void, start_pass_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, downsample_xp, (j_compress_ptr cinfo,
+			     JSAMPIMAGEXP input_buf, JDIMENSION in_row_index,
+			     JSAMPIMAGEXP output_buf,
 			     JDIMENSION out_row_group_index));
 
   boolean need_context_rows;	/* TRUE if need rows above & below */
 };
 
 /* Forward DCT (also controls coefficient quantization) */
-struct jpeg_forward_dct {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo));
+struct jpeg_forward_dct_xp {
+  JMETHOD(void, start_pass_xp, (j_compress_ptr cinfo));
   /* perhaps this should be an array??? */
-  JMETHOD(void, forward_DCT, (j_compress_ptr cinfo,
+  JMETHOD(void, forward_DCT_xp, (j_compress_ptr cinfo,
 			      jpeg_component_info * compptr,
-			      JSAMPARRAY sample_data, JBLOCKROW coef_blocks,
+			      JSAMPARRAYXP sample_data, JBLOCKROW coef_blocks,
 			      JDIMENSION start_row, JDIMENSION start_col,
 			      JDIMENSION num_blocks));
 };
 
 /* Entropy encoding */
-struct jpeg_entropy_encoder {
-  JMETHOD(void, start_pass, (j_compress_ptr cinfo, boolean gather_statistics));
-  JMETHOD(boolean, encode_mcu, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
-  JMETHOD(void, finish_pass, (j_compress_ptr cinfo));
+struct jpeg_entropy_encoder_xp {
+  JMETHOD(void, start_pass_xp, (j_compress_ptr cinfo, boolean gather_statistics));
+  JMETHOD(boolean, encode_mcu_xp, (j_compress_ptr cinfo, JBLOCKROW *MCU_data));
+  JMETHOD(void, finish_pass_xp, (j_compress_ptr cinfo));
 };
 
 /* Marker writing */
-struct jpeg_marker_writer {
-  JMETHOD(void, write_file_header, (j_compress_ptr cinfo));
-  JMETHOD(void, write_frame_header, (j_compress_ptr cinfo));
-  JMETHOD(void, write_scan_header, (j_compress_ptr cinfo));
-  JMETHOD(void, write_file_trailer, (j_compress_ptr cinfo));
-  JMETHOD(void, write_tables_only, (j_compress_ptr cinfo));
+struct jpeg_marker_writer_xp {
+  JMETHOD(void, write_file_header_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, write_frame_header_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, write_scan_header_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, write_file_trailer_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, write_tables_only_xp, (j_compress_ptr cinfo));
   /* These routines are exported to allow insertion of extra markers */
   /* Probably only COM and APPn markers should be written this way */
-  JMETHOD(void, write_marker_header, (j_compress_ptr cinfo, int marker,
+  JMETHOD(void, write_marker_header_xp, (j_compress_ptr cinfo, int marker,
 				      unsigned int datalen));
-  JMETHOD(void, write_marker_byte, (j_compress_ptr cinfo, int val));
+  JMETHOD(void, write_marker_byte_xp, (j_compress_ptr cinfo, int val));
 };
 
 
 /* Declarations for decompression modules */
 
 /* Master control module */
-struct jpeg_decomp_master {
-  JMETHOD(void, prepare_for_output_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, finish_output_pass, (j_decompress_ptr cinfo));
+struct jpeg_decomp_master_xp {
+  JMETHOD(void, prepare_for_output_pass_xp, (j_decompress_ptr cinfo));
+  JMETHOD(void, finish_output_pass_xp, (j_decompress_ptr cinfo));
 
   /* State variables made visible to other modules */
   boolean is_dummy_pass;	/* True during 1st pass for 2-pass quant */
 };
 
 /* Input control module */
-struct jpeg_input_controller {
-  JMETHOD(int, consume_input, (j_decompress_ptr cinfo));
-  JMETHOD(void, reset_input_controller, (j_decompress_ptr cinfo));
-  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, finish_input_pass, (j_decompress_ptr cinfo));
+struct jpeg_input_controller_xp {
+  JMETHOD(int, consume_input_xp, (j_decompress_ptr cinfo));
+  JMETHOD(void, reset_input_controller_xp, (j_decompress_ptr cinfo));
+  JMETHOD(void, start_input_pass_xp, (j_decompress_ptr cinfo));
+  JMETHOD(void, finish_input_pass_xp, (j_decompress_ptr cinfo));
 
   /* State variables made visible to other modules */
   boolean has_multiple_scans;	/* True if file has multiple scans */
@@ -155,46 +155,56 @@ struct jpeg_input_controller {
 };
 
 /* Main buffer control (downsampled-data buffer) */
-struct jpeg_d_main_controller {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(void, process_data, (j_decompress_ptr cinfo,
-			       JSAMPARRAY output_buf, JDIMENSION *out_row_ctr,
+struct jpeg_d_main_controller_xp {
+  JMETHOD(void, start_pass_xp, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, process_data_xp, (j_decompress_ptr cinfo,
+			       JSAMPARRAYXP output_buf, JDIMENSION *out_row_ctr,
 			       JDIMENSION out_rows_avail));
 };
 
 /* Coefficient buffer control */
-struct jpeg_d_coef_controller {
-  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
-  JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
-  JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
-  JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
-				 JSAMPIMAGE output_buf));
+struct jpeg_d_coef_controller_xp {
+  JMETHOD(void, start_input_pass_xp, (j_decompress_ptr cinfo));
+  JMETHOD(int, consume_data_xp, (j_decompress_ptr cinfo));
+  JMETHOD(void, start_output_pass_xp, (j_decompress_ptr cinfo));
+  JMETHOD(int, decompress_data_xp, (j_decompress_ptr cinfo,
+				 JSAMPIMAGEXP output_buf));
   /* Pointer to array of coefficient virtual arrays, or NULL if none */
   jvirt_barray_ptr *coef_arrays;
 };
 
 /* Decompression postprocessing (color quantization buffer control) */
-struct jpeg_d_post_controller {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
-  JMETHOD(void, post_process_data, (j_decompress_ptr cinfo,
-				    JSAMPIMAGE input_buf,
+struct jpeg_d_post_controller_xp {
+  JMETHOD(void, start_pass_xp, (j_decompress_ptr cinfo, J_BUF_MODE pass_mode));
+  JMETHOD(void, post_process_data_xp, (j_decompress_ptr cinfo,
+				    JSAMPIMAGEXP input_buf,
 				    JDIMENSION *in_row_group_ctr,
 				    JDIMENSION in_row_groups_avail,
-				    JSAMPARRAY output_buf,
+				    JSAMPARRAYXP output_buf,
 				    JDIMENSION *out_row_ctr,
 				    JDIMENSION out_rows_avail));
 };
 
+/* Decompression codec (decompressor proper) -- lossless only */
+struct jpeg_d_codec_xp {
+  JMETHOD(void, calc_output_dimensions, (j_decompress_ptr cinfo));
+  JMETHOD(void, start_input_pass, (j_decompress_ptr cinfo));
+  JMETHOD(int, consume_data, (j_decompress_ptr cinfo));
+  JMETHOD(void, start_output_pass, (j_decompress_ptr cinfo));
+  JMETHOD(int, decompress_data, (j_decompress_ptr cinfo,
+				 JSAMPIMAGEXP output_buf));
+};
+
 /* Marker reading & parsing */
-struct jpeg_marker_reader {
-  JMETHOD(void, reset_marker_reader, (j_decompress_ptr cinfo));
+struct jpeg_marker_reader_xp {
+  JMETHOD(void, reset_marker_reader_xp, (j_decompress_ptr cinfo));
   /* Read markers until SOS or EOI.
    * Returns same codes as are defined for jpeg_consume_input:
    * JPEG_SUSPENDED, JPEG_REACHED_SOS, or JPEG_REACHED_EOI.
    */
-  JMETHOD(int, read_markers, (j_decompress_ptr cinfo));
+  JMETHOD(int, read_markers_xp, (j_decompress_ptr cinfo));
   /* Read a restart marker --- exported for use by entropy decoder only */
-  jpeg_marker_parser_method read_restart_marker;
+  jpeg_marker_parser_method_xp read_restart_marker;
 
   /* State of marker reader --- nominally internal, but applications
    * supplying COM or APPn handlers might like to know the state.
@@ -206,9 +216,9 @@ struct jpeg_marker_reader {
 };
 
 /* Entropy decoding */
-struct jpeg_entropy_decoder {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-  JMETHOD(boolean, decode_mcu, (j_decompress_ptr cinfo,
+struct jpeg_entropy_decoder_xp {
+  JMETHOD(void, start_pass_xp, (j_decompress_ptr cinfo));
+  JMETHOD(boolean, decode_mcu_xp, (j_decompress_ptr cinfo,
 				JBLOCKROW *MCU_data));
 
   /* This is here to share code between baseline and progressive decoders; */
@@ -217,25 +227,25 @@ struct jpeg_entropy_decoder {
 };
 
 /* Inverse DCT (also performs dequantization) */
-typedef JMETHOD(void, inverse_DCT_method_ptr,
+typedef JMETHOD(void, inverse_DCT_method_ptr_xp,
 		(j_decompress_ptr cinfo, jpeg_component_info * compptr,
 		 JCOEFPTR coef_block,
-		 JSAMPARRAY output_buf, JDIMENSION output_col));
+		 JSAMPARRAYXP output_buf, JDIMENSION output_col));
 
-struct jpeg_inverse_dct {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
+struct jpeg_inverse_dct_xp {
+  JMETHOD(void, start_pass_xp, (j_decompress_ptr cinfo));
   /* It is useful to allow each component to have a separate IDCT method. */
-  inverse_DCT_method_ptr inverse_DCT[MAX_COMPONENTS];
+  inverse_DCT_method_ptr_xp inverse_DCT[MAX_COMPONENTS];
 };
 
 /* Upsampling (note that upsampler must also call color converter) */
-struct jpeg_upsampler {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, upsample, (j_decompress_ptr cinfo,
-			   JSAMPIMAGE input_buf,
+struct jpeg_upsampler_xp {
+  JMETHOD(void, start_pass_xp, (j_decompress_ptr cinfo));
+  JMETHOD(void, upsample_xp, (j_decompress_ptr cinfo,
+			   JSAMPIMAGEXP input_buf,
 			   JDIMENSION *in_row_group_ctr,
 			   JDIMENSION in_row_groups_avail,
-			   JSAMPARRAY output_buf,
+			   JSAMPARRAYXP output_buf,
 			   JDIMENSION *out_row_ctr,
 			   JDIMENSION out_rows_avail));
 
@@ -243,21 +253,21 @@ struct jpeg_upsampler {
 };
 
 /* Colorspace conversion */
-struct jpeg_color_deconverter {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, color_convert, (j_decompress_ptr cinfo,
-				JSAMPIMAGE input_buf, JDIMENSION input_row,
-				JSAMPARRAY output_buf, int num_rows));
+struct jpeg_color_deconverter_xp {
+  JMETHOD(void, start_pass_xp, (j_decompress_ptr cinfo));
+  JMETHOD(void, color_convert_xp, (j_decompress_ptr cinfo,
+				JSAMPIMAGEXP input_buf, JDIMENSION input_row,
+				JSAMPARRAYXP output_buf, int num_rows));
 };
 
 /* Color quantization or color precision reduction */
-struct jpeg_color_quantizer {
-  JMETHOD(void, start_pass, (j_decompress_ptr cinfo, boolean is_pre_scan));
-  JMETHOD(void, color_quantize, (j_decompress_ptr cinfo,
-				 JSAMPARRAY input_buf, JSAMPARRAY output_buf,
+struct jpeg_color_quantizer_xp {
+  JMETHOD(void, start_pass_xp, (j_decompress_ptr cinfo, boolean is_pre_scan));
+  JMETHOD(void, color_quantize_xp, (j_decompress_ptr cinfo,
+				 JSAMPARRAYXP input_buf, JSAMPARRAYXP output_buf,
 				 int num_rows));
-  JMETHOD(void, finish_pass, (j_decompress_ptr cinfo));
-  JMETHOD(void, new_color_map, (j_decompress_ptr cinfo));
+  JMETHOD(void, finish_pass_xp, (j_decompress_ptr cinfo));
+  JMETHOD(void, new_color_map_xp, (j_decompress_ptr cinfo));
 };
 
 
@@ -295,34 +305,36 @@ struct jpeg_color_quantizer {
 
 #ifdef NEED_SHORT_EXTERNAL_NAMES
 #define jinit_compress_master	jICompress
-#define jinit_c_master_control	jICMaster
+#define jinit_c_master_control_xp	jICMasterXp
 #define jinit_c_main_controller	jICMainC
 #define jinit_c_prep_controller	jICPrepC
 #define jinit_c_coef_controller	jICCoefC
-#define jinit_color_converter	jICColor
+#define jinit_color_converter_xp	jICColorXp
 #define jinit_downsampler	jIDownsampler
 #define jinit_forward_dct	jIFDCT
 #define jinit_huff_encoder	jIHEncoder
 #define jinit_phuff_encoder	jIPHEncoder
 #define jinit_marker_writer	jIMWriter
-#define jinit_master_decompress	jIDMaster
+#define jinit_d_codec_xp jIDCodecXp
+#define jinit_lossless_d_codec_xp jILosslsDXp
+#define jinit_master_decompress_xp	jIDMasterXp
 #define jinit_d_main_controller	jIDMainC
 #define jinit_d_coef_controller	jIDCoefC
 #define jinit_d_post_controller	jIDPostC
-#define jinit_input_controller	jIInCtlr
-#define jinit_marker_reader	jIMReader
-#define jinit_huff_decoder	jIHDecoder
-#define jinit_phuff_decoder	jIPHDecoder
-#define jinit_inverse_dct	jIIDCT
-#define jinit_upsampler		jIUpsampler
-#define jinit_color_deconverter	jIDColor
-#define jinit_1pass_quantizer	jI1Quant
-#define jinit_2pass_quantizer	jI2Quant
-#define jinit_merged_upsampler	jIMUpsampler
-#define jinit_memory_mgr	jIMemMgr
+#define jinit_input_controller_xp	jIInCtlrXp
+#define jinit_marker_reader_xp	jIMReaderXp
+#define jinit_huff_decoder_xp	jIHDecoderXp
+#define jinit_phuff_decoder_xp	jIPHDecoderXp
+#define jinit_inverse_dct_xp	jIIDCTXp
+#define jinit_upsampler_xp		jIUpsamplerXp
+#define jinit_color_deconverter_xp	jIDColorXp
+#define jinit_1pass_quantizer_xp	jI1QuantXp
+#define jinit_2pass_quantizer_xp	jI2QuantXp
+#define jinit_merged_upsampler_xp	jIMUpsamplerXp
+#define jinit_memory_mgr_xp	jIMemMgrXp
 #define jdiv_round_up		jDivRound
 #define jround_up		jRound
-#define jcopy_sample_rows	jCopySamples
+#define jcopy_sample_rows_xp	jCopySamplesXp
 #define jcopy_block_row		jCopyBlocks
 #define jzero_far		jZeroFar
 #define jpeg_zigzag_order	jZIGTable
@@ -331,47 +343,49 @@ struct jpeg_color_quantizer {
 
 
 /* Compression module initialization routines */
-EXTERN(void) jinit_compress_master JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_c_master_control JPP((j_compress_ptr cinfo,
+EXTERN(void) jinit_compress_master_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_c_master_control_xp JPP((j_compress_ptr cinfo,
 					 boolean transcode_only));
-EXTERN(void) jinit_c_main_controller JPP((j_compress_ptr cinfo,
+EXTERN(void) jinit_c_main_controller_xp JPP((j_compress_ptr cinfo,
 					  boolean need_full_buffer));
-EXTERN(void) jinit_c_prep_controller JPP((j_compress_ptr cinfo,
+EXTERN(void) jinit_c_prep_controller_xp JPP((j_compress_ptr cinfo,
 					  boolean need_full_buffer));
-EXTERN(void) jinit_c_coef_controller JPP((j_compress_ptr cinfo,
+EXTERN(void) jinit_c_coef_controller_xp JPP((j_compress_ptr cinfo,
 					  boolean need_full_buffer));
-EXTERN(void) jinit_color_converter JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_downsampler JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_forward_dct JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_huff_encoder JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_phuff_encoder JPP((j_compress_ptr cinfo));
-EXTERN(void) jinit_marker_writer JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_color_converter_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_downsampler_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_forward_dct_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_huff_encoder_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_phuff_encoder_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jinit_marker_writer_xp JPP((j_compress_ptr cinfo));
 /* Decompression module initialization routines */
-EXTERN(void) jinit_master_decompress JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_d_main_controller JPP((j_decompress_ptr cinfo,
+EXTERN(void) jinit_d_codec_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_lossless_d_codec_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_master_decompress_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_d_main_controller_xp JPP((j_decompress_ptr cinfo,
 					  boolean need_full_buffer));
-EXTERN(void) jinit_d_coef_controller JPP((j_decompress_ptr cinfo,
+EXTERN(void) jinit_d_coef_controller_xp JPP((j_decompress_ptr cinfo,
 					  boolean need_full_buffer));
-EXTERN(void) jinit_d_post_controller JPP((j_decompress_ptr cinfo,
+EXTERN(void) jinit_d_post_controller_xp JPP((j_decompress_ptr cinfo,
 					  boolean need_full_buffer));
-EXTERN(void) jinit_input_controller JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_marker_reader JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_huff_decoder JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_phuff_decoder JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_inverse_dct JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_upsampler JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_color_deconverter JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_1pass_quantizer JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_2pass_quantizer JPP((j_decompress_ptr cinfo));
-EXTERN(void) jinit_merged_upsampler JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_input_controller_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_marker_reader_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_huff_decoder_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_phuff_decoder_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_inverse_dct_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_upsampler_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_color_deconverter_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_1pass_quantizer_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_2pass_quantizer_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jinit_merged_upsampler_xp JPP((j_decompress_ptr cinfo));
 /* Memory manager initialization */
-EXTERN(void) jinit_memory_mgr JPP((j_common_ptr cinfo));
+EXTERN(void) jinit_memory_mgr_xp JPP((j_common_ptr cinfo));
 
 /* Utility routines in jutils.c */
 EXTERN(long) jdiv_round_up JPP((long a, long b));
 EXTERN(long) jround_up JPP((long a, long b));
-EXTERN(void) jcopy_sample_rows JPP((JSAMPARRAY input_array, int source_row,
-				    JSAMPARRAY output_array, int dest_row,
+EXTERN(void) jcopy_sample_rows_xp JPP((JSAMPARRAYXP input_array, int source_row,
+				    JSAMPARRAYXP output_array, int dest_row,
 				    int num_rows, JDIMENSION num_cols));
 EXTERN(void) jcopy_block_row JPP((JBLOCKROW input_row, JBLOCKROW output_row,
 				  JDIMENSION num_blocks));
@@ -386,7 +400,7 @@ extern const int jpeg_natural_order[]; /* zigzag coef order to natural order */
 
 #ifdef INCOMPLETE_TYPES_BROKEN
 #ifndef AM_MEMORY_MANAGER	/* only jmemmgr.c defines these */
-struct jvirt_sarray_control { long dummy; };
+struct jvirt_sarray_control_xp { long dummy; };
 struct jvirt_barray_control { long dummy; };
 #endif
 #endif /* INCOMPLETE_TYPES_BROKEN */
diff --git a/xjpeglib.h b/xjpeglib.h
new file mode 100644
index 0000000..5a5dc78
--- /dev/null
+++ b/xjpeglib.h
@@ -0,0 +1,392 @@
+/*
+ * xjpeglib.h
+ *
+ * Copyright (C) 1991-1998, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file defines the application interface for the JPEG library.
+ * Most applications using the library need only include this file,
+ * and perhaps jerror.h if they want to know the exact error codes.
+ */
+
+#ifndef XJPEGLIB_H
+#define XJPEGLIB_H
+
+/*
+ * First we include the configuration files that record how this
+ * installation of the JPEG library is set up.  jconfig.h can be
+ * generated automatically for many systems.  jmorecfg.h contains
+ * manual configuration options that most people need not worry about.
+ */
+
+#ifndef JCONFIG_INCLUDED	/* in case jinclude.h already did */
+#include "jconfig.h"		/* widely used configuration options */
+#endif
+#include "jmorecfg.h"		/* seldom changed options */
+#include "jpeglib.h"
+
+
+/* Extended record for a compression instance */
+
+typedef struct {
+  struct jpeg_destination_mgr_xp * dest_xp;  /* Destination for compressed data */
+  /*
+   * Links to compression subobjects (methods and private variables of modules)
+   */
+  struct jpeg_comp_master_xp * master_xp;
+  struct jpeg_c_main_controller_xp * main_xp;
+  struct jpeg_c_prep_controller_xp * prep_xp;
+  struct jpeg_c_coef_controller_xp  * coef_xp;
+  struct jpeg_marker_writer_xp * marker_xp;
+  struct jpeg_color_converter_xp * cconvert_xp;
+  struct jpeg_downsampler_xp * downsample_xp;
+  struct jpeg_forward_dct_xp * fdct_xp;
+  struct jpeg_entropy_encoder_xp * entropy_xp;
+} jpeg_compress_struct_xp;
+
+typedef jpeg_compress_struct_xp * j_compress_ptr_xp;
+
+
+/* Extended record for a decompression instance */
+
+typedef struct {
+  struct jpeg_source_mgr_xp * src_xp;   /* Source of compressed data */
+  JSAMPARRAYXP colormap_xp;		/* The color map as a 2-D pixel array */
+  boolean lossless_xp;		/* TRUE=lossless encoding, FALSE=lossy */
+  int data_unit_xp;		/* size of data unit in samples */
+  JSAMPLEXP * sample_range_limit_xp;    /* table for fast range-limiting */
+  int bits_in_JSAMPLEXP;
+  JSAMPLEXP max_JSAMPLEXP;
+  JSAMPLEXP center_JSAMPLEXP;
+  /*
+   * Links to decompression subobjects (methods, private variables of modules)
+   */
+  struct jpeg_decomp_master_xp * master_xp;
+  struct jpeg_d_main_controller_xp * main_xp;
+  struct jpeg_d_codec_xp * codec_xp; // used for lossless decoding only
+  struct jpeg_d_coef_controller_xp * coef_xp;
+  struct jpeg_d_post_controller_xp * post_xp;
+  struct jpeg_input_controller_xp * inputctl_xp;
+  struct jpeg_marker_reader_xp * marker_xp;
+  struct jpeg_entropy_decoder_xp * entropy_xp;
+  struct jpeg_inverse_dct_xp * idct_xp;
+  struct jpeg_upsampler_xp * upsample_xp;
+  struct jpeg_color_deconverter_xp * cconvert_xp;
+  struct jpeg_color_quantizer_xp * cquantize_xp;
+} jpeg_decompress_struct_xp;
+
+typedef jpeg_decompress_struct_xp * j_decompress_ptr_xp;
+
+
+/* Data destination object for compression */
+
+struct jpeg_destination_mgr_xp {
+  JOCTET * next_output_byte;	/* => next byte to write in buffer */
+  size_t free_in_buffer;	/* # of byte spaces remaining in buffer */
+
+  JMETHOD(void, init_destination_xp, (j_compress_ptr cinfo));
+  JMETHOD(boolean, empty_output_buffer_xp, (j_compress_ptr cinfo));
+  JMETHOD(void, term_destination_xp, (j_compress_ptr cinfo));
+};
+
+
+/* Data source object for decompression */
+
+struct jpeg_source_mgr_xp {
+  const JOCTET * next_input_byte; /* => next byte to read from buffer */
+  size_t bytes_in_buffer;	/* # of bytes remaining in buffer */
+
+  JMETHOD(void, init_source, (j_decompress_ptr cinfo));
+  JMETHOD(boolean, fill_input_buffer, (j_decompress_ptr cinfo));
+  JMETHOD(void, skip_input_data, (j_decompress_ptr cinfo, long num_bytes));
+  JMETHOD(boolean, resync_to_restart_xp, (j_decompress_ptr cinfo, int desired));
+  JMETHOD(void, term_source, (j_decompress_ptr cinfo));
+};
+/* Routine signature for application-supplied marker processing methods.
+ * Need not pass marker code since it is stored in cinfo->unread_marker.
+ */
+typedef JMETHOD(boolean, jpeg_marker_parser_method_xp, (j_decompress_ptr cinfo));
+
+
+/* Declarations for routines called by application.
+ * The JPP macro hides prototype parameters from compilers that can't cope.
+ * Note JPP requires double parentheses.
+ */
+
+#ifdef HAVE_PROTOTYPES
+#define JPP(arglist)	arglist
+#else
+#define JPP(arglist)	()
+#endif
+
+
+/* Short forms of external names for systems with brain-damaged linkers.
+ * We shorten external names to be unique in the first six letters, which
+ * is good enough for all known systems.
+ * (If your compiler itself needs names to be unique in less than 15 
+ * characters, you are out of luck.  Get a better compiler.)
+ */
+
+#ifdef NEED_SHORT_EXTERNAL_NAMES
+#define jpeg_std_error_xp		jStdErrXp
+#define jpeg_CreateCompress_xp	jCreaCmpXp
+#define jpeg_CreateDecompress_xp	jCreaDecXp
+#define jpeg_destroy_compress_xp	jDestCmpXp
+#define jpeg_destroy_decompress_xp	jDestDecXp
+#define jpeg_stdio_dest_xp		jStdDestXp
+#define jpeg_stdio_src_xp	jStdSrcXp
+#define jpeg_set_defaults_xp	jSetDefaultsXp
+#define jpeg_set_colorspace_xp	jSetColorspXp
+#define jpeg_default_colorspace_xp	jDefColorspXp
+#define jpeg_set_quality_xp	jSetQualityXp
+#define jpeg_set_linear_quality_xp	jSetLQualityXp
+#define jpeg_add_quant_table_xp	jAddQuantTableXp
+#define jpeg_quality_scaling	jQualityScaling
+#define jpeg_simple_progression_xp	jSimProgressXp
+#define jpeg_suppress_tables_xp	jSuppressTablesXp
+//#define jpeg_alloc_quant_table_xp	jAlcQTableXp
+//#define jpeg_alloc_huff_table_xp	jAlcHTableXp
+#define jpeg_start_compress_xp	jStrtCompressXp
+#define jpeg_write_scanlines_xp	jWrtScanlinesXp
+#define jpeg_finish_compress_xp	jFinCompressXp
+#define jpeg_write_raw_data_xp	jWrtRawDataXp
+#define jpeg_write_marker_xp	jWrtMarkerXp
+#define jpeg_write_m_header_xp	jWrtMHeaderXp
+#define jpeg_write_m_byte_xp	jWrtMByteXp
+#define jpeg_write_tables_xp	jWrtTablesXp
+#define jpeg_read_header_xp	jReadHeaderXp
+#define jpeg_start_decompress_xp	jStrtDecompressXp
+#define jpeg_read_scanlines_xp	jReadScanlinesXp
+#define jpeg_finish_decompress_xp	jFinDecompressXp
+#define jpeg_read_raw_data_xp	jReadRawDataXp
+#define jpeg_has_multiple_scans_xp	jHasMultScnXp
+#define jpeg_start_output_xp	jStrtOutputXp
+#define jpeg_finish_output_xp	jFinOutputXp
+#define jpeg_input_complete_xp	jInCompleteXp
+#define jpeg_new_colormap_xp	jNewCMapXp
+#define jpeg_consume_input_xp	jConsumeInputXp
+#define jpeg_calc_output_dimensions_xp	jCalcDimsXp
+#define jpeg_save_markers_xp	jSaveMarkersXp
+#define jpeg_set_marker_processor_xp	jSetMarkerXp
+#define jpeg_read_coefficients_xp	jReadCoefsXp
+#define jpeg_write_coefficients_xp	jWrtCoefsXp
+#define jpeg_copy_critical_parameters_xp	jCopyCritXp
+#define jpeg_abort_compress_xp	jAbrtCmpXp
+#define jpeg_abort_decompress_xp	jAbrtDecXp
+#define jpeg_abort_xp		jAbortXp
+#define jpeg_destroy_xp		jDestroyXp
+#define jpeg_resync_to_restart_xp	jResyncRestartXp
+#endif /* NEED_SHORT_EXTERNAL_NAMES */
+
+
+/* Initialization of JPEG compression objects.
+ * jpeg_create_compress() and jpeg_create_decompress() are the exported
+ * names that applications should call.  These expand to calls on
+ * jpeg_CreateCompress and jpeg_CreateDecompress with additional information
+ * passed for version mismatch checking.
+ * NB: you must set up the error-manager BEFORE calling jpeg_create_xxx.
+ */
+#define jpeg_create_compress_xp(cinfo) \
+    jpeg_CreateCompress_xp((cinfo), JPEG_LIB_VERSION, \
+			(size_t) sizeof(struct jpeg_compress_struct))
+#define jpeg_create_decompress_xp(cinfo) \
+    jpeg_CreateDecompress_xp((cinfo), JPEG_LIB_VERSION, \
+			  (size_t) sizeof(struct jpeg_decompress_struct))
+EXTERN(void) jpeg_CreateCompress_xp JPP((j_compress_ptr cinfo,
+				      int version, size_t structsize));
+EXTERN(void) jpeg_CreateDecompress_xp JPP((j_decompress_ptr cinfo,
+					int version, size_t structsize));
+/* Destruction of JPEG compression objects */
+EXTERN(void) jpeg_destroy_compress_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_destroy_decompress_xp JPP((j_decompress_ptr cinfo));
+
+/* Standard data source and destination managers: stdio streams. */
+/* Caller is responsible for opening the file before and closing after. */
+EXTERN(void) jpeg_stdio_dest_xp JPP((j_compress_ptr cinfo, FILE * outfile));
+EXTERN(void) jpeg_stdio_src_xp JPP((j_decompress_ptr cinfo, FILE * infile));
+
+/* Default parameter setup for compression */
+EXTERN(void) jpeg_set_defaults_xp JPP((j_compress_ptr cinfo));
+/* Compression parameter setup aids */
+EXTERN(void) jpeg_set_colorspace_xp JPP((j_compress_ptr cinfo,
+				      J_COLOR_SPACE colorspace));
+EXTERN(void) jpeg_default_colorspace_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_set_quality_xp JPP((j_compress_ptr cinfo, int quality,
+				   boolean force_baseline));
+EXTERN(void) jpeg_set_linear_quality_xp JPP((j_compress_ptr cinfo,
+					  int scale_factor,
+					  boolean force_baseline));
+EXTERN(void) jpeg_add_quant_table_xp JPP((j_compress_ptr cinfo, int which_tbl,
+				       const unsigned int *basic_table,
+				       int scale_factor,
+				       boolean force_baseline));
+EXTERN(int) jpeg_quality_scaling JPP((int quality));
+EXTERN(void) jpeg_simple_progression_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_suppress_tables_xp JPP((j_compress_ptr cinfo,
+				       boolean suppress));
+//EXTERN(JQUANT_TBL *) jpeg_alloc_quant_table_xp JPP((j_common_ptr cinfo));
+//EXTERN(JHUFF_TBL *) jpeg_alloc_huff_table_xp JPP((j_common_ptr cinfo));
+
+/* Main entry points for compression */
+EXTERN(void) jpeg_start_compress_xp JPP((j_compress_ptr cinfo,
+				      boolean write_all_tables));
+EXTERN(JDIMENSION) jpeg_write_scanlines_xp JPP((j_compress_ptr cinfo,
+					     JSAMPARRAYXP scanlines,
+					     JDIMENSION num_lines));
+EXTERN(void) jpeg_finish_compress_xp JPP((j_compress_ptr cinfo));
+
+/* Replaces jpeg_write_scanlines when writing raw downsampled data. */
+EXTERN(JDIMENSION) jpeg_write_raw_data_xp JPP((j_compress_ptr cinfo,
+					    JSAMPIMAGEXP data,
+					    JDIMENSION num_lines));
+
+/* Write a special marker.  See libjpeg.doc concerning safe usage. */
+EXTERN(void) jpeg_write_marker_xp
+	JPP((j_compress_ptr cinfo, int marker,
+	     const JOCTET * dataptr, unsigned int datalen));
+/* Same, but piecemeal. */
+EXTERN(void) jpeg_write_m_header_xp
+	JPP((j_compress_ptr cinfo, int marker, unsigned int datalen));
+EXTERN(void) jpeg_write_m_byte_xp
+	JPP((j_compress_ptr cinfo, int val));
+
+/* Alternate compression function: just write an abbreviated table file */
+EXTERN(void) jpeg_write_tables_xp JPP((j_compress_ptr cinfo));
+
+/* Decompression startup: read start of JPEG datastream to see what's there */
+EXTERN(int) jpeg_read_header_xp JPP((j_decompress_ptr cinfo,
+				  boolean require_image));
+/* Return value is one of: */
+#define JPEG_SUSPENDED		0 /* Suspended due to lack of input data */
+#define JPEG_HEADER_OK		1 /* Found valid image datastream */
+#define JPEG_HEADER_TABLES_ONLY	2 /* Found valid table-specs-only datastream */
+/* If you pass require_image = TRUE (normal case), you need not check for
+ * a TABLES_ONLY return code; an abbreviated file will cause an error exit.
+ * JPEG_SUSPENDED is only possible if you use a data source module that can
+ * give a suspension return (the stdio source module doesn't).
+ */
+
+/* Main entry points for decompression */
+EXTERN(boolean) jpeg_start_decompress_xp JPP((j_decompress_ptr cinfo));
+EXTERN(JDIMENSION) jpeg_read_scanlines_xp JPP((j_decompress_ptr cinfo,
+					    JSAMPARRAYXP scanlines,
+					    JDIMENSION max_lines));
+EXTERN(boolean) jpeg_finish_decompress_xp JPP((j_decompress_ptr cinfo));
+
+/* Replaces jpeg_read_scanlines when reading raw downsampled data. */
+EXTERN(JDIMENSION) jpeg_read_raw_data_xp JPP((j_decompress_ptr cinfo,
+					   JSAMPIMAGEXP data,
+					   JDIMENSION max_lines));
+
+/* Additional entry points for buffered-image mode. */
+EXTERN(boolean) jpeg_has_multiple_scans_xp JPP((j_decompress_ptr cinfo));
+EXTERN(boolean) jpeg_start_output_xp JPP((j_decompress_ptr cinfo,
+				       int scan_number));
+EXTERN(boolean) jpeg_finish_output_xp JPP((j_decompress_ptr cinfo));
+EXTERN(boolean) jpeg_input_complete_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jpeg_new_colormap_xp JPP((j_decompress_ptr cinfo));
+EXTERN(int) jpeg_consume_input_xp JPP((j_decompress_ptr cinfo));
+/* Return value is one of: */
+/* #define JPEG_SUSPENDED	0    Suspended due to lack of input data */
+#define JPEG_REACHED_SOS	1 /* Reached start of new scan */
+#define JPEG_REACHED_EOI	2 /* Reached end of image */
+#define JPEG_ROW_COMPLETED	3 /* Completed one iMCU row */
+#define JPEG_SCAN_COMPLETED	4 /* Completed last iMCU row of a scan */
+
+/* Precalculate output dimensions for current decompression parameters. */
+EXTERN(void) jpeg_calc_output_dimensions_xp JPP((j_decompress_ptr cinfo));
+
+/* Control saving of COM and APPn markers into marker_list. */
+EXTERN(void) jpeg_save_markers_xp
+	JPP((j_decompress_ptr cinfo, int marker_code,
+	     unsigned int length_limit));
+
+/* Install a special processing method for COM or APPn markers. */
+EXTERN(void) jpeg_set_marker_processor_xp
+	JPP((j_decompress_ptr cinfo, int marker_code,
+	     jpeg_marker_parser_method_xp routine));
+
+/* Read or write raw DCT coefficients --- useful for lossless transcoding. */
+EXTERN(jvirt_barray_ptr *) jpeg_read_coefficients_xp JPP((j_decompress_ptr cinfo));
+EXTERN(void) jpeg_write_coefficients_xp JPP((j_compress_ptr cinfo,
+					  jvirt_barray_ptr * coef_arrays));
+EXTERN(void) jpeg_copy_critical_parameters_xp JPP((j_decompress_ptr srcinfo,
+						j_compress_ptr dstinfo));
+
+/* If you choose to abort compression or decompression before completing
+ * jpeg_finish_(de)compress, then you need to clean up to release memory,
+ * temporary files, etc.  You can just call jpeg_destroy_(de)compress
+ * if you're done with the JPEG object, but if you want to clean it up and
+ * reuse it, call this:
+ */
+EXTERN(void) jpeg_abort_compress_xp JPP((j_compress_ptr cinfo));
+EXTERN(void) jpeg_abort_decompress_xp JPP((j_decompress_ptr cinfo));
+
+/* Generic versions of jpeg_abort and jpeg_destroy that work on either
+ * flavor of JPEG object.  These may be more convenient in some places.
+ */
+EXTERN(void) jpeg_abort_xp JPP((j_common_ptr cinfo));
+EXTERN(void) jpeg_destroy_xp JPP((j_common_ptr cinfo));
+
+/* Default restart-marker-resync procedure for use by data source modules */
+EXTERN(boolean) jpeg_resync_to_restart_xp JPP((j_decompress_ptr cinfo,
+					    int desired));
+
+
+/* These marker codes are exported since applications and data source modules
+ * are likely to want to use them.
+ */
+
+#define JPEG_RST0	0xD0	/* RST0 marker code */
+#define JPEG_EOI	0xD9	/* EOI marker code */
+#define JPEG_APP0	0xE0	/* APP0 marker code */
+#define JPEG_COM	0xFE	/* COM marker code */
+
+
+/* If we have a brain-damaged compiler that emits warnings (or worse, errors)
+ * for structure definitions that are never filled in, keep it quiet by
+ * supplying dummy definitions for the various substructures.
+ */
+
+#ifdef INCOMPLETE_TYPES_BROKEN
+#ifndef JPEG_INTERNALS		/* will be defined in jpegint.h */
+struct jvirt_sarray_control_xp { long dummy; };
+struct jvirt_barray_control { long dummy; };
+struct jpeg_comp_master_xp { long dummy; };
+struct jpeg_c_main_controller_xp { long dummy; };
+struct jpeg_c_prep_controller_xp { long dummy; };
+struct jpeg_c_coef_controller_xp { long dummy; };
+struct jpeg_marker_writer_xp { long dummy; };
+struct jpeg_color_converter_xp { long dummy; };
+struct jpeg_downsampler_xp { long dummy; };
+struct jpeg_forward_dct_xp { long dummy; };
+struct jpeg_entropy_encoder_xp { long dummy; };
+struct jpeg_decomp_master_xp { long dummy; };
+struct jpeg_d_main_controller_xp { long dummy; };
+struct jpeg_d_coef_controller_xp { long dummy; };
+struct jpeg_d_post_controller_xp { long dummy; };
+struct jpeg_input_controller_xp { long dummy; };
+struct jpeg_marker_reader_xp { long dummy; };
+struct jpeg_entropy_decoder_xp { long dummy; };
+struct jpeg_inverse_dct_xp { long dummy; };
+struct jpeg_upsampler_xp { long dummy; };
+struct jpeg_color_deconverter_xp { long dummy; };
+struct jpeg_color_quantizer_xp { long dummy; };
+#endif /* JPEG_INTERNALS */
+#endif /* INCOMPLETE_TYPES_BROKEN */
+
+
+/*
+ * The JPEG library modules define JPEG_INTERNALS before including this file.
+ * The internal structure declarations are read only when that is true.
+ * Applications using the library should not include jpegint.h, but may wish
+ * to include jerror.h.
+ */
+
+#ifdef JPEG_INTERNALS
+#include "xjpegint.h"		/* fetch private declarations */
+#include "jerror.h"		  /* fetch error codes too */
+#endif
+
+#endif /* XJPEGLIB_H */
diff --git a/jquant1.c b/xjquant1.c
similarity index 81%
rename from jquant1.c
rename to xjquant1.c
index b2f96aa..bc6f786 100644
--- a/jquant1.c
+++ b/xjquant1.c
@@ -1,5 +1,5 @@
 /*
- * jquant1.c
+ * xjquant1.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -12,7 +12,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 #ifdef QUANT_1PASS_SUPPORTED
 
@@ -124,7 +124,7 @@ static const UINT8 base_dither_matrix[ODITHER_SIZE][ODITHER_SIZE] = {
  * segment to hold the error array; so it is allocated with alloc_large.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 typedef INT16 FSERROR;		/* 16 bits should be enough */
 typedef int LOCFSERROR;		/* use 'int' for calculation temps */
 #else
@@ -140,13 +140,13 @@ typedef FSERROR FAR *FSERRPTR;	/* pointer to error array (in FAR storage!) */
 #define MAX_Q_COMPS 4		/* max components I can handle */
 
 typedef struct {
-  struct jpeg_color_quantizer pub; /* public fields */
+  struct jpeg_color_quantizer_xp pub; /* public fields */
 
   /* Initially allocated colormap is saved here */
-  JSAMPARRAY sv_colormap;	/* The color map as a 2-D pixel array */
+  JSAMPARRAYXP sv_colormap;	/* The color map as a 2-D pixel array */
   int sv_actual;		/* number of entries in use */
 
-  JSAMPARRAY colorindex;	/* Precomputed mapping for speed */
+  JSAMPARRAYXP colorindex;	/* Precomputed mapping for speed */
   /* colorindex[i][j] = index of color closest to pixel value j in component i,
    * premultiplied as described above.  Since colormap indexes must fit into
    * JSAMPLEs, the entries of this array will too.
@@ -183,7 +183,7 @@ typedef my_cquantizer * my_cquantize_ptr;
 
 
 LOCAL(int)
-select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
+select_ncolors_xp (j_decompress_ptr cinfo, int Ncolors[])
 /* Determine allocation of desired colors to components, */
 /* and fill in Ncolors[] array to indicate choice. */
 /* Return value is total number of colors (product of Ncolors[] values). */
@@ -242,7 +242,7 @@ select_ncolors (j_decompress_ptr cinfo, int Ncolors[])
 
 
 LOCAL(int)
-output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
+output_value_xp (j_decompress_ptr cinfo, int ci, int j, int maxj)
 /* Return j'th output value, where j will range from 0 to maxj */
 /* The output values must fall in 0..MAXJSAMPLE in increasing order */
 {
@@ -251,17 +251,17 @@ output_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
    * (Forcing the upper and lower values to the limits ensures that
    * dithering can't produce a color outside the selected gamut.)
    */
-  return (int) (((INT32) j * MAXJSAMPLE + maxj/2) / maxj);
+  return (int) (((INT32) j * MAXJSAMPLE12 + maxj/2) / maxj);
 }
 
 
 LOCAL(int)
-largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
+largest_input_value_xp (j_decompress_ptr cinfo, int ci, int j, int maxj)
 /* Return largest input value that should map to j'th output value */
 /* Must have largest(j=0) >= 0, and largest(j=maxj) >= MAXJSAMPLE */
 {
   /* Breakpoints are halfway between values returned by output_value */
-  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE + maxj) / (2*maxj));
+  return (int) (((INT32) (2*j + 1) * MAXJSAMPLE12 + maxj) / (2*maxj));
 }
 
 
@@ -270,15 +270,16 @@ largest_input_value (j_decompress_ptr cinfo, int ci, int j, int maxj)
  */
 
 LOCAL(void)
-create_colormap (j_decompress_ptr cinfo)
+create_colormap_xp (j_decompress_ptr cinfo)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
-  JSAMPARRAY colormap;		/* Created colormap */
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
+  JSAMPARRAYXP colormap;		/* Created colormap */
   int total_colors;		/* Number of distinct output colors */
   int i,j,k, nci, blksize, blkdist, ptr, val;
 
   /* Select number of colors for each component */
-  total_colors = select_ncolors(cinfo, cquantize->Ncolors);
+  total_colors = select_ncolors_xp(cinfo, cquantize->Ncolors);
 
   /* Report selected color counts */
   if (cinfo->out_color_components == 3)
@@ -292,7 +293,7 @@ create_colormap (j_decompress_ptr cinfo)
   /* The colors are ordered in the map in standard row-major order, */
   /* i.e. rightmost (highest-indexed) color changes most rapidly. */
 
-  colormap = (*cinfo->mem->alloc_sarray)
+  colormap = (*cinfo->mem->alloc_sarray_xp)
     ((j_common_ptr) cinfo, JPOOL_IMAGE,
      (JDIMENSION) total_colors, (JDIMENSION) cinfo->out_color_components);
 
@@ -306,12 +307,12 @@ create_colormap (j_decompress_ptr cinfo)
     blksize = blkdist / nci;
     for (j = 0; j < nci; j++) {
       /* Compute j'th output value (out of nci) for component */
-      val = output_value(cinfo, i, j, nci-1);
+      val = output_value_xp(cinfo, i, j, nci-1);
       /* Fill in all colormap entries that have this value of this component */
       for (ptr = j * blksize; ptr < total_colors; ptr += blkdist) {
 	/* fill in blksize entries beginning at ptr */
 	for (k = 0; k < blksize; k++)
-	  colormap[i][ptr+k] = (JSAMPLE) val;
+	  colormap[i][ptr+k] = (JSAMPLEXP) val;
       }
     }
     blkdist = blksize;		/* blksize of this color is blkdist of next */
@@ -330,10 +331,11 @@ create_colormap (j_decompress_ptr cinfo)
  */
 
 LOCAL(void)
-create_colorindex (j_decompress_ptr cinfo)
+create_colorindex_xp (j_decompress_ptr cinfo)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
-  JSAMPROW indexptr;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
+  JSAMPROWXP indexptr;
   int i,j,k, nci, blksize, val, pad;
 
   /* For ordered dither, we pad the color index tables by MAXJSAMPLE in
@@ -342,16 +344,16 @@ create_colorindex (j_decompress_ptr cinfo)
    * flag whether it was done in case user changes dithering mode.
    */
   if (cinfo->dither_mode == JDITHER_ORDERED) {
-    pad = MAXJSAMPLE*2;
+    pad = MAXJSAMPLE12*2;
     cquantize->is_padded = TRUE;
   } else {
     pad = 0;
     cquantize->is_padded = FALSE;
   }
 
-  cquantize->colorindex = (*cinfo->mem->alloc_sarray)
+  cquantize->colorindex = (*cinfo->mem->alloc_sarray_xp)
     ((j_common_ptr) cinfo, JPOOL_IMAGE,
-     (JDIMENSION) (MAXJSAMPLE+1 + pad),
+     (JDIMENSION) (MAXJSAMPLE12+1 + pad),
      (JDIMENSION) cinfo->out_color_components);
 
   /* blksize is number of adjacent repeated entries for a component */
@@ -364,24 +366,24 @@ create_colorindex (j_decompress_ptr cinfo)
 
     /* adjust colorindex pointers to provide padding at negative indexes. */
     if (pad)
-      cquantize->colorindex[i] += MAXJSAMPLE;
+      cquantize->colorindex[i] += MAXJSAMPLE12;
 
     /* in loop, val = index of current output value, */
     /* and k = largest j that maps to current val */
     indexptr = cquantize->colorindex[i];
     val = 0;
-    k = largest_input_value(cinfo, i, 0, nci-1);
-    for (j = 0; j <= MAXJSAMPLE; j++) {
+    k = largest_input_value_xp(cinfo, i, 0, nci-1);
+    for (j = 0; j <= MAXJSAMPLE12; j++) {
       while (j > k)		/* advance val if past boundary */
-	k = largest_input_value(cinfo, i, ++val, nci-1);
+	k = largest_input_value_xp(cinfo, i, ++val, nci-1);
       /* premultiply so that no multiplication needed in main processing */
-      indexptr[j] = (JSAMPLE) (val * blksize);
+      indexptr[j] = (JSAMPLEXP) (val * blksize);
     }
     /* Pad at both ends if necessary */
     if (pad)
-      for (j = 1; j <= MAXJSAMPLE; j++) {
+      for (j = 1; j <= MAXJSAMPLE12; j++) {
 	indexptr[-j] = indexptr[0];
-	indexptr[MAXJSAMPLE+j] = indexptr[MAXJSAMPLE];
+	indexptr[MAXJSAMPLE12+j] = indexptr[MAXJSAMPLE12];
       }
   }
 }
@@ -393,7 +395,7 @@ create_colorindex (j_decompress_ptr cinfo)
  */
 
 LOCAL(ODITHER_MATRIX_PTR)
-make_odither_array (j_decompress_ptr cinfo, int ncolors)
+make_odither_array_xp (j_decompress_ptr cinfo, int ncolors)
 {
   ODITHER_MATRIX_PTR odither;
   int j,k;
@@ -411,7 +413,7 @@ make_odither_array (j_decompress_ptr cinfo, int ncolors)
   for (j = 0; j < ODITHER_SIZE; j++) {
     for (k = 0; k < ODITHER_SIZE; k++) {
       num = ((INT32) (ODITHER_CELLS-1 - 2*((int)base_dither_matrix[j][k])))
-	    * MAXJSAMPLE;
+	    * MAXJSAMPLE12;
       /* Ensure round towards zero despite C's lack of consistency
        * about rounding negative values in integer division...
        */
@@ -429,9 +431,10 @@ make_odither_array (j_decompress_ptr cinfo, int ncolors)
  */
 
 LOCAL(void)
-create_odither_tables (j_decompress_ptr cinfo)
+create_odither_tables_xp (j_decompress_ptr cinfo)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   ODITHER_MATRIX_PTR odither;
   int i, j, nci;
 
@@ -445,7 +448,7 @@ create_odither_tables (j_decompress_ptr cinfo)
       }
     }
     if (odither == NULL)	/* need a new table? */
-      odither = make_odither_array(cinfo, nci);
+      odither = make_odither_array_xp(cinfo, nci);
     cquantize->odither[i] = odither;
   }
 }
@@ -456,14 +459,15 @@ create_odither_tables (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
-		JSAMPARRAY output_buf, int num_rows)
+color_quantize_xp (j_decompress_ptr cinfo, JSAMPARRAYXP input_buf,
+		JSAMPARRAYXP output_buf, int num_rows)
 /* General case, no dithering */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
-  JSAMPARRAY colorindex = cquantize->colorindex;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
+  JSAMPARRAYXP colorindex = cquantize->colorindex;
   register int pixcode, ci;
-  register JSAMPROW ptrin, ptrout;
+  register JSAMPROWXP ptrin, ptrout;
   int row;
   JDIMENSION col;
   JDIMENSION width = cinfo->output_width;
@@ -477,23 +481,24 @@ color_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
       for (ci = 0; ci < nc; ci++) {
 	pixcode += GETJSAMPLE(colorindex[ci][GETJSAMPLE(*ptrin++)]);
       }
-      *ptrout++ = (JSAMPLE) pixcode;
+      *ptrout++ = (JSAMPLEXP) pixcode;
     }
   }
 }
 
 
 METHODDEF(void)
-color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
-		 JSAMPARRAY output_buf, int num_rows)
+color_quantize3_xp (j_decompress_ptr cinfo, JSAMPARRAYXP input_buf,
+		 JSAMPARRAYXP output_buf, int num_rows)
 /* Fast path for out_color_components==3, no dithering */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   register int pixcode;
-  register JSAMPROW ptrin, ptrout;
-  JSAMPROW colorindex0 = cquantize->colorindex[0];
-  JSAMPROW colorindex1 = cquantize->colorindex[1];
-  JSAMPROW colorindex2 = cquantize->colorindex[2];
+  register JSAMPROWXP ptrin, ptrout;
+  JSAMPROWXP colorindex0 = cquantize->colorindex[0];
+  JSAMPROWXP colorindex1 = cquantize->colorindex[1];
+  JSAMPROWXP colorindex2 = cquantize->colorindex[2];
   int row;
   JDIMENSION col;
   JDIMENSION width = cinfo->output_width;
@@ -505,21 +510,22 @@ color_quantize3 (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
       pixcode  = GETJSAMPLE(colorindex0[GETJSAMPLE(*ptrin++)]);
       pixcode += GETJSAMPLE(colorindex1[GETJSAMPLE(*ptrin++)]);
       pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*ptrin++)]);
-      *ptrout++ = (JSAMPLE) pixcode;
+      *ptrout++ = (JSAMPLEXP) pixcode;
     }
   }
 }
 
 
 METHODDEF(void)
-quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
-		     JSAMPARRAY output_buf, int num_rows)
+quantize_ord_dither_xp (j_decompress_ptr cinfo, JSAMPARRAYXP input_buf,
+		     JSAMPARRAYXP output_buf, int num_rows)
 /* General case, with ordered dithering */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
-  register JSAMPROW input_ptr;
-  register JSAMPROW output_ptr;
-  JSAMPROW colorindex_ci;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
+  register JSAMPROWXP input_ptr;
+  register JSAMPROWXP output_ptr;
+  JSAMPROWXP colorindex_ci;
   int * dither;			/* points to active row of dither matrix */
   int row_index, col_index;	/* current indexes into dither matrix */
   int nc = cinfo->out_color_components;
@@ -531,7 +537,7 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
   for (row = 0; row < num_rows; row++) {
     /* Initialize output values to 0 so can process components separately */
     jzero_far((void FAR *) output_buf[row],
-	      (size_t) (width * SIZEOF(JSAMPLE)));
+	      (size_t) (width * SIZEOF(JSAMPLEXP)));
     row_index = cquantize->row_index;
     for (ci = 0; ci < nc; ci++) {
       input_ptr = input_buf[row] + ci;
@@ -562,17 +568,18 @@ quantize_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
 
 
 METHODDEF(void)
-quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
-		      JSAMPARRAY output_buf, int num_rows)
+quantize3_ord_dither_xp (j_decompress_ptr cinfo, JSAMPARRAYXP input_buf,
+		      JSAMPARRAYXP output_buf, int num_rows)
 /* Fast path for out_color_components==3, with ordered dithering */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   register int pixcode;
-  register JSAMPROW input_ptr;
-  register JSAMPROW output_ptr;
-  JSAMPROW colorindex0 = cquantize->colorindex[0];
-  JSAMPROW colorindex1 = cquantize->colorindex[1];
-  JSAMPROW colorindex2 = cquantize->colorindex[2];
+  register JSAMPROWXP input_ptr;
+  register JSAMPROWXP output_ptr;
+  JSAMPROWXP colorindex0 = cquantize->colorindex[0];
+  JSAMPROWXP colorindex1 = cquantize->colorindex[1];
+  JSAMPROWXP colorindex2 = cquantize->colorindex[2];
   int * dither0;		/* points to active row of dither matrix */
   int * dither1;
   int * dither2;
@@ -597,7 +604,7 @@ quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
 					dither1[col_index]]);
       pixcode += GETJSAMPLE(colorindex2[GETJSAMPLE(*input_ptr++) +
 					dither2[col_index]]);
-      *output_ptr++ = (JSAMPLE) pixcode;
+      *output_ptr++ = (JSAMPLEXP) pixcode;
       col_index = (col_index + 1) & ODITHER_MASK;
     }
     row_index = (row_index + 1) & ODITHER_MASK;
@@ -607,21 +614,22 @@ quantize3_ord_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
 
 
 METHODDEF(void)
-quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
-		    JSAMPARRAY output_buf, int num_rows)
+quantize_fs_dither_xp (j_decompress_ptr cinfo, JSAMPARRAYXP input_buf,
+		    JSAMPARRAYXP output_buf, int num_rows)
 /* General case, with Floyd-Steinberg dithering */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   register LOCFSERROR cur;	/* current error or pixel value */
   LOCFSERROR belowerr;		/* error for pixel below cur */
   LOCFSERROR bpreverr;		/* error for below/prev col */
   LOCFSERROR bnexterr;		/* error for below/next col */
   LOCFSERROR delta;
   register FSERRPTR errorptr;	/* => fserrors[] at column before current */
-  register JSAMPROW input_ptr;
-  register JSAMPROW output_ptr;
-  JSAMPROW colorindex_ci;
-  JSAMPROW colormap_ci;
+  register JSAMPROWXP input_ptr;
+  register JSAMPROWXP output_ptr;
+  JSAMPROWXP colorindex_ci;
+  JSAMPROWXP colormap_ci;
   int pixcode;
   int nc = cinfo->out_color_components;
   int dir;			/* 1 for left-to-right, -1 for right-to-left */
@@ -630,13 +638,13 @@ quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
   int row;
   JDIMENSION col;
   JDIMENSION width = cinfo->output_width;
-  JSAMPLE *range_limit = cinfo->sample_range_limit;
+  JSAMPLEXP *range_limit = xinfo->sample_range_limit_xp;
   SHIFT_TEMPS
 
   for (row = 0; row < num_rows; row++) {
     /* Initialize output values to 0 so can process components separately */
     jzero_far((void FAR *) output_buf[row],
-	      (size_t) (width * SIZEOF(JSAMPLE)));
+	      (size_t) (width * SIZEOF(JSAMPLEXP)));
     for (ci = 0; ci < nc; ci++) {
       input_ptr = input_buf[row] + ci;
       output_ptr = output_buf[row];
@@ -678,7 +686,7 @@ quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
 	cur = GETJSAMPLE(range_limit[cur]);
 	/* Select output value, accumulate into output code for this pixel */
 	pixcode = GETJSAMPLE(colorindex_ci[cur]);
-	*output_ptr += (JSAMPLE) pixcode;
+	*output_ptr += (JSAMPLEXP) pixcode;
 	/* Compute actual representation error at this pixel */
 	/* Note: we can do this even though we don't have the final */
 	/* pixel code, because the colormap is orthogonal. */
@@ -719,9 +727,10 @@ quantize_fs_dither (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
  */
 
 LOCAL(void)
-alloc_fs_workspace (j_decompress_ptr cinfo)
+alloc_fs_workspace_xp (j_decompress_ptr cinfo)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   size_t arraysize;
   int i;
 
@@ -738,46 +747,47 @@ alloc_fs_workspace (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
+start_pass_1_quant_xp (j_decompress_ptr cinfo, boolean is_pre_scan)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   size_t arraysize;
   int i;
 
   /* Install my colormap. */
-  cinfo->colormap = cquantize->sv_colormap;
+  xinfo->colormap_xp = cquantize->sv_colormap;
   cinfo->actual_number_of_colors = cquantize->sv_actual;
 
   /* Initialize for desired dithering mode. */
   switch (cinfo->dither_mode) {
   case JDITHER_NONE:
     if (cinfo->out_color_components == 3)
-      cquantize->pub.color_quantize = color_quantize3;
+      cquantize->pub.color_quantize_xp = color_quantize3_xp;
     else
-      cquantize->pub.color_quantize = color_quantize;
+      cquantize->pub.color_quantize_xp = color_quantize_xp;
     break;
   case JDITHER_ORDERED:
     if (cinfo->out_color_components == 3)
-      cquantize->pub.color_quantize = quantize3_ord_dither;
+      cquantize->pub.color_quantize_xp = quantize3_ord_dither_xp;
     else
-      cquantize->pub.color_quantize = quantize_ord_dither;
+      cquantize->pub.color_quantize_xp = quantize_ord_dither_xp;
     cquantize->row_index = 0;	/* initialize state for ordered dither */
     /* If user changed to ordered dither from another mode,
      * we must recreate the color index table with padding.
      * This will cost extra space, but probably isn't very likely.
      */
     if (! cquantize->is_padded)
-      create_colorindex(cinfo);
+      create_colorindex_xp(cinfo);
     /* Create ordered-dither tables if we didn't already. */
     if (cquantize->odither[0] == NULL)
-      create_odither_tables(cinfo);
+      create_odither_tables_xp(cinfo);
     break;
   case JDITHER_FS:
-    cquantize->pub.color_quantize = quantize_fs_dither;
+    cquantize->pub.color_quantize_xp = quantize_fs_dither_xp;
     cquantize->on_odd_row = FALSE; /* initialize state for F-S dither */
     /* Allocate Floyd-Steinberg workspace if didn't already. */
     if (cquantize->fserrors[0] == NULL)
-      alloc_fs_workspace(cinfo);
+      alloc_fs_workspace_xp(cinfo);
     /* Initialize the propagated errors to zero. */
     arraysize = (size_t) ((cinfo->output_width + 2) * SIZEOF(FSERROR));
     for (i = 0; i < cinfo->out_color_components; i++)
@@ -795,7 +805,7 @@ start_pass_1_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
  */
 
 METHODDEF(void)
-finish_pass_1_quant (j_decompress_ptr cinfo)
+finish_pass_1_quant_xp (j_decompress_ptr cinfo)
 {
   /* no work in 1-pass case */
 }
@@ -807,7 +817,7 @@ finish_pass_1_quant (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-new_color_map_1_quant (j_decompress_ptr cinfo)
+new_color_map_1_quant_xp (j_decompress_ptr cinfo)
 {
   ERREXIT(cinfo, JERR_MODE_CHANGE);
 }
@@ -818,17 +828,18 @@ new_color_map_1_quant (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_1pass_quantizer (j_decompress_ptr cinfo)
+jinit_1pass_quantizer_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_cquantize_ptr cquantize;
 
   cquantize = (my_cquantize_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_cquantizer));
-  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
-  cquantize->pub.start_pass = start_pass_1_quant;
-  cquantize->pub.finish_pass = finish_pass_1_quant;
-  cquantize->pub.new_color_map = new_color_map_1_quant;
+  xinfo->cquantize_xp = (struct jpeg_color_quantizer_xp *) cquantize;
+  cquantize->pub.start_pass_xp = start_pass_1_quant_xp;
+  cquantize->pub.finish_pass_xp = finish_pass_1_quant_xp;
+  cquantize->pub.new_color_map_xp = new_color_map_1_quant_xp;
   cquantize->fserrors[0] = NULL; /* Flag FS workspace not allocated */
   cquantize->odither[0] = NULL;	/* Also flag odither arrays not allocated */
 
@@ -836,12 +847,12 @@ jinit_1pass_quantizer (j_decompress_ptr cinfo)
   if (cinfo->out_color_components > MAX_Q_COMPS)
     ERREXIT1(cinfo, JERR_QUANT_COMPONENTS, MAX_Q_COMPS);
   /* Make sure colormap indexes can be represented by JSAMPLEs */
-  if (cinfo->desired_number_of_colors > (MAXJSAMPLE+1))
-    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE+1);
+  if (cinfo->desired_number_of_colors > (MAXJSAMPLE12+1))
+    ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXJSAMPLE12+1);
 
   /* Create the colormap and color index table. */
-  create_colormap(cinfo);
-  create_colorindex(cinfo);
+  create_colormap_xp(cinfo);
+  create_colorindex_xp(cinfo);
 
   /* Allocate Floyd-Steinberg workspace now if requested.
    * We do this now since it is FAR storage and may affect the memory
@@ -850,7 +861,7 @@ jinit_1pass_quantizer (j_decompress_ptr cinfo)
    * possibly overrun the max_memory_to_use setting.
    */
   if (cinfo->dither_mode == JDITHER_FS)
-    alloc_fs_workspace(cinfo);
+    alloc_fs_workspace_xp(cinfo);
 }
 
 #endif /* QUANT_1PASS_SUPPORTED */
diff --git a/jquant2.c b/xjquant2.c
similarity index 87%
rename from jquant2.c
rename to xjquant2.c
index af601e3..ce6f7aa 100644
--- a/jquant2.c
+++ b/xjquant2.c
@@ -1,5 +1,5 @@
 /*
- * jquant2.c
+ * xjquant2.c
  *
  * Copyright (C) 1991-1996, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -19,7 +19,7 @@
 
 #define JPEG_INTERNALS
 #include "jinclude.h"
-#include "jpeglib.h"
+#include "xjpeglib.h"
 
 #ifdef QUANT_2PASS_SUPPORTED
 
@@ -124,7 +124,7 @@
  * arrays are in far memory (same arrangement as we use for image arrays).
  */
 
-#define MAXNUMCOLORS  (MAXJSAMPLE+1) /* maximum size of colormap */
+#define MAXNUMCOLORS  (MAXJSAMPLE12+1) /* maximum size of colormap */
 
 /* These will do the right thing for either R,G,B or B,G,R color order,
  * but you may not like the results for other color orders.
@@ -139,9 +139,9 @@
 #define HIST_C2_ELEMS  (1<<HIST_C2_BITS)
 
 /* These are the amounts to shift an input value to get a histogram index. */
-#define C0_SHIFT  (BITS_IN_JSAMPLE-HIST_C0_BITS)
-#define C1_SHIFT  (BITS_IN_JSAMPLE-HIST_C1_BITS)
-#define C2_SHIFT  (BITS_IN_JSAMPLE-HIST_C2_BITS)
+#define C0_SHIFT  (BITS_IN_JSAMPLE12-HIST_C0_BITS)
+#define C1_SHIFT  (BITS_IN_JSAMPLE12-HIST_C1_BITS)
+#define C2_SHIFT  (BITS_IN_JSAMPLE12-HIST_C2_BITS)
 
 
 typedef UINT16 histcell;	/* histogram cell; prefer an unsigned type */
@@ -177,7 +177,7 @@ typedef hist2d * hist3d;	/* type for top-level pointer */
  * segment to hold the error array; so it is allocated with alloc_large.
  */
 
-#if BITS_IN_JSAMPLE == 8
+#if BITS_IN_JSAMPLE12 == 8
 typedef INT16 FSERROR;		/* 16 bits should be enough */
 typedef int LOCFSERROR;		/* use 'int' for calculation temps */
 #else
@@ -191,10 +191,10 @@ typedef FSERROR FAR *FSERRPTR;	/* pointer to error array (in FAR storage!) */
 /* Private subobject */
 
 typedef struct {
-  struct jpeg_color_quantizer pub; /* public fields */
+  struct jpeg_color_quantizer_xp pub; /* public fields */
 
   /* Space for the eventually created colormap is stashed here */
-  JSAMPARRAY sv_colormap;	/* colormap allocated at init time */
+  JSAMPARRAYXP sv_colormap;	/* colormap allocated at init time */
   int desired;			/* desired # of colors = size of colormap */
 
   /* Variables for accumulating image statistics */
@@ -221,11 +221,12 @@ typedef my_cquantizer * my_cquantize_ptr;
  */
 
 METHODDEF(void)
-prescan_quantize (j_decompress_ptr cinfo, JSAMPARRAY input_buf,
-		  JSAMPARRAY output_buf, int num_rows)
+prescan_quantize_xp (j_decompress_ptr cinfo, JSAMPARRAYXP input_buf,
+		  JSAMPARRAYXP output_buf, int num_rows)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
-  register JSAMPROW ptr;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
+  register JSAMPROWXP ptr;
   register histptr histp;
   register hist3d histogram = cquantize->histogram;
   int row;
@@ -310,11 +311,12 @@ find_biggest_volume (boxptr boxlist, int numboxes)
 
 
 LOCAL(void)
-update_box (j_decompress_ptr cinfo, boxptr boxp)
+update_box_xp (j_decompress_ptr cinfo, boxptr boxp)
 /* Shrink the min/max bounds of a box to enclose only nonzero elements, */
 /* and recompute its volume and population */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   hist3d histogram = cquantize->histogram;
   histptr histp;
   int c0,c1,c2;
@@ -421,7 +423,7 @@ update_box (j_decompress_ptr cinfo, boxptr boxp)
 
 
 LOCAL(int)
-median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
+median_cut_xp (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
 	    int desired_colors)
 /* Repeatedly select and split the largest box until we have enough boxes */
 {
@@ -487,8 +489,8 @@ median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
       break;
     }
     /* Update stats for boxes */
-    update_box(cinfo, b1);
-    update_box(cinfo, b2);
+    update_box_xp(cinfo, b1);
+    update_box_xp(cinfo, b2);
     numboxes++;
   }
   return numboxes;
@@ -496,12 +498,13 @@ median_cut (j_decompress_ptr cinfo, boxptr boxlist, int numboxes,
 
 
 LOCAL(void)
-compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
+compute_color_xp (j_decompress_ptr cinfo, boxptr boxp, int icolor)
 /* Compute representative color for a box, put it in colormap[icolor] */
 {
   /* Current algorithm: mean weighted by pixels (not colors) */
   /* Note it is important to get the rounding correct! */
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   hist3d histogram = cquantize->histogram;
   histptr histp;
   int c0,c1,c2;
@@ -529,14 +532,14 @@ compute_color (j_decompress_ptr cinfo, boxptr boxp, int icolor)
       }
     }
   
-  cinfo->colormap[0][icolor] = (JSAMPLE) ((c0total + (total>>1)) / total);
-  cinfo->colormap[1][icolor] = (JSAMPLE) ((c1total + (total>>1)) / total);
-  cinfo->colormap[2][icolor] = (JSAMPLE) ((c2total + (total>>1)) / total);
+  xinfo->colormap_xp[0][icolor] = (JSAMPLEXP) ((c0total + (total>>1)) / total);
+  xinfo->colormap_xp[1][icolor] = (JSAMPLEXP) ((c1total + (total>>1)) / total);
+  xinfo->colormap_xp[2][icolor] = (JSAMPLEXP) ((c2total + (total>>1)) / total);
 }
 
 
 LOCAL(void)
-select_colors (j_decompress_ptr cinfo, int desired_colors)
+select_colors_xp (j_decompress_ptr cinfo, int desired_colors)
 /* Master routine for color selection */
 {
   boxptr boxlist;
@@ -549,18 +552,18 @@ select_colors (j_decompress_ptr cinfo, int desired_colors)
   /* Initialize one box containing whole space */
   numboxes = 1;
   boxlist[0].c0min = 0;
-  boxlist[0].c0max = MAXJSAMPLE >> C0_SHIFT;
+  boxlist[0].c0max = MAXJSAMPLE12 >> C0_SHIFT;
   boxlist[0].c1min = 0;
-  boxlist[0].c1max = MAXJSAMPLE >> C1_SHIFT;
+  boxlist[0].c1max = MAXJSAMPLE12 >> C1_SHIFT;
   boxlist[0].c2min = 0;
-  boxlist[0].c2max = MAXJSAMPLE >> C2_SHIFT;
+  boxlist[0].c2max = MAXJSAMPLE12 >> C2_SHIFT;
   /* Shrink it to actually-used volume and set its statistics */
-  update_box(cinfo, & boxlist[0]);
+  update_box_xp(cinfo, & boxlist[0]);
   /* Perform median-cut to produce final box list */
-  numboxes = median_cut(cinfo, boxlist, numboxes, desired_colors);
+  numboxes = median_cut_xp(cinfo, boxlist, numboxes, desired_colors);
   /* Compute the representative color for each box, fill colormap */
   for (i = 0; i < numboxes; i++)
-    compute_color(cinfo, & boxlist[i], i);
+    compute_color_xp(cinfo, & boxlist[i], i);
   cinfo->actual_number_of_colors = numboxes;
   TRACEMS1(cinfo, 1, JTRC_QUANT_SELECTED, numboxes);
 }
@@ -643,8 +646,8 @@ select_colors (j_decompress_ptr cinfo, int desired_colors)
  */
 
 LOCAL(int)
-find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
-		    JSAMPLE colorlist[])
+find_nearby_colors_xp (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
+		    JSAMPLEXP colorlist[])
 /* Locate the colormap entries close enough to an update box to be candidates
  * for the nearest entry to some cell(s) in the update box.  The update box
  * is specified by the center coordinates of its first cell.  The number of
@@ -654,6 +657,7 @@ find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
  * the colors that need further consideration.
  */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int numcolors = cinfo->actual_number_of_colors;
   int maxc0, maxc1, maxc2;
   int centerc0, centerc1, centerc2;
@@ -686,7 +690,7 @@ find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
 
   for (i = 0; i < numcolors; i++) {
     /* We compute the squared-c0-distance term, then add in the other two. */
-    x = GETJSAMPLE(cinfo->colormap[0][i]);
+    x = GETJSAMPLE(xinfo->colormap_xp[0][i]);
     if (x < minc0) {
       tdist = (x - minc0) * C0_SCALE;
       min_dist = tdist*tdist;
@@ -709,7 +713,7 @@ find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
       }
     }
 
-    x = GETJSAMPLE(cinfo->colormap[1][i]);
+    x = GETJSAMPLE(xinfo->colormap_xp[1][i]);
     if (x < minc1) {
       tdist = (x - minc1) * C1_SCALE;
       min_dist += tdist*tdist;
@@ -731,7 +735,7 @@ find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
       }
     }
 
-    x = GETJSAMPLE(cinfo->colormap[2][i]);
+    x = GETJSAMPLE(xinfo->colormap_xp[2][i]);
     if (x < minc2) {
       tdist = (x - minc2) * C2_SCALE;
       min_dist += tdist*tdist;
@@ -765,15 +769,15 @@ find_nearby_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
   ncolors = 0;
   for (i = 0; i < numcolors; i++) {
     if (mindist[i] <= minmaxdist)
-      colorlist[ncolors++] = (JSAMPLE) i;
+      colorlist[ncolors++] = (JSAMPLEXP) i;
   }
   return ncolors;
 }
 
 
 LOCAL(void)
-find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
-		  int numcolors, JSAMPLE colorlist[], JSAMPLE bestcolor[])
+find_best_colors_xp (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
+		  int numcolors, JSAMPLEXP colorlist[], JSAMPLEXP bestcolor[])
 /* Find the closest colormap entry for each cell in the update box,
  * given the list of candidate colors prepared by find_nearby_colors.
  * Return the indexes of the closest entries in the bestcolor[] array.
@@ -781,10 +785,11 @@ find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
  * find the distance from a colormap entry to successive cells in the box.
  */
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   int ic0, ic1, ic2;
   int i, icolor;
   register INT32 * bptr;	/* pointer into bestdist[] array */
-  JSAMPLE * cptr;		/* pointer into bestcolor[] array */
+  JSAMPLEXP * cptr;		/* pointer into bestcolor[] array */
   INT32 dist0, dist1;		/* initial distance values */
   register INT32 dist2;		/* current distance in inner loop */
   INT32 xx0, xx1;		/* distance increments */
@@ -811,11 +816,11 @@ find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
   for (i = 0; i < numcolors; i++) {
     icolor = GETJSAMPLE(colorlist[i]);
     /* Compute (square of) distance from minc0/c1/c2 to this color */
-    inc0 = (minc0 - GETJSAMPLE(cinfo->colormap[0][icolor])) * C0_SCALE;
+    inc0 = (minc0 - GETJSAMPLE(xinfo->colormap_xp[0][icolor])) * C0_SCALE;
     dist0 = inc0*inc0;
-    inc1 = (minc1 - GETJSAMPLE(cinfo->colormap[1][icolor])) * C1_SCALE;
+    inc1 = (minc1 - GETJSAMPLE(xinfo->colormap_xp[1][icolor])) * C1_SCALE;
     dist0 += inc1*inc1;
-    inc2 = (minc2 - GETJSAMPLE(cinfo->colormap[2][icolor])) * C2_SCALE;
+    inc2 = (minc2 - GETJSAMPLE(xinfo->colormap_xp[2][icolor])) * C2_SCALE;
     dist0 += inc2*inc2;
     /* Form the initial difference increments */
     inc0 = inc0 * (2 * STEP_C0) + STEP_C0 * STEP_C0;
@@ -834,7 +839,7 @@ find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
 	for (ic2 = BOX_C2_ELEMS-1; ic2 >= 0; ic2--) {
 	  if (dist2 < *bptr) {
 	    *bptr = dist2;
-	    *cptr = (JSAMPLE) icolor;
+	    *cptr = (JSAMPLEXP) icolor;
 	  }
 	  dist2 += xx2;
 	  xx2 += 2 * STEP_C2 * STEP_C2;
@@ -852,22 +857,23 @@ find_best_colors (j_decompress_ptr cinfo, int minc0, int minc1, int minc2,
 
 
 LOCAL(void)
-fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
+fill_inverse_cmap_xp (j_decompress_ptr cinfo, int c0, int c1, int c2)
 /* Fill the inverse-colormap entries in the update box that contains */
 /* histogram cell c0/c1/c2.  (Only that one cell MUST be filled, but */
 /* we can fill as many others as we wish.) */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   hist3d histogram = cquantize->histogram;
   int minc0, minc1, minc2;	/* lower left corner of update box */
   int ic0, ic1, ic2;
-  register JSAMPLE * cptr;	/* pointer into bestcolor[] array */
+  register JSAMPLEXP * cptr;	/* pointer into bestcolor[] array */
   register histptr cachep;	/* pointer into main cache array */
   /* This array lists the candidate colormap indexes. */
-  JSAMPLE colorlist[MAXNUMCOLORS];
+  JSAMPLEXP colorlist[MAXNUMCOLORS];
   int numcolors;		/* number of candidate colors */
   /* This array holds the actually closest colormap index for each cell. */
-  JSAMPLE bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
+  JSAMPLEXP bestcolor[BOX_C0_ELEMS * BOX_C1_ELEMS * BOX_C2_ELEMS];
 
   /* Convert cell coordinates to update box ID */
   c0 >>= BOX_C0_LOG;
@@ -885,10 +891,10 @@ fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
   /* Determine which colormap entries are close enough to be candidates
    * for the nearest entry to some cell in the update box.
    */
-  numcolors = find_nearby_colors(cinfo, minc0, minc1, minc2, colorlist);
+  numcolors = find_nearby_colors_xp(cinfo, minc0, minc1, minc2, colorlist);
 
   /* Determine the actually nearest colors. */
-  find_best_colors(cinfo, minc0, minc1, minc2, numcolors, colorlist,
+  find_best_colors_xp(cinfo, minc0, minc1, minc2, numcolors, colorlist,
 		   bestcolor);
 
   /* Save the best color numbers (plus 1) in the main cache array */
@@ -912,13 +918,14 @@ fill_inverse_cmap (j_decompress_ptr cinfo, int c0, int c1, int c2)
  */
 
 METHODDEF(void)
-pass2_no_dither (j_decompress_ptr cinfo,
-		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
+pass2_no_dither_xp (j_decompress_ptr cinfo,
+		 JSAMPARRAYXP input_buf, JSAMPARRAYXP output_buf, int num_rows)
 /* This version performs no dithering */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   hist3d histogram = cquantize->histogram;
-  register JSAMPROW inptr, outptr;
+  register JSAMPROWXP inptr, outptr;
   register histptr cachep;
   register int c0, c1, c2;
   int row;
@@ -937,38 +944,39 @@ pass2_no_dither (j_decompress_ptr cinfo,
       /* If we have not seen this color before, find nearest colormap entry */
       /* and update the cache */
       if (*cachep == 0)
-	fill_inverse_cmap(cinfo, c0,c1,c2);
+	fill_inverse_cmap_xp(cinfo, c0,c1,c2);
       /* Now emit the colormap index for this cell */
-      *outptr++ = (JSAMPLE) (*cachep - 1);
+      *outptr++ = (JSAMPLEXP) (*cachep - 1);
     }
   }
 }
 
 
 METHODDEF(void)
-pass2_fs_dither (j_decompress_ptr cinfo,
-		 JSAMPARRAY input_buf, JSAMPARRAY output_buf, int num_rows)
+pass2_fs_dither_xp (j_decompress_ptr cinfo,
+		 JSAMPARRAYXP input_buf, JSAMPARRAYXP output_buf, int num_rows)
 /* This version performs Floyd-Steinberg dithering */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   hist3d histogram = cquantize->histogram;
   register LOCFSERROR cur0, cur1, cur2;	/* current error or pixel value */
   LOCFSERROR belowerr0, belowerr1, belowerr2; /* error for pixel below cur */
   LOCFSERROR bpreverr0, bpreverr1, bpreverr2; /* error for below/prev col */
   register FSERRPTR errorptr;	/* => fserrors[] at column before current */
-  JSAMPROW inptr;		/* => current input pixel */
-  JSAMPROW outptr;		/* => current output pixel */
+  JSAMPROWXP inptr;		/* => current input pixel */
+  JSAMPROWXP outptr;		/* => current output pixel */
   histptr cachep;
   int dir;			/* +1 or -1 depending on direction */
   int dir3;			/* 3*dir, for advancing inptr & errorptr */
   int row;
   JDIMENSION col;
   JDIMENSION width = cinfo->output_width;
-  JSAMPLE *range_limit = cinfo->sample_range_limit;
+  JSAMPLEXP *range_limit = xinfo->sample_range_limit_xp;
   int *error_limit = cquantize->error_limiter;
-  JSAMPROW colormap0 = cinfo->colormap[0];
-  JSAMPROW colormap1 = cinfo->colormap[1];
-  JSAMPROW colormap2 = cinfo->colormap[2];
+  JSAMPROWXP colormap0 = xinfo->colormap_xp[0];
+  JSAMPROWXP colormap1 = xinfo->colormap_xp[1];
+  JSAMPROWXP colormap2 = xinfo->colormap_xp[2];
   SHIFT_TEMPS
 
   for (row = 0; row < num_rows; row++) {
@@ -1028,10 +1036,10 @@ pass2_fs_dither (j_decompress_ptr cinfo,
       /* If we have not seen this color before, find nearest colormap */
       /* entry and update the cache */
       if (*cachep == 0)
-	fill_inverse_cmap(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
+	fill_inverse_cmap_xp(cinfo, cur0>>C0_SHIFT,cur1>>C1_SHIFT,cur2>>C2_SHIFT);
       /* Now emit the colormap index for this cell */
       { register int pixcode = *cachep - 1;
-	*outptr = (JSAMPLE) pixcode;
+	*outptr = (JSAMPLEXP) pixcode;
 	/* Compute representation error for this pixel */
 	cur0 -= GETJSAMPLE(colormap0[pixcode]);
 	cur1 -= GETJSAMPLE(colormap1[pixcode]);
@@ -1105,19 +1113,20 @@ pass2_fs_dither (j_decompress_ptr cinfo,
  */
 
 LOCAL(void)
-init_error_limit (j_decompress_ptr cinfo)
+init_error_limit_xp (j_decompress_ptr cinfo)
 /* Allocate and fill in the error_limiter table */
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   int * table;
   int in, out;
 
   table = (int *) (*cinfo->mem->alloc_small)
-    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE*2+1) * SIZEOF(int));
-  table += MAXJSAMPLE;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
+    ((j_common_ptr) cinfo, JPOOL_IMAGE, (MAXJSAMPLE12*2+1) * SIZEOF(int));
+  table += MAXJSAMPLE12;		/* so can index -MAXJSAMPLE .. +MAXJSAMPLE */
   cquantize->error_limiter = table;
 
-#define STEPSIZE ((MAXJSAMPLE+1)/16)
+#define STEPSIZE ((MAXJSAMPLE12+1)/16)
   /* Map errors 1:1 up to +- MAXJSAMPLE/16 */
   out = 0;
   for (in = 0; in < STEPSIZE; in++, out++) {
@@ -1128,7 +1137,7 @@ init_error_limit (j_decompress_ptr cinfo)
     table[in] = out; table[-in] = -out;
   }
   /* Clamp the rest to final out value (which is (MAXJSAMPLE+1)/8) */
-  for (; in <= MAXJSAMPLE; in++) {
+  for (; in <= MAXJSAMPLE12; in++) {
     table[in] = out; table[-in] = -out;
   }
 #undef STEPSIZE
@@ -1140,20 +1149,21 @@ init_error_limit (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-finish_pass1 (j_decompress_ptr cinfo)
+finish_pass1_xp (j_decompress_ptr cinfo)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
 
   /* Select the representative colors and fill in cinfo->colormap */
-  cinfo->colormap = cquantize->sv_colormap;
-  select_colors(cinfo, cquantize->desired);
+  xinfo->colormap_xp = cquantize->sv_colormap;
+  select_colors_xp(cinfo, cquantize->desired);
   /* Force next pass to zero the color index table */
   cquantize->needs_zeroed = TRUE;
 }
 
 
 METHODDEF(void)
-finish_pass2 (j_decompress_ptr cinfo)
+finish_pass2_xp (j_decompress_ptr cinfo)
 {
   /* no work */
 }
@@ -1164,9 +1174,10 @@ finish_pass2 (j_decompress_ptr cinfo)
  */
 
 METHODDEF(void)
-start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
+start_pass_2_quant_xp (j_decompress_ptr cinfo, boolean is_pre_scan)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
   hist3d histogram = cquantize->histogram;
   int i;
 
@@ -1177,16 +1188,16 @@ start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
 
   if (is_pre_scan) {
     /* Set up method pointers */
-    cquantize->pub.color_quantize = prescan_quantize;
-    cquantize->pub.finish_pass = finish_pass1;
+    cquantize->pub.color_quantize_xp = prescan_quantize_xp;
+    cquantize->pub.finish_pass_xp = finish_pass1_xp;
     cquantize->needs_zeroed = TRUE; /* Always zero histogram */
   } else {
     /* Set up method pointers */
     if (cinfo->dither_mode == JDITHER_FS)
-      cquantize->pub.color_quantize = pass2_fs_dither;
+      cquantize->pub.color_quantize_xp = pass2_fs_dither_xp;
     else
-      cquantize->pub.color_quantize = pass2_no_dither;
-    cquantize->pub.finish_pass = finish_pass2;
+      cquantize->pub.color_quantize_xp = pass2_no_dither_xp;
+    cquantize->pub.finish_pass_xp = finish_pass2_xp;
 
     /* Make sure color count is acceptable */
     i = cinfo->actual_number_of_colors;
@@ -1206,7 +1217,7 @@ start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
       jzero_far((void FAR *) cquantize->fserrors, arraysize);
       /* Make the error-limit table if we didn't already. */
       if (cquantize->error_limiter == NULL)
-	init_error_limit(cinfo);
+	init_error_limit_xp(cinfo);
       cquantize->on_odd_row = FALSE;
     }
 
@@ -1227,9 +1238,10 @@ start_pass_2_quant (j_decompress_ptr cinfo, boolean is_pre_scan)
  */
 
 METHODDEF(void)
-new_color_map_2_quant (j_decompress_ptr cinfo)
+new_color_map_2_quant_xp (j_decompress_ptr cinfo)
 {
-  my_cquantize_ptr cquantize = (my_cquantize_ptr) cinfo->cquantize;
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
+  my_cquantize_ptr cquantize = (my_cquantize_ptr) xinfo->cquantize_xp;
 
   /* Reset the inverse color map */
   cquantize->needs_zeroed = TRUE;
@@ -1241,17 +1253,18 @@ new_color_map_2_quant (j_decompress_ptr cinfo)
  */
 
 GLOBAL(void)
-jinit_2pass_quantizer (j_decompress_ptr cinfo)
+jinit_2pass_quantizer_xp (j_decompress_ptr cinfo)
 {
+  j_decompress_ptr_xp xinfo = (j_decompress_ptr_xp) cinfo->client_data;
   my_cquantize_ptr cquantize;
   int i;
 
   cquantize = (my_cquantize_ptr)
     (*cinfo->mem->alloc_small) ((j_common_ptr) cinfo, JPOOL_IMAGE,
 				SIZEOF(my_cquantizer));
-  cinfo->cquantize = (struct jpeg_color_quantizer *) cquantize;
-  cquantize->pub.start_pass = start_pass_2_quant;
-  cquantize->pub.new_color_map = new_color_map_2_quant;
+  xinfo->cquantize_xp = (struct jpeg_color_quantizer_xp *) cquantize;
+  cquantize->pub.start_pass_xp = start_pass_2_quant_xp;
+  cquantize->pub.new_color_map_xp = new_color_map_2_quant_xp;
   cquantize->fserrors = NULL;	/* flag optional arrays not allocated */
   cquantize->error_limiter = NULL;
 
@@ -1282,7 +1295,7 @@ jinit_2pass_quantizer (j_decompress_ptr cinfo)
     /* Make sure colormap indexes can be represented by JSAMPLEs */
     if (desired > MAXNUMCOLORS)
       ERREXIT1(cinfo, JERR_QUANT_MANY_COLORS, MAXNUMCOLORS);
-    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray)
+    cquantize->sv_colormap = (*cinfo->mem->alloc_sarray_xp)
       ((j_common_ptr) cinfo,JPOOL_IMAGE, (JDIMENSION) desired, (JDIMENSION) 3);
     cquantize->desired = desired;
   } else
@@ -1303,7 +1316,7 @@ jinit_2pass_quantizer (j_decompress_ptr cinfo)
       ((j_common_ptr) cinfo, JPOOL_IMAGE,
        (size_t) ((cinfo->output_width + 2) * (3 * SIZEOF(FSERROR))));
     /* Might as well create the error-limiting table too. */
-    init_error_limit(cinfo);
+    init_error_limit_xp(cinfo);
   }
 }
 
diff --git a/xjutils.c b/xjutils.c
new file mode 100644
index 0000000..ac99af2
--- /dev/null
+++ b/xjutils.c
@@ -0,0 +1,52 @@
+/*
+ * xjutils.c
+ *
+ * Copyright (C) 1991-1996, Thomas G. Lane.
+ * This file is part of the Independent JPEG Group's software.
+ * For conditions of distribution and use, see the accompanying README file.
+ *
+ * This file contains tables and miscellaneous utility routines needed
+ * for both compression and decompression.
+ * Note we prefix all global names with "j" to minimize conflicts with
+ * a surrounding application.
+ */
+
+#define JPEG_INTERNALS
+#include "jinclude.h"
+#include "xjpeglib.h"
+
+
+
+GLOBAL(void)
+jcopy_sample_rows_xp (JSAMPARRAYXP input_array, int source_row,
+		   JSAMPARRAYXP output_array, int dest_row,
+		   int num_rows, JDIMENSION num_cols)
+/* Copy some rows of samples from one place to another.
+ * num_rows rows are copied from input_array[source_row++]
+ * to output_array[dest_row++]; these areas may overlap for duplication.
+ * The source and destination arrays must be at least as wide as num_cols.
+ */
+{
+  register JSAMPROWXP inptr, outptr;
+#ifdef FMEMCOPY
+  register size_t count = (size_t) (num_cols * SIZEOF(JSAMPLEXP));
+#else
+  register JDIMENSION count;
+#endif
+  register int row;
+
+  input_array += source_row;
+  output_array += dest_row;
+
+  for (row = num_rows; row > 0; row--) {
+    inptr = *input_array++;
+    outptr = *output_array++;
+#ifdef FMEMCOPY
+    FMEMCOPY(outptr, inptr, count);
+#else
+    for (count = num_cols; count > 0; count--)
+      *outptr++ = *inptr++;	/* needn't bother with GETJSAMPLE() here */
+#endif
+  }
+}
+
