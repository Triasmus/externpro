diff --git a/CMakeLists.txt b/CMakeLists.txt
index 75f35c7..c81a223 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -19,13 +19,20 @@ PROJECT(APR C)
 
 CMAKE_MINIMUM_REQUIRED(VERSION 2.8)
 
+INCLUDE(flags OPTIONAL)
 OPTION(APR_INSTALL_PRIVATE_H  "Install selected private .h files (for httpd)"  OFF)
 OPTION(APR_HAVE_IPV6        "IPv6 support"                 ON)
 OPTION(INSTALL_PDB          "Install .pdb files (if generated)"  ON)
 OPTION(APR_BUILD_TESTAPR    "Build the test suite"         OFF)
 OPTION(TEST_STATIC_LIBS     "Test programs use APR static libraries instead of shared libraries?" OFF)
+if(WIN32)
 SET(MIN_WINDOWS_VER             "Vista" 
     CACHE STRING "Minimum Windows version")
+endif(WIN32)
+
+if(TEST_STATIC_LIBS)
+  OPTION(BUILD_ONLY_STATIC_LIBS  "Build only static libraries" ON)
+endif()
 
 # create 1-or-0 representation of feature tests for apr.h
 
@@ -35,6 +42,7 @@ IF(APR_HAVE_IPV6)
   SET(apr_have_ipv6_10 1)
 ENDIF()
 
+if(WIN32)
 IF("${MIN_WINDOWS_VER}" STREQUAL "")
   SET(win32_winnt_str "0x0600")
 ELSEIF(${MIN_WINDOWS_VER} STREQUAL "Vista")
@@ -47,13 +55,15 @@ ENDIF()
 
 CONFIGURE_FILE(include/apr.hwc
                ${PROJECT_BINARY_DIR}/apr.h)
+elseif(UNIX)
+  include(configure.cmake) # generates apr.h apr_private.h, sets APR_SYSTEM_LIBS
+endif()
 
 ADD_EXECUTABLE(gen_test_char tools/gen_test_char.c)
-GET_TARGET_PROPERTY(GEN_TEST_CHAR_EXE gen_test_char LOCATION)
 ADD_CUSTOM_COMMAND(
   COMMENT "Generating character tables, apr_escape_test_char.h, for current locale"
   DEPENDS gen_test_char
-  COMMAND ${GEN_TEST_CHAR_EXE} > ${PROJECT_BINARY_DIR}/apr_escape_test_char.h
+  COMMAND $<TARGET_FILE:gen_test_char> > ${PROJECT_BINARY_DIR}/apr_escape_test_char.h
   OUTPUT ${PROJECT_BINARY_DIR}/apr_escape_test_char.h
 )
 ADD_CUSTOM_TARGET(
@@ -71,16 +81,22 @@ ADD_CUSTOM_TARGET(
 SET(APR_INCLUDE_DIRECTORIES
   ${PROJECT_BINARY_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/include
-  ${CMAKE_CURRENT_SOURCE_DIR}/include/arch/win32
-  ${CMAKE_CURRENT_SOURCE_DIR}/include/arch/unix
-  ${CMAKE_CURRENT_SOURCE_DIR}/include/private
 )
 
+if(WIN32)
+LIST(APPEND APR_INCLUDE_DIRECTORIES
+  ${CMAKE_CURRENT_SOURCE_DIR}/include/arch/win32
+)
 SET(APR_SYSTEM_LIBS
   ws2_32
   mswsock
   rpcrt4
 )
+endif(WIN32)
+# TRICKY: include/arch/unix must be after include/arch/win32
+LIST(APPEND APR_INCLUDE_DIRECTORIES
+  ${CMAKE_CURRENT_SOURCE_DIR}/include/arch/unix
+)
 
 INCLUDE_DIRECTORIES(${APR_INCLUDE_DIRECTORIES})
 
@@ -127,6 +143,7 @@ SET(APR_PUBLIC_HEADERS_GENERATED
   ${PROJECT_BINARY_DIR}/apr.h
 )
 
+if(WIN32)
 SET(APR_SOURCES
   atomic/win32/apr_atomic.c
   dso/win32/dso.c
@@ -201,6 +218,90 @@ SET(APR_SOURCES
   user/win32/groupinfo.c
   user/win32/userinfo.c
 )
+elseif(UNIX)
+SET(APR_SOURCES
+  atomic/unix/builtins.c
+  atomic/unix/ia32.c
+  atomic/unix/mutex.c
+  atomic/unix/ppc.c
+  atomic/unix/s390.c
+  atomic/unix/solaris.c
+  dso/unix/dso.c
+  encoding/apr_escape.c
+  file_io/unix/copy.c
+  file_io/unix/fileacc.c
+  file_io/unix/filepath_util.c
+  file_io/unix/fullrw.c
+  file_io/unix/mktemp.c
+  file_io/unix/tempdir.c
+  file_io/unix/buffer.c
+  file_io/unix/dir.c
+  file_io/unix/filedup.c
+  file_io/unix/filepath.c
+  file_io/unix/filestat.c
+  file_io/unix/flock.c
+  file_io/unix/open.c
+  file_io/unix/pipe.c
+  file_io/unix/readwrite.c
+  file_io/unix/seek.c
+  locks/unix/global_mutex.c
+  locks/unix/proc_mutex.c
+  locks/unix/thread_cond.c
+  locks/unix/thread_mutex.c
+  locks/unix/thread_rwlock.c
+  memory/unix/apr_pools.c
+  misc/unix/errorcodes.c
+  misc/unix/getopt.c
+  misc/unix/otherchild.c
+  misc/unix/version.c
+  misc/unix/charset.c
+  misc/unix/env.c
+  misc/unix/rand.c
+  misc/unix/start.c
+  mmap/unix/common.c
+  mmap/unix/mmap.c
+  network_io/unix/inet_ntop.c
+  network_io/unix/inet_pton.c
+  network_io/unix/multicast.c
+  network_io/unix/sockaddr.c
+  network_io/unix/socket_util.c
+  network_io/unix/sendrecv.c
+  network_io/unix/sockets.c
+  network_io/unix/sockopt.c
+  passwd/apr_getpass.c
+  poll/unix/poll.c
+  poll/unix/pollcb.c
+  poll/unix/pollset.c
+  poll/unix/select.c
+  poll/unix/epoll.c
+  poll/unix/kqueue.c
+  poll/unix/port.c
+  poll/unix/z_asio.c
+  random/unix/apr_random.c
+  random/unix/sha2.c
+  random/unix/sha2_glue.c
+  shmem/unix/shm.c
+  strings/apr_cpystrn.c
+  strings/apr_fnmatch.c
+  strings/apr_snprintf.c
+  strings/apr_strings.c
+  strings/apr_strnatcmp.c
+  strings/apr_strtok.c
+  support/unix/waitio.c
+  tables/apr_hash.c
+  tables/apr_skiplist.c
+  tables/apr_tables.c
+  threadproc/unix/proc.c
+  threadproc/unix/procsup.c
+  threadproc/unix/signals.c
+  threadproc/unix/thread.c
+  threadproc/unix/threadpriv.c
+  time/unix/time.c
+  time/unix/timestr.c
+  user/unix/groupinfo.c
+  user/unix/userinfo.c
+)
+endif()
 
 SET(APR_TEST_SOURCES
   test/abts.c
@@ -251,31 +352,57 @@ SET(APR_TEST_SOURCES
   test/testvsn.c
 )
 
+IF(DEFINED APR_VER)
+  set(ver _${APR_VER})
+  set(verDir /apr${ver})
+ENDIF()
+
 SET(install_targets)
 SET(install_bin_pdb)
 
 # libapr-1 is shared, apr-1 is static
+if(NOT BUILD_ONLY_STATIC_LIBS)
 ADD_LIBRARY(libapr-1 SHARED ${APR_SOURCES} ${APR_PUBLIC_HEADERS_GENERATED} libapr.rc)
 SET(install_targets ${install_targets} libapr-1)
 SET(install_bin_pdb ${install_bin_pdb} ${PROJECT_BINARY_DIR}/libapr-1.pdb)
 TARGET_LINK_LIBRARIES(libapr-1 ${APR_SYSTEM_LIBS})
+if(WIN32)
 SET_TARGET_PROPERTIES(libapr-1 PROPERTIES COMPILE_DEFINITIONS "APR_DECLARE_EXPORT;WINNT")
+elseif(UNIX)
+SET_TARGET_PROPERTIES(libapr-1 PROPERTIES COMPILE_DEFINITIONS "APR_DECLARE_EXPORT")
+endif()
 ADD_DEPENDENCIES(libapr-1 test_char_header)
+endif()
 
 ADD_LIBRARY(apr-1 STATIC ${APR_SOURCES} ${APR_PUBLIC_HEADERS_GENERATED})
 SET(install_targets ${install_targets} apr-1)
+TARGET_INCLUDE_DIRECTORIES(apr-1 PUBLIC
+  $<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include${verDir}> #include <apr/apr_version.h>
+  $<INSTALL_INTERFACE:$<INSTALL_PREFIX>/include${verDir}/apr> #include <apr_version.h>
+  )
 TARGET_LINK_LIBRARIES(apr-1 ${APR_SYSTEM_LIBS})
+if(WIN32)
+TARGET_COMPILE_DEFINITIONS(apr-1 PUBLIC $<INSTALL_INTERFACE:APR_DECLARE_STATIC>)
 SET_TARGET_PROPERTIES(apr-1 PROPERTIES COMPILE_DEFINITIONS "APR_DECLARE_STATIC;WINNT")
+elseif(UNIX)
+SET_TARGET_PROPERTIES(apr-1 PROPERTIES COMPILE_DEFINITIONS "APR_DECLARE_STATIC")
+endif()
+SET_TARGET_PROPERTIES(apr-1 PROPERTIES OUTPUT_NAME apr-1${ver})
 ADD_DEPENDENCIES(apr-1 test_char_header)
 
+if(WIN32)
 # libaprapp-1 and aprapp-1 are static
+if(NOT BUILD_ONLY_STATIC_LIBS)
 ADD_LIBRARY(libaprapp-1 STATIC misc/win32/apr_app.c misc/win32/internal.c ${APR_PUBLIC_HEADERS_GENERATED})
 SET(install_targets ${install_targets} libaprapp-1)
 SET_TARGET_PROPERTIES(libaprapp-1 PROPERTIES COMPILE_DEFINITIONS "APR_APP;WINNT")
+endif()
 
 ADD_LIBRARY(aprapp-1 STATIC misc/win32/apr_app.c misc/win32/internal.c ${APR_PUBLIC_HEADERS_GENERATED})
 SET(install_targets ${install_targets} aprapp-1)
 SET_TARGET_PROPERTIES(aprapp-1 PROPERTIES COMPILE_DEFINITIONS "APR_DECLARE_STATIC;APR_APP;WINNT")
+SET_TARGET_PROPERTIES(aprapp-1 PROPERTIES OUTPUT_NAME aprapp-1${ver})
+endif(WIN32)
 
 IF(APR_BUILD_TESTAPR)
   ENABLE_TESTING()
@@ -303,8 +430,12 @@ IF(APR_BUILD_TESTAPR)
   ENDIF()
 
   ADD_EXECUTABLE(testapp test/testapp.c)
+  if(WIN32)
   TARGET_LINK_LIBRARIES(testapp ${whichapr} ${whichaprapp} ${APR_SYSTEM_LIBS})
   SET_TARGET_PROPERTIES(testapp PROPERTIES LINK_FLAGS /entry:wmainCRTStartup)
+  else()
+  TARGET_LINK_LIBRARIES(testapp ${whichapr} ${APR_SYSTEM_LIBS})
+  endif()
   IF(apiflag)
     SET_TARGET_PROPERTIES(testapp PROPERTIES COMPILE_FLAGS ${apiflag})
   ENDIF()
@@ -319,12 +450,14 @@ IF(APR_BUILD_TESTAPR)
 
   ADD_LIBRARY(mod_test MODULE test/mod_test.c)
   TARGET_LINK_LIBRARIES(mod_test ${whichapr} ${APR_SYSTEM_LIBS})
+  if(WIN32)
   SET_PROPERTY(TARGET mod_test APPEND PROPERTY LINK_FLAGS /export:print_hello)
   # nasty work-around for difficulties adding more than one additional flag
   # (they get joined in a bad way behind the scenes)
   GET_PROPERTY(link_flags TARGET mod_test PROPERTY LINK_FLAGS)
   SET(link_flags "${link_flags} /export:count_reps")
   SET_TARGET_PROPERTIES(mod_test PROPERTIES LINK_FLAGS ${link_flags})
+  endif(WIN32)
   IF(apiflag)
     SET_TARGET_PROPERTIES(mod_test PROPERTIES COMPILE_FLAGS ${apiflag})
   ENDIF()
@@ -333,7 +466,7 @@ IF(APR_BUILD_TESTAPR)
   # requirements.
   SET(single_source_programs
     test/echod.c
-    test/sendfile.c
+    test/sendfiletest.c
     test/sockperf.c
     test/testlockperf.c
     test/testmutexscope.c
@@ -345,8 +478,10 @@ IF(APR_BUILD_TESTAPR)
     test/testshmproducer.c
     test/testshmconsumer.c
     test/tryread.c
-    test/internal/testucs.c
   )
+  if(WIN32)
+    list(APPEND single_source_programs test/internal/testucs.c)
+  endif(WIN32)
 
   FOREACH(sourcefile ${single_source_programs})
     STRING(REGEX REPLACE ".*/([^\\]+)\\.c" "\\1" proggie ${sourcefile})
@@ -362,6 +497,9 @@ IF(APR_BUILD_TESTAPR)
     testmutexscope
     testucs
   )
+  if(NOT WIN32)
+    list(REMOVE_ITEM simple_tests testucs)
+  endif()
 
   FOREACH(simple ${simple_tests})
     ADD_TEST(NAME ${simple} COMMAND ${simple})
@@ -370,9 +508,9 @@ IF(APR_BUILD_TESTAPR)
   # testlockperf takes forever on Windows with default counter limit
   ADD_TEST(NAME testlockperf COMMAND testlockperf -c 50000)
 
-  # sendfile runs multiple times with different parameters.
+  # sendfiletest runs multiple times with different parameters.
   FOREACH(sendfile_mode blocking nonblocking timeout)
-    ADD_TEST(NAME sendfile-${sendfile_mode} COMMAND sendfile client ${sendfile_mode} startserver)
+    ADD_TEST(NAME sendfiletest-${sendfile_mode} COMMAND sendfiletest client ${sendfile_mode} startserver)
   ENDFOREACH()
 
   # No test is added for echod+sockperf.  Those will have to be run manually.
@@ -381,11 +519,16 @@ ENDIF (APR_BUILD_TESTAPR)
 
 # Installation
 
-INSTALL(TARGETS ${install_targets}
+SET(targetsFile apr${ver}-targets)
+INSTALL(TARGETS ${install_targets} EXPORT ${targetsFile}
         RUNTIME DESTINATION bin
         LIBRARY DESTINATION lib
         ARCHIVE DESTINATION lib
        )
+IF(DEFINED XP_NAMESPACE)
+  SET(nameSpace NAMESPACE ${XP_NAMESPACE}::)
+ENDIF()
+INSTALL(EXPORT ${targetsFile} DESTINATION lib/cmake ${nameSpace})
 
 IF(INSTALL_PDB)
   INSTALL(FILES ${install_bin_pdb}
@@ -393,7 +536,8 @@ IF(INSTALL_PDB)
           CONFIGURATIONS RelWithDebInfo Debug)
 ENDIF()
 
-INSTALL(FILES ${APR_PUBLIC_HEADERS_STATIC} ${APR_PUBLIC_HEADERS_GENERATED} DESTINATION include)
+SET(includeDir include${verDir}/apr)
+INSTALL(FILES ${APR_PUBLIC_HEADERS_STATIC} ${APR_PUBLIC_HEADERS_GENERATED} DESTINATION ${includeDir})
 IF(APR_INSTALL_PRIVATE_H)
   # Kludges for unexpected dependencies of httpd 2.x, not installed by default
   SET(APR_PRIVATE_H_FOR_HTTPD
@@ -402,8 +546,8 @@ IF(APR_INSTALL_PRIVATE_H)
     include/arch/win32/apr_arch_utf8.h
     include/arch/win32/apr_private.h
     )
-  INSTALL(FILES ${APR_PRIVATE_H_FOR_HTTPD} DESTINATION include/arch/win32)
-  INSTALL(FILES include/arch/apr_private_common.h DESTINATION include/arch)
+  INSTALL(FILES ${APR_PRIVATE_H_FOR_HTTPD} DESTINATION ${includeDir}/arch/win32)
+  INSTALL(FILES include/arch/apr_private_common.h DESTINATION ${includeDir}/arch)
 ENDIF()
 
 STRING(TOUPPER "${CMAKE_BUILD_TYPE}" buildtype)
@@ -417,7 +561,9 @@ MESSAGE(STATUS "  Install .pdb (if available)...... : ${INSTALL_PDB}")
 MESSAGE(STATUS "  Install prefix .................. : ${CMAKE_INSTALL_PREFIX}")
 MESSAGE(STATUS "  C compiler ...................... : ${CMAKE_C_COMPILER}")
 MESSAGE(STATUS "  IPv6 ............................ : ${APR_HAVE_IPV6}")
+if(WIN32)
 MESSAGE(STATUS "  Minimum Windows version ......... : ${MIN_WINDOWS_VER}")
+endif(WIN32)
 MESSAGE(STATUS "  Build test suite ................ : ${APR_BUILD_TESTAPR}")
 IF(TEST_STATIC_LIBS)
 MESSAGE(STATUS "    (testing static libraries)")
diff --git a/configure.cmake b/configure.cmake
new file mode 100644
index 0000000..efb4ee7
--- /dev/null
+++ b/configure.cmake
@@ -0,0 +1,1210 @@
+include(CheckCSourceCompiles)
+include(CheckFunctionExists)
+include(CheckIncludeFile)
+include(CheckLibraryExists)
+include(CheckStructHasMember)
+include(CheckSymbolExists)
+include(CheckTypeSize)
+include(TestBigEndian)
+########################################
+function(set_define var)
+  if(${ARGC} GREATER 1 AND ${var})
+    set(DEFINE_${var} cmakedefine01 PARENT_SCOPE)
+  else()
+    set(DEFINE_${var} cmakedefine PARENT_SCOPE)
+  endif()
+  if(${var})
+    set(APR_TEST_DEFINES "${APR_TEST_DEFINES} -D${var}" PARENT_SCOPE)
+    set(CMAKE_REQUIRED_DEFINITIONS ${APR_TEST_DEFINES} PARENT_SCOPE)
+  endif(${var})
+endfunction()
+##########
+function(set01 var boolVar)
+  if(${boolVar})
+    set(${var} 1 PARENT_SCOPE)
+  else()
+    set(${var} 0 PARENT_SCOPE)
+  endif()
+endfunction()
+##########
+macro(check_struct_has_member01 struct member header variable)
+  check_struct_has_member(${struct} ${member} ${header} ${variable})
+  set_define(${variable} 1)
+endmacro()
+##########
+macro(check_include_file_concat incfile var)
+  if(${ARGC} GREATER 2)
+    unset(code)
+    foreach(arg ${ARGN})
+      set(code "${code}#include <${arg}>\n")
+    endforeach()
+    set(code "${code}#include <${incfile}>
+int main(void)
+{
+  return 0;
+}
+"     )
+    check_c_source_compiles("${code}" ${var})
+  else()
+    check_include_file("${incfile}" ${var})
+  endif()
+  set_define(${var} 1)
+  if(${var})
+    set(APR_INCLUDES ${APR_INCLUDES} ${incfile})
+  endif(${var})
+endmacro()
+##########
+macro(check_exists_define01 func var)
+  if(UNIX)
+    check_function_exists("${func}" ${var})
+  else()
+    check_symbol_exists("${func}" "${APR_INCLUDES}" ${var})
+  endif()
+  set_define(${var} 1)
+endmacro()
+##########
+macro(check_symbol_exists_define01 sym inc var)
+  check_symbol_exists(${sym} "${inc}" ${var})
+  set_define(${var} 1)
+endmacro()
+##########
+macro(check_library_exists_concat lib symbol var)
+  check_library_exists("${lib};${APR_SYSTEM_LIBS}" ${symbol} "${CMAKE_LIBRARY_PATH}" ${var})
+  set_define(${var} 1)
+  if(${var})
+    set(APR_SYSTEM_LIBS ${lib} ${APR_SYSTEM_LIBS})
+    set(CMAKE_REQUIRED_LIBRARIES ${APR_SYSTEM_LIBS})
+  endif(${var})
+endmacro()
+########################################
+check_include_file_concat(windows.h HAVE_WINDOWS_H)
+if(HAVE_WINDOWS_H)
+  set(WIN32_LEAN_AND_MEAN TRUE) # Define to avoid automatic inclusion of winsock.h
+endif()
+set_define(WIN32_LEAN_AND_MEAN)
+check_include_file_concat(arpa/inet.h HAVE_ARPA_INET_H)
+check_include_file_concat(conio.h HAVE_CONIO_H)
+check_include_file_concat(crypt.h HAVE_CRYPT_H)
+check_include_file_concat(ctype.h HAVE_CTYPE_H)
+check_include_file_concat(dirent.h HAVE_DIRENT_H)
+check_include_file_concat(errno.h HAVE_ERRNO_H)
+check_include_file_concat(fcntl.h HAVE_FCNTL_H)
+check_include_file_concat(io.h HAVE_IO_H)
+check_include_file_concat(limits.h HAVE_LIMITS_H)
+check_include_file_concat(netdb.h HAVE_NETDB_H)
+check_include_file_concat(netinet/in.h HAVE_NETINET_IN_H)
+check_include_file_concat(netinet/sctp.h HAVE_NETINET_SCTP_H)
+check_include_file_concat(netinet/sctp_uio.h HAVE_NETINET_SCTP_UIO_H)
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS AND HAVE_NETINET_IN_H)
+  # TRICKY: Solaris needs an extra include, netinet/tcp.h doesn't compile by itself
+  set(additionalInc netinet/in.h)
+endif()
+check_include_file_concat(netinet/tcp.h HAVE_NETINET_TCP_H ${additionalInc})
+check_include_file_concat(process.h HAVE_PROCESS_H)
+check_include_file_concat(pthread.h HAVE_PTHREAD_H)
+check_include_file_concat(semaphore.h HAVE_SEMAPHORE_H)
+check_include_file_concat(signal.h HAVE_SIGNAL_H)
+check_include_file_concat(stdarg.h HAVE_STDARG_H)
+check_include_file_concat(stdint.h HAVE_STDINT_H)
+check_include_file_concat(stdio.h HAVE_STDIO_H)
+check_include_file_concat(stdlib.h HAVE_STDLIB_H)
+check_include_file_concat(string.h HAVE_STRING_H)
+check_include_file_concat(strings.h HAVE_STRINGS_H)
+check_include_file_concat(sys/ioctl.h HAVE_SYS_IOCTL_H)
+check_include_file_concat(sys/sendfile.h HAVE_SYS_SENDFILE_H)
+check_include_file_concat(sys/signal.h HAVE_SYS_SIGNAL_H)
+check_include_file_concat(sys/socket.h HAVE_SYS_SOCKET_H)
+check_include_file_concat(sys/sockio.h HAVE_SYS_SOCKIO_H)
+check_include_file_concat(sys/syslimits.h HAVE_SYS_SYSLIMITS_H)
+check_include_file_concat(sys/time.h HAVE_SYS_TIME_H)
+check_include_file_concat(sys/types.h HAVE_SYS_TYPES_H)
+check_include_file_concat(sys/uio.h HAVE_SYS_UIO_H)
+check_include_file_concat(sys/un.h HAVE_SYS_UN_H)
+check_include_file_concat(sys/wait.h HAVE_SYS_WAIT_H)
+check_include_file_concat(time.h HAVE_TIME_H)
+check_include_file_concat(unistd.h HAVE_UNISTD_H)
+check_include_file_concat(winsock2.h HAVE_WINSOCK2_H)
+check_include_file_concat(ByteOrder.h HAVE_BYTEORDER_H)
+check_include_file_concat(dir.h HAVE_DIR_H)
+check_include_file_concat(dlfcn.h HAVE_DLFCN_H)
+check_include_file_concat(dl.h HAVE_DL_H)
+check_include_file_concat(grp.h HAVE_GRP_H)
+check_include_file_concat(inttypes.h HAVE_INTTYPES_H)
+check_include_file_concat(kernel/OS.h HAVE_KERNEL_OS_H)
+check_include_file_concat(langinfo.h HAVE_LANGINFO_H)
+check_include_file_concat(mach-o/dyld.h HAVE_MACH_O_DYLD_H)
+check_include_file_concat(malloc.h HAVE_MALLOC_H)
+check_include_file_concat(memory.h HAVE_MEMORY_H)
+check_include_file_concat(net/errno.h HAVE_NET_ERRNO_H)
+check_include_file_concat(os2.h HAVE_OS2_H)
+check_include_file_concat(osreldate.h HAVE_OSRELDATE_H)
+check_include_file_concat(OS.h HAVE_OS_H)
+check_include_file_concat(poll.h HAVE_POLL_H)
+check_include_file_concat(pwd.h HAVE_PWD_H)
+check_include_file_concat(sched.h HAVE_SCHED_H) #TODO: configure diff
+check_include_file_concat(stddef.h HAVE_STDDEF_H)
+check_include_file_concat(sysapi.h HAVE_SYSAPI_H)
+check_include_file_concat(sysgtime.h HAVE_SYSGTIME_H)
+check_include_file_concat(sys/file.h HAVE_SYS_FILE_H)
+check_include_file_concat(sys/ipc.h HAVE_SYS_IPC_H)
+check_include_file_concat(sys/mman.h HAVE_SYS_MMAN_H)
+check_include_file_concat(sys/mutex.h HAVE_SYS_MUTEX_H)
+check_include_file_concat(sys/param.h HAVE_SYS_PARAM_H)
+check_include_file_concat(sys/poll.h HAVE_SYS_POLL_H)
+check_include_file_concat(sys/resource.h HAVE_SYS_RESOURCE_H)
+check_include_file_concat(sys/select.h HAVE_SYS_SELECT_H)
+check_include_file_concat(sys/sem.h HAVE_SYS_SEM_H)
+check_include_file_concat(sys/shm.h HAVE_SYS_SHM_H)
+check_include_file_concat(sys/stat.h HAVE_SYS_STAT_H)
+check_include_file_concat(sys/sysctl.h HAVE_SYS_SYSCTL_H)
+check_include_file_concat(sys/uuid.h HAVE_SYS_UUID_H)
+check_include_file_concat(termios.h HAVE_TERMIOS_H)
+check_include_file_concat(tpfeq.h HAVE_TPFEQ_H)
+check_include_file_concat(tpfio.h HAVE_TPFIO_H)
+check_include_file_concat(unix.h HAVE_UNIX_H)
+check_include_file_concat(uuid.h HAVE_UUID_H)
+check_include_file_concat(uuid/uuid.h HAVE_UUID_UUID_H)
+check_include_file_concat(alloca.h HAVE_ALLOCA_H)
+##########
+check_library_exists_concat(bsd random HAVE_LIBBSD)
+check_library_exists_concat(sendfile sendfilev HAVE_LIBSENDFILE)
+check_library_exists_concat(truerand main HAVE_LIBTRUERAND)
+check_library_exists_concat(rt shm_open HAVE_LIBRT)
+check_library_exists_concat(pthread pthread_yield HAVE_LIBPTHREAD)
+check_library_exists_concat(dl dlopen HAVE_LIBDL)
+check_library_exists_concat(socket connect HAVE_LIBSOCKET)
+check_library_exists_concat(nsl gethostbyaddr HAVE_LIBNSL)
+#check_library_exists_concat(ws2_32 getch HAVE_LIBWS2_32)
+##########
+check_exists_define01(accept4 HAVE_ACCEPT4)
+check_exists_define01(calloc HAVE_CALLOC)
+check_exists_define01(create_area HAVE_CREATE_AREA)
+check_exists_define01(create_sem HAVE_CREATE_SEM)
+check_exists_define01(dup3 HAVE_DUP3)
+check_exists_define01(epoll_create1 HAVE_EPOLL_CREATE1)
+check_exists_define01(fdatasync HAVE_FDATASYNC)
+check_exists_define01(flock HAVE_FLOCK)
+check_exists_define01(fork HAVE_FORK)
+check_exists_define01(gai_strerror HAVE_GAI_STRERROR)
+check_exists_define01(getenv HAVE_GETENV)
+check_exists_define01(getgrgid_r HAVE_GETGRGID_R)
+check_exists_define01(getgrnam_r HAVE_GETGRNAM_R)
+check_exists_define01(gethostbyaddr_r HAVE_GETHOSTBYADDR_R)
+check_exists_define01(gethostbyname_r HAVE_GETHOSTBYNAME_R)
+check_exists_define01(getifaddrs HAVE_GETIFADDRS)
+check_exists_define01(getnameinfo HAVE_GETNAMEINFO)
+check_exists_define01(getpass HAVE_GETPASS)
+check_exists_define01(getpassphrase HAVE_GETPASSPHRASE)
+check_exists_define01(getpwnam_r HAVE_GETPWNAM_R)
+check_exists_define01(getpwuid_r HAVE_GETPWUID_R)
+check_exists_define01(getrlimit HAVE_GETRLIMIT)
+check_exists_define01(getservbyname_r HAVE_GETSERVBYNAME_R)
+check_exists_define01(gmtime_r HAVE_GMTIME_R)
+check_exists_define01(isinf HAVE_ISINF)
+check_exists_define01(isnan HAVE_ISNAN)
+check_exists_define01(kqueue HAVE_KQUEUE)
+check_exists_define01(localtime_r HAVE_LOCALTIME_R)
+check_exists_define01(memchr HAVE_MEMCHR)
+check_exists_define01(memmove HAVE_MEMMOVE)
+check_exists_define01(mkstemp HAVE_MKSTEMP)
+check_exists_define01(mkstemp64 HAVE_MKSTEMP64) #TODO: configure diff
+check_exists_define01(mmap HAVE_MMAP)
+check_exists_define01(mmap64 HAVE_MMAP64) #TODO: configure diff
+check_exists_define01(munmap HAVE_MUNMAP)
+check_exists_define01(nl_langinfo HAVE_NL_LANGINFO)
+check_exists_define01(poll HAVE_POLL)
+check_exists_define01(port_create HAVE_PORT_CREATE)
+check_exists_define01(pthread_attr_setguardsize HAVE_PTHREAD_ATTR_SETGUARDSIZE)
+check_exists_define01(pthread_key_delete HAVE_PTHREAD_KEY_DELETE)
+check_exists_define01(pthread_mutexattr_setpshared HAVE_PTHREAD_MUTEXATTR_SETPSHARED)
+check_exists_define01(pthread_rwlock_init HAVE_PTHREAD_RWLOCK_INIT)
+check_exists_define01(pthread_yield HAVE_PTHREAD_YIELD)
+check_exists_define01(putenv HAVE_PUTENV)
+check_exists_define01(readdir64_r HAVE_READDIR64_R) #TODO: configure diff
+check_exists_define01(sched_yield HAVE_SCHED_YIELD) #TODO: configure diff
+check_exists_define01(semctl HAVE_SEMCTL)
+check_exists_define01(semget HAVE_SEMGET)
+check_exists_define01(sem_close HAVE_SEM_CLOSE)
+check_exists_define01(sem_post HAVE_SEM_POST)
+check_exists_define01(sem_unlink HAVE_SEM_UNLINK)
+check_exists_define01(sem_wait HAVE_SEM_WAIT)
+check_exists_define01(sendfile HAVE_SENDFILE)
+check_exists_define01(sendfile64 HAVE_SENDFILE64) #TODO: configure diff
+check_exists_define01(sendfilev HAVE_SENDFILEV)
+check_exists_define01(sendfilev64 HAVE_SENDFILEV64)
+check_exists_define01(send_file HAVE_SEND_FILE)
+check_exists_define01(setenv HAVE_SETENV)
+check_exists_define01(setrlimit HAVE_SETRLIMIT)
+check_exists_define01(setsid HAVE_SETSID)
+check_exists_define01(set_h_errno HAVE_SET_H_ERRNO)
+check_exists_define01(shmat HAVE_SHMAT)
+check_exists_define01(shmctl HAVE_SHMCTL)
+check_exists_define01(shmdt HAVE_SHMDT)
+check_exists_define01(shmget HAVE_SHMGET)
+check_exists_define01(shm_open HAVE_SHM_OPEN)
+check_exists_define01(shm_unlink HAVE_SHM_UNLINK)
+check_exists_define01(sigaction HAVE_SIGACTION)
+check_exists_define01(sigsuspend HAVE_SIGSUSPEND)
+check_exists_define01(sigwait HAVE_SIGWAIT)
+check_exists_define01(strcasecmp HAVE_STRCASECMP)
+check_exists_define01(strdup HAVE_STRDUP)
+check_exists_define01(strerror_r HAVE_STRERROR_R)
+check_exists_define01(stricmp HAVE_STRICMP)
+check_exists_define01(strncasecmp HAVE_STRNCASECMP)
+check_exists_define01(strnicmp HAVE_STRNICMP)
+check_exists_define01(strstr HAVE_STRSTR)
+check_exists_define01(unsetenv HAVE_UNSETENV)
+check_exists_define01(utime HAVE_UTIME)
+check_exists_define01(utimes HAVE_UTIMES)
+check_exists_define01(uuid_create HAVE_UUID_CREATE)
+check_exists_define01(uuid_generate HAVE_UUID_GENERATE)
+check_exists_define01(waitpid HAVE_WAITPID)
+check_exists_define01(writev HAVE_WRITEV)
+##########
+check_symbol_exists_define01(alloca alloca.h HAVE_ALLOCA)
+check_symbol_exists_define01(BONE_VERSION sys/socket.h HAVE_BONE_VERSION)
+check_symbol_exists_define01(F_SETLK fcntl.h HAVE_F_SETLK)
+check_symbol_exists_define01(LOCK_EX sys/file.h HAVE_LOCK_EX)
+check_symbol_exists_define01(MAP_ANON sys/mman.h HAVE_MAP_ANON)
+check_symbol_exists_define01(POLLIN poll.h HAVE_POLLIN)
+if(NOT HAVE_POLLIN)
+  check_symbol_exists_define01(POLLIN sys/poll.h HAVE_POLLIN)
+endif()
+check_symbol_exists_define01(PTHREAD_PROCESS_SHARED pthread.h HAVE_PTHREAD_PROCESS_SHARED)
+check_symbol_exists_define01(SEM_UNDO sys/sem.h HAVE_SEM_UNDO)
+check_symbol_exists_define01(SO_ACCEPTFILTER sys/socket.h HAVE_SO_ACCEPTFILTER)
+check_symbol_exists_define01(TCP_CORK netinet/tcp.h HAVE_TCP_CORK)
+check_symbol_exists_define01(TCP_NOPUSH netinet/tcp.h HAVE_TCP_NOPUSH)
+##########
+set(CMAKE_EXTRA_INCLUDE_FILES ${APR_INCLUDES})
+check_type_size(char SIZEOF_CHAR)
+check_type_size(ino_t SIZEOF_INO_T) # sets HAVE_SIZEOF_INO_T
+check_type_size(int SIZEOF_INT)
+check_type_size(long SIZEOF_LONG)
+check_type_size("long long" SIZEOF_LONG_LONG)
+check_type_size(off_t SIZEOF_OFF_T) # sets HAVE_SIZEOF_OFF_T
+check_type_size(pid_t SIZEOF_PID_T) # sets HAVE_SIZEOF_PID_T
+check_type_size(short SIZEOF_SHORT)
+check_type_size(size_t SIZEOF_SIZE_T) # sets HAVE_SIZEOF_SIZE_T
+check_type_size(ssize_t SIZEOF_SSIZE_T) # sets HAVE_SIZEOF_SSIZE_T
+check_type_size("struct iovec" SIZEOF_STRUCT_IOVEC) # sets HAVE_SIZEOF_STRUCT_IOVEC
+check_type_size("void*" SIZEOF_VOIDP)
+check_type_size("struct ip_mreq" STRUCT_IPMREQ) # sets HAVE_STRUCT_IPMREQ
+set_define(HAVE_STRUCT_IPMREQ 1)
+check_type_size(socklen_t SOCKLEN_T) # sets HAVE_SOCKLEN_T
+set_define(HAVE_SOCKLEN_T 1)
+check_type_size(gid_t GID_T) # sets HAVE_GIT_T
+check_type_size(uid_t UID_T) # sets HAVE_UID_T
+check_type_size("struct rlimit" STRUCT_RLIMIT) # sets HAVE_STRUCT_RLIMIT
+set(CMAKE_EXTRA_INCLUDE_FILES)
+########################################
+if(NOT HAVE_GID_T)
+  set(gid_t "int") # Define to `int' if <sys/types.h> doesn't define.
+endif()
+if(NOT HAVE_SIZEOF_OFF_T)
+  set(off_t "long int") # Define to `long int' if <sys/types.h> does not define.
+  set(off_t_value ${off_t}) # used by apr.h.in
+else()
+  set(off_t_value off_t) # used by apr.h.in
+endif()
+if(NOT HAVE_SIZEOF_PID_T)
+  set(pid_t "int") # Define to `int' if <sys/types.h> does not define.
+endif()
+if(NOT HAVE_SIZEOF_SIZE_T)
+  set(size_t "unsigned int") # Define to `unsigned int' if <sys/types.h> does not define.
+  set(size_t_value apr_int32_t) # used by apr.h.in
+else()
+  set(size_t_value size_t) # used by apr.h.in
+endif()
+if(NOT HAVE_SIZEOF_SSIZE_T)
+  if(HAVE_WINDOWS_H AND SIZEOF_SIZE_T EQUAL 8)
+    set(ssize_t "__int64")
+  else()
+    set(ssize_t "int") # Define to `int' if <sys/types.h> does not define.
+  endif()
+  set(ssize_t_value apr_int32_t) # used by apr.h.in
+else()
+  set(ssize_t_value ssize_t) # used by apr.h.in
+endif()
+if(NOT HAVE_UID_T)
+  set(uid_t "int") # Define to `int' if <sys/types.h> doesn't define.
+endif()
+if(NOT HAVE_SOCKLEN_T)
+  set(socklen_t_value int)
+else()
+  set(socklen_t_value socklen_t)
+endif()
+if(NOT HAVE_SIZEOF_INO_T)
+  set(ino_t_value apr_int64_t) #TODO: determine
+else()
+  set(ino_t_value ino_t)
+endif()
+########################################
+if(HAVE_SYS_STAT_H)
+  set(statHdr sys/stat.h)
+else()
+  set(statHdr unknown.h)
+endif()
+check_struct_has_member01("struct stat" st_atimensec ${statHdr} HAVE_STRUCT_STAT_ST_ATIMENSEC)
+check_struct_has_member01("struct stat" st_atime_n ${statHdr} HAVE_STRUCT_STAT_ST_ATIME_N)
+check_struct_has_member01("struct stat" st_atim.tv_nsec ${statHdr} HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC)
+check_struct_has_member01("struct stat" st_blocks ${statHdr} HAVE_STRUCT_STAT_ST_BLOCKS)
+check_struct_has_member01("struct stat" st_ctimensec ${statHdr} HAVE_STRUCT_STAT_ST_CTIMENSEC)
+check_struct_has_member01("struct stat" st_ctime_n ${statHdr} HAVE_STRUCT_STAT_ST_CTIME_N)
+check_struct_has_member01("struct stat" st_ctim.tv_nsec ${statHdr} HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC)
+check_struct_has_member01("struct stat" st_mtimensec ${statHdr} HAVE_STRUCT_STAT_ST_MTIMENSEC)
+check_struct_has_member01("struct stat" st_mtime_n ${statHdr} HAVE_STRUCT_STAT_ST_MTIME_N)
+check_struct_has_member01("struct stat" st_mtim.tv_nsec ${statHdr} HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC)
+if(HAVE_TIME_H)
+  set(tmHdr time.h)
+else()
+  set(tmHdr unknown.h)
+endif()
+check_struct_has_member01("struct tm" tm_gmtoff ${tmHdr} HAVE_STRUCT_TM_TM_GMTOFF)
+check_struct_has_member01("struct tm" __tm_gmtoff ${tmHdr} HAVE_STRUCT_TM___TM_GMTOFF)
+########################################
+# Define if building universal (internal helper macro)
+set(AC_APPLE_UNIVERSAL_BUILD) #TODO: determine on Apple
+set_define(AC_APPLE_UNIVERSAL_BUILD)
+####################
+# path of random device
+if(EXISTS /dev/urandom)
+  set(DEV_RANDOM /dev/urandom)
+endif()
+set_define(DEV_RANDOM)
+####################
+# Define to the sub-directory in which libtool stores uninstalled libraries.
+execute_process(COMMAND libtool --version
+  OUTPUT_QUIET ERROR_QUIET RESULT_VARIABLE hasLibtool
+  )
+if(hasLibtool EQUAL 0) # 0 == success
+  set(LT_OBJDIR .libs/)
+endif()
+####################
+# Name of package
+set(PACKAGE "APR")
+# Version number of package
+file(STRINGS include/apr_version.h MAJOR REGEX "^#define[\t ]+APR_MAJOR_VERSION[ \t]+([0-9]+)")
+file(STRINGS include/apr_version.h MINOR REGEX "^#define[\t ]+APR_MINOR_VERSION[ \t]+([0-9]+)")
+file(STRINGS include/apr_version.h PATCH REGEX "^#define[\t ]+APR_PATCH_VERSION[ \t]+([0-9]+)")
+string(REGEX MATCH "([0-9]+)" MAJOR ${MAJOR})
+string(REGEX MATCH "([0-9]+)" MINOR ${MINOR})
+string(REGEX MATCH "([0-9]+)" PATCH ${PATCH})
+set(VERSION ${MAJOR}.${MINOR}.${PATCH})
+# Define to the address where bug reports for this package should be sent.
+set(PACKAGE_BUGREPORT "ASF Bugzilla: https://bz.apache.org/bugzilla/enter_bug.cgi?product=APR")
+# Define to the full name of this package.
+set(PACKAGE_NAME ${PACKAGE})
+# Define to the version of this package.
+set(PACKAGE_VERSION ${VERSION})
+# Define to the full name and version of this package.
+set(PACKAGE_STRING "${PACKAGE} ${PACKAGE_VERSION}")
+# Define to the one symbol short name of this package.
+set(PACKAGE_TARNAME ${PACKAGE})
+# Define to the home page for this package.
+set(PACKAGE_URL http://apr.apache.org)
+####################
+# Define to 1 if you have the ANSI C header files.
+set(STDC_HEADERS TRUE) #TODO: determine if true
+set_define(STDC_HEADERS 1)
+####################
+set(_ALL_SOURCE TRUE)
+set_define(_ALL_SOURCE 1)
+###
+set(_GNU_SOURCE TRUE)
+set_define(_GNU_SOURCE 1)
+add_definitions(-D_GNU_SOURCE)
+###
+set(_POSIX_PTHREAD_SEMANTICS TRUE)
+set_define(_POSIX_PTHREAD_SEMANTICS 1)
+add_definitions(-D_POSIX_PTHREAD_SEMANTICS)
+###
+set(_TANDEM_SOURCE TRUE)
+set_define(_TANDEM_SOURCE 1)
+###
+set(__EXTENSIONS__ TRUE) #TODO: determine (configure does)
+set_define(__EXTENSIONS__ 1)
+####################
+# Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+# significant byte first (like Motorola and SPARC, unlike Intel).
+test_big_endian(WORDS_BIGENDIAN)
+set_define(WORDS_BIGENDIAN 1)
+########################################
+set(apr_include_arpainet "
+#ifdef HAVE_ARPA_INET_H
+# include <arpa/inet.h>
+#endif"
+  )
+set(apr_include_netdb "
+#ifdef HAVE_NETDB_H
+# include <netdb.h>
+#endif"
+  )
+set(apr_include_netinetin "
+#ifdef HAVE_NETINET_IN_H
+# include <netinet/in.h>
+#endif"
+  )
+set(apr_include_netinetsctp "
+#ifdef HAVE_NETINET_SCTP_H
+# include <netinet/sctp.h>
+#endif
+#ifdef HAVE_NETINET_SCTP_UIO_H
+# include <netinet/sctp_uio.h>
+#endif"
+  )
+set(apr_include_stdint "
+#ifdef HAVE_STDINT_H
+# include <stdint.h>
+#endif"
+  )
+set(apr_include_stdlib "
+#ifdef HAVE_STDLIB_H
+# include <stdlib.h>
+#endif"
+  )
+set(apr_include_string "
+#ifdef HAVE_STRING_H
+# include <string.h>
+#endif"
+  )
+set(apr_include_sysipc "
+#ifdef HAVE_SYS_IPC_H
+# include <sys/ipc.h>
+#endif"
+  )
+set(apr_include_syssem "
+#ifdef HAVE_SYS_SEM_H
+# include <sys/sem.h>
+#endif"
+  )
+set(apr_include_systypes "
+#ifdef HAVE_SYS_TYPES_H
+# include <sys/types.h>
+#endif"
+  )
+set(apr_include_syssocket "
+#ifdef HAVE_SYS_SOCKET_H
+# include <sys/socket.h>
+#endif"
+  )
+set(apr_include_windows "
+#ifdef HAVE_WINDOWS_H
+# ifndef WIN32_LEAN_AND_MEAN
+#  define WIN32_LEAN_AND_MEAN
+# endif
+# include <windows.h>
+#endif"
+  )
+set(apr_include_winsock "
+#ifdef HAVE_WINSOCK2_H
+# include <winsock2.h>
+#endif"
+  )
+########################################
+# Define if getaddrinfo accepts the AI_ADDRCONFIG flag
+check_c_source_compiles("
+${apr_include_netdb}
+${apr_include_string}
+${apr_include_systypes}
+${apr_include_syssocket}
+int main(int argc, char **argv)
+{
+  struct addrinfo hints, *ai;
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_family = AF_UNSPEC;
+  hints.ai_socktype = SOCK_STREAM;
+  hints.ai_flags = AI_ADDRCONFIG;
+  return getaddrinfo(\"localhost\", NULL, &hints, &ai) != 0;
+}
+" HAVE_GAI_ADDRCONFIG
+  )
+set_define(HAVE_GAI_ADDRCONFIG 1)
+########################################
+# Define to 1 if getaddrinfo exists and works well enough for APR
+check_c_source_compiles("
+${apr_include_netdb}
+${apr_include_string}
+${apr_include_systypes}
+${apr_include_syssocket}
+int main(void)
+{
+  struct addrinfo hints;
+  struct addrinfo *ai = 0;
+  int error;
+  memset(&hints, 0, sizeof(hints));
+  hints.ai_flags = AI_NUMERICHOST;
+  hints.ai_family = AF_UNSPEC;
+  hints.ai_socktype = SOCK_STREAM;
+  error = getaddrinfo(\"127.0.0.1\", NULL, &hints, &ai);
+  if(error || !ai || ai->ai_addr->sa_family != AF_INET)
+    exit(1); /* fail */
+  exit(0);
+}
+" HAVE_GETADDRINFO
+  )
+set_define(HAVE_GETADDRINFO 1)
+########################################
+# Define to empty if `const' does not conform to ANSI C.
+check_c_source_compiles("
+int main()
+{
+#ifndef __cplusplus
+  /* Ultrix mips cc rejects this sort of thing.  */
+  typedef int charset[2];
+  const charset cs = { 0, 0 };
+  /* SunOS 4.1.1 cc rejects this.  */
+  char const *const *pcpcc;
+  char **ppc;
+  /* NEC SVR4.0.2 mips cc rejects this.  */
+  struct point {int x, y;};
+  static struct point const zero = {0,0};
+  /* AIX XL C 1.02.0.0 rejects this.
+     It does not let you subtract one const X* pointer from another in
+     an arm of an if-expression whose if-part is not a constant
+     expression */
+  const char *g = \"string\";
+  pcpcc = &g + (g ? g-g : 0);
+  /* HPUX 7.0 cc rejects these. */
+  ++pcpcc;
+  ppc = (char**) pcpcc;
+  pcpcc = (char const *const *) ppc;
+  { /* SCO 3.2v4 cc rejects this sort of thing.  */
+    char tx;
+    char *t = &tx;
+    char const *s = 0 ? (char *) 0 : (char const *) 0;
+
+    *t++ = 0;
+    if (s) return 0;
+  }
+  { /* Someone thinks the Sun supposedly-ANSI compiler will reject this.  */
+    int x[] = {25, 17};
+    const int *foo = &x[0];
+    ++foo;
+  }
+  { /* Sun SC1.0 ANSI compiler rejects this -- but not the above. */
+    typedef const int *iptr;
+    iptr p = 0;
+    ++p;
+  }
+  { /* AIX XL C 1.02.0.0 rejects this sort of thing, saying
+       \"k.c\", line 2.27: 1506-025 (S) Operand must be a modifiable lvalue. */
+    struct s { int j; const int *ap[3]; } bx;
+    struct s *b = &bx; b->j = 5;
+  }
+  { /* ULTRIX-32 V3.1 (Rev 9) vcc rejects this */
+    const int foo = 10;
+    if (!foo) return 0;
+  }
+  return !cs[0] && !zero.x;
+#endif
+  ;
+  return 0;
+}
+" ANSI_CONST
+  )
+if(NOT ANSI_CONST)
+  set(const empty)
+endif()
+set_define(const)
+########################################
+check_c_source_compiles("
+${apr_include_systypes}
+${apr_include_netinetin}
+${apr_include_winsock}
+int main(void)
+{
+  struct in_addr arg;
+  arg.s_addr = htonl(INADDR_ANY);
+  ;
+  return 0;
+}
+" HAVE_IN_ADDR
+  )
+########################################
+check_c_source_compiles("
+${apr_include_systypes}
+${apr_include_arpainet}
+int main(void)
+{
+  inet_addr(\"127.0.0.1\");
+  ;
+  return 0;
+}
+" HAVE_INET_ADDR
+  )
+########################################
+check_c_source_compiles("
+${apr_include_systypes}
+${apr_include_arpainet}
+int main(void)
+{
+  inet_network(\"127.0.0.1\");
+  ;
+  return 0;
+}
+" HAVE_INET_NETWORK
+  )
+########################################
+check_c_source_compiles("
+${apr_include_systypes}
+${apr_include_netinetin}
+int main(void)
+{
+  struct sockaddr_storage sa;
+  ;
+  return 0;
+}
+" HAVE_SA_STORAGE
+  )
+########################################
+check_c_source_compiles("
+${apr_include_systypes}
+${apr_include_sysipc}
+${apr_include_syssem}
+int main(void)
+{
+  union semun arg;
+  semctl(0,0,0,arg);
+  ;
+  return 0;
+}
+" HAVE_UNION_SEMUN
+  )
+########################################
+check_c_source_compiles("
+${apr_include_systypes}
+${apr_include_syssocket}
+${apr_include_netinetin}
+${apr_include_netinetsctp}
+${apr_include_stdlib}
+int main(void)
+{
+  int s, opt = 1;
+  if ((s = socket(AF_INET, SOCK_STREAM, IPPROTO_SCTP)) < 0)
+    exit(1);
+  if (setsockopt(s, IPPROTO_SCTP, SCTP_NODELAY, &opt, sizeof(int)) < 0)
+    exit(2);
+  exit(0);
+}
+" HAVE_SCTP
+  )
+########################################
+check_c_source_compiles("
+${apr_include_systypes}
+${apr_include_netinetin}
+int main(void)
+{
+  struct sockaddr_in6 sa;
+  ;
+  return 0;
+}
+" HAVE_SOCKADDR_IN6
+  )
+########################################
+check_c_source_compiles("
+${apr_include_stdint}
+int main(void)
+{
+#ifdef INT64_C
+  return 0;
+#else
+  return 1;
+#endif
+}
+" HAVE_INT64_C_DEFINED
+  )
+########################################
+unset(inline)
+########################################
+set(APR_ALLOCATOR_USES_MMAP FALSE) #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(APR_INT64_STRFN strtoll) #TODO: determine
+  set(APR_OFF_T_STRFN strtoll) #TODO: determine
+else()
+  set(APR_INT64_STRFN strtol) #TODO: determine
+  set(APR_OFF_T_STRFN strtol) #TODO: determine
+endif()
+set(CRAY_STACKSEG_END FALSE) #TODO: determine
+set(C_ALLOCA FALSE) #TODO: determine
+list(APPEND cmakedefine
+  APR_INT64_STRFN
+  APR_OFF_T_STRFN
+  )
+list(APPEND cmakedefine01
+  APR_ALLOCATOR_USES_MMAP
+  CRAY_STACKSEG_END
+  C_ALLOCA
+  )
+########################################
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(DIRENT_INODE d_ino) #TODO: determine
+  set(DIRENT_TYPE) #TODO: determine
+else()
+  set(DIRENT_INODE d_fileno) #TODO: determine
+  set(DIRENT_TYPE d_type) #TODO: determine
+endif()
+list(APPEND cmakedefine
+  DIRENT_INODE
+  DIRENT_TYPE
+  )
+########################################
+# DSO support TODO: determine
+set(DSO_USE_DLFCN TRUE) # uses dlfcn.h
+set(DSO_USE_DYLD FALSE) # uses dyld.h
+set(DSO_USE_SHL FALSE) # uses shl_load
+list(APPEND cmakedefine01
+  DSO_USE_DLFCN
+  DSO_USE_DYLD
+  DSO_USE_SHL
+  )
+########################################
+set(EGD_DEFAULT_SOCKET FALSE) #TODO: determine
+list(APPEND cmakedefine EGD_DEFAULT_SOCKET)
+########################################
+set(FCNTL_IS_GLOBAL FALSE) #TODO: determine
+set(FCNTL_TRYACQUIRE_EACCES FALSE) #TODO: determine
+set(FLOCK_IS_GLOBAL FALSE) #TODO: determine
+list(APPEND cmakedefine01
+  FCNTL_IS_GLOBAL
+  FCNTL_TRYACQUIRE_EACCES
+  FLOCK_IS_GLOBAL
+  )
+########################################
+set(GETHOSTBYADDR_IS_THREAD_SAFE FALSE) #TODO: determine
+set(GETHOSTBYNAME_IS_THREAD_SAFE FALSE) #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(GETHOSTBYNAME_R_GLIBC2 FALSE) #TODO: determine
+  set(GETSERVBYNAME_R_GLIBC2 FALSE) #TODO: determine
+  set(GETSERVBYNAME_R_SOLARIS TRUE) #TODO: determine
+else()
+  set(GETHOSTBYNAME_R_GLIBC2 TRUE) #TODO: determine
+  set(GETSERVBYNAME_R_GLIBC2 TRUE) #TODO: determine
+  set(GETSERVBYNAME_R_SOLARIS FALSE) #TODO: determine
+endif()
+set(GETHOSTBYNAME_R_HOSTENT_DATA FALSE) #TODO: determine
+set(GETSERVBYNAME_IS_THREAD_SAFE FALSE) #TODO: determine
+set(GETSERVBYNAME_R_OSF1 FALSE) #TODO: determine
+list(APPEND cmakedefine01
+  GETHOSTBYADDR_IS_THREAD_SAFE
+  GETHOSTBYNAME_IS_THREAD_SAFE
+  GETHOSTBYNAME_R_GLIBC2
+  GETHOSTBYNAME_R_HOSTENT_DATA
+  GETSERVBYNAME_IS_THREAD_SAFE
+  GETSERVBYNAME_R_GLIBC2
+  GETSERVBYNAME_R_OSF1
+  GETSERVBYNAME_R_SOLARIS
+  )
+########################################
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(HAVE_DECL_SYS_SIGLIST FALSE) #TODO: determine
+else()
+  set(HAVE_DECL_SYS_SIGLIST TRUE) #TODO: determine
+endif()
+set01(HAVE_DECL_SYS_SIGLIST HAVE_DECL_SYS_SIGLIST)
+########################################
+set(HAVE_AIO_MSGQ FALSE) #TODO: determine
+set(HAVE_ATOMIC_BUILTINS TRUE) #TODO: determine
+set(HAVE_EGD FALSE) #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(HAVE_EPOLL FALSE) #TODO: determine
+else()
+  set(HAVE_EPOLL TRUE) #TODO: determine
+endif()
+set(HAVE_HSTRERROR FALSE) #TODO: determine
+set(HAVE_PTHREAD_MUTEX_RECURSIVE TRUE) #TODO: determine
+set(HAVE_PTHREAD_MUTEX_ROBUST TRUE) #TODO: determine
+set(HAVE_PTHREAD_RWLOCKS TRUE) #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(HAVE_SOCK_CLOEXEC FALSE) #TODO: determine
+  set(HAVE_TCP_NODELAY_WITH_CORK FALSE) #TODO: determine
+else()
+  set(HAVE_SOCK_CLOEXEC TRUE) #TODO: determine
+  set(HAVE_TCP_NODELAY_WITH_CORK TRUE) #TODO: determine
+endif()
+set(HAVE_TRUERAND FALSE) #TODO: determine
+set(HAVE_VLA TRUE) #TODO: determine
+set(HAVE_ZOS_PTHREADS FALSE) #TODO: determine
+list(APPEND cmakedefine01
+  HAVE_AIO_MSGQ
+  HAVE_ATOMIC_BUILTINS
+  HAVE_EGD
+  HAVE_EPOLL
+  HAVE_HSTRERROR
+  HAVE_PTHREAD_MUTEX_RECURSIVE
+  HAVE_PTHREAD_MUTEX_ROBUST
+  HAVE_PTHREAD_RWLOCKS
+  HAVE_SOCK_CLOEXEC
+  HAVE_TCP_NODELAY_WITH_CORK
+  HAVE_TRUERAND
+  HAVE_VLA
+  HAVE_ZOS_PTHREADS
+  )
+########################################
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(NEGATIVE_EAI FALSE) #TODO: determine
+else()
+  set(NEGATIVE_EAI TRUE) #TODO: determine
+endif()
+set(POSIXSEM_IS_GLOBAL FALSE) #TODO: determine
+set(PPC405_ERRATA FALSE) #TODO: determine
+set(PTHREAD_ATTR_GETDETACHSTATE_TAKES_ONE_ARG FALSE) #TODO: determine
+set(PTHREAD_GETSPECIFIC_TAKES_TWO_ARGS FALSE) #TODO: determine
+set(READDIR_IS_THREAD_SAFE FALSE) #TODO: determine
+set(SETPGRP_VOID TRUE) #TODO: determine
+set(SIGWAIT_TAKES_ONE_ARG FALSE) #TODO: determine
+set(STACK_DIRECTION FALSE) #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(STRERROR_R_RC_INT TRUE) #TODO: determine
+else()
+  set(STRERROR_R_RC_INT FALSE) #TODO: determine
+endif()
+set(SYSVSEM_IS_GLOBAL FALSE) #TODO: determine
+list(APPEND cmakedefine01
+  NEGATIVE_EAI
+  POSIXSEM_IS_GLOBAL
+  PPC405_ERRATA
+  PTHREAD_ATTR_GETDETACHSTATE_TAKES_ONE_ARG
+  PTHREAD_GETSPECIFIC_TAKES_TWO_ARGS
+  READDIR_IS_THREAD_SAFE
+  SETPGRP_VOID
+  SIGWAIT_TAKES_ONE_ARG
+  STACK_DIRECTION
+  STRERROR_R_RC_INT
+  SYSVSEM_IS_GLOBAL
+  )
+########################################
+set(USE_ATOMICS_GENERIC FALSE) #TODO: determine
+set(USE_BEOSSEM FALSE) #TODO: determine
+set(USE_FCNTL_SERIALIZE FALSE) #TODO: determine
+set(USE_FLOCK_SERIALIZE FALSE) #TODO: determine
+set(USE_POSIXSEM_SERIALIZE FALSE) #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(USE_PROC_PTHREAD_SERIALIZE TRUE) #TODO: determine
+else()
+  set(USE_PROC_PTHREAD_SERIALIZE FALSE) #TODO: determine
+endif()
+set(USE_SHMEM_BEOS FALSE) #TODO: determine
+set(USE_SHMEM_BEOS_ANON FALSE) #TODO: determine
+set(USE_SHMEM_MMAP_ANON TRUE) #TODO: determine
+set(USE_SHMEM_MMAP_SHM FALSE) #TODO: determine
+set(USE_SHMEM_MMAP_TMP FALSE) #TODO: determine
+set(USE_SHMEM_MMAP_ZERO FALSE) #TODO: determine
+set(USE_SHMEM_OS2 FALSE) #TODO: determine
+set(USE_SHMEM_OS2_ANON FALSE) #TODO: determine
+set(USE_SHMEM_SHMGET TRUE) #TODO: determine
+set(USE_SHMEM_SHMGET_ANON FALSE) #TODO: determine
+set(USE_SHMEM_WIN32 FALSE) #TODO: determine
+set(USE_SHMEM_WIN32_ANON FALSE) #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(USE_SYSVSEM_SERIALIZE FALSE) #TODO: determine
+else()
+  set(USE_SYSVSEM_SERIALIZE TRUE) #TODO: determine
+endif()
+list(APPEND cmakedefine01
+  USE_ATOMICS_GENERIC
+  USE_BEOSSEM
+  USE_FCNTL_SERIALIZE
+  USE_FLOCK_SERIALIZE
+  USE_SHMEM_BEOS
+  USE_SHMEM_BEOS_ANON
+  USE_SHMEM_MMAP_ANON
+  USE_SHMEM_MMAP_SHM
+  USE_SHMEM_MMAP_TMP
+  USE_SHMEM_MMAP_ZERO
+  USE_SHMEM_OS2
+  USE_SHMEM_OS2_ANON
+  USE_SHMEM_SHMGET
+  USE_SHMEM_SHMGET_ANON
+  USE_SHMEM_WIN32
+  USE_SHMEM_WIN32_ANON
+  USE_SYSVSEM_SERIALIZE
+  )
+########################################
+set(WAITIO_USES_POLL TRUE) #TODO: determine
+set(_MINIX FALSE) #TODO: determine
+set(_POSIX_1_SOURCE FALSE) #TODO: determine
+set(_POSIX_SOURCE FALSE) #TODO: determine
+list(APPEND cmakedefine01
+  WAITIO_USES_POLL
+  _MINIX
+  _POSIX_1_SOURCE
+  _POSIX_SOURCE
+  )
+########################################
+foreach(var ${cmakedefine01})
+  set_define(${var} 1)
+endforeach()
+foreach(var ${cmakedefine})
+  set_define(${var})
+endforeach()
+########################################
+configure_file(${CMAKE_SOURCE_DIR}/include/arch/unix/apr_private.cmake.in .)
+configure_file(${CMAKE_BINARY_DIR}/apr_private.cmake.in ${PROJECT_BINARY_DIR}/apr_private.h)
+################################################################################
+set01(arpa_ineth HAVE_ARPA_INET_H) # APR_HAVE_ARPA_INET_H
+set01(conioh HAVE_CONIO_H) # APR_HAVE_CONIO_H
+set01(crypth HAVE_CRYPT_H) # APR_HAVE_CRYPT_H
+set01(ctypeh HAVE_CTYPE_H) # APR_HAVE_CTYPE_H
+set01(direnth HAVE_DIRENT_H) # APR_HAVE_DIRENT_H
+set01(errnoh HAVE_ERRNO_H) # APR_HAVE_ERRNO_H
+set01(fcntlh HAVE_FCNTL_H) # APR_HAVE_FCNTL_H
+set01(ioh HAVE_IO_H) # APR_HAVE_IO_H
+set01(limitsh HAVE_LIMITS_H) # APR_HAVE_LIMITS_H
+set01(netdbh HAVE_NETDB_H) # APR_HAVE_NETDB_H
+set01(netinet_inh HAVE_NETINET_IN_H) # APR_HAVE_NETINET_IN_H
+set01(netinet_sctph HAVE_NETINET_SCTP_H) # APR_HAVE_NETINET_SCTP_H
+set01(netinet_sctp_uioh HAVE_NETINET_SCTP_UIO_H) # APR_HAVE_NETINET_SCTP_UIO_H
+set01(netinet_tcph HAVE_NETINET_TCP_H) # APR_HAVE_NETINET_TCP_H
+set01(processh HAVE_PROCESS_H) # APR_HAVE_PROCESS_H
+set01(pthreadh HAVE_PTHREAD_H) # APR_HAVE_PTHREAD_H
+set01(semaphoreh HAVE_SEMAPHORE_H) # APR_HAVE_SEMAPHORE_H
+set01(signalh HAVE_SIGNAL_H) # APR_HAVE_SIGNAL_H
+set01(stdargh HAVE_STDARG_H) # APR_HAVE_STDARG_H
+set01(stdint HAVE_STDINT_H) # APR_HAVE_STDINT_H
+set01(stdioh HAVE_STDIO_H) # APR_HAVE_STDIO_H
+set01(stdlibh HAVE_STDLIB_H) # APR_HAVE_STDLIB_H
+set01(stringh HAVE_STRING_H) # APR_HAVE_STRING_H
+set01(stringsh HAVE_STRINGS_H) # APR_HAVE_STRINGS_H
+set01(sys_ioctlh HAVE_SYS_IOCTL_H) # APR_HAVE_SYS_IOCTL_H
+set01(sys_sendfileh HAVE_SYS_SENDFILE_H) # APR_HAVE_SYS_SENDFILE_H
+set01(sys_signalh HAVE_SYS_SIGNAL_H) # APR_HAVE_SYS_SIGNAL_H
+set01(sys_socketh HAVE_SYS_SOCKET_H) # APR_HAVE_SYS_SOCKET_H
+set01(sys_sockioh HAVE_SYS_SOCKIO_H) # APR_HAVE_SYS_SOCKIO_H
+set01(sys_syslimitsh HAVE_SYS_SYSLIMITS_H) # APR_HAVE_SYS_SYSLIMITS_H
+set01(sys_timeh HAVE_SYS_TIME_H) # APR_HAVE_SYS_TIME_H
+set01(sys_typesh HAVE_SYS_TYPES_H) # APR_HAVE_SYS_TYPES_H
+set01(sys_uioh HAVE_SYS_UIO_H) # APR_HAVE_SYS_UIO_H
+set01(sys_unh HAVE_SYS_UN_H) # APR_HAVE_SYS_UN_H
+set01(sys_waith HAVE_SYS_WAIT_H) # APR_HAVE_SYS_WAIT_H
+set01(timeh HAVE_TIME_H) # APR_HAVE_TIME_H
+set01(unistdh HAVE_UNISTD_H) # APR_HAVE_UNISTD_H
+set01(windowsh HAVE_WINDOWS_H) # APR_HAVE_WINDOWS_H
+set01(winsock2h HAVE_WINSOCK2_H) # APR_HAVE_WINSOCK2_H
+#####
+set(HAVE_MMAP_TMP HAVE_SYS_MMAN_H AND HAVE_MMAP AND HAVE_MUNMAP)
+set(HAVE_MMAP_SHM HAVE_MMAP_TMP AND HAVE_SHM_OPEN AND HAVE_SHM_UNLINK)
+set(HAVE_MMAP_ZERO HAVE_MMAP_TMP AND EXISTS /dev/zero)
+set(HAVE_SHM_HEADERS HAVE_SYS_IPC_H AND HAVE_SYS_SHM_H AND HAVE_SYS_FILE_H)
+set(HAVE_SHM_FUNCS HAVE_SHMGET AND HAVE_SHMAT AND HAVE_SHMDT AND HAVE_SHMCTL)
+set(HAVE_SHM_GETANON HAVE_SHM_HEADERS AND HAVE_SHM_FUNCS)
+set(HAVE_SHM_GET HAVE_SHM_HEADERS AND HAVE_SHM_FUNCS)
+set(HAVE_MMAP_ANON HAVE_MMAP_TMP AND HAVE_MAP_ANON)
+set(HAVE_BEOS_AREA FALSE) # no tests in configure
+set01(havemmaptmp HAVE_MMAP_TMP) # APR_HAVE_SHMEM_MMAP_TMP
+set01(havemmapshm HAVE_MMAP_SHM) # APR_HAVE_SHMEM_MMAP_SHM
+set01(havemmapzero HAVE_MMAP_ZERO) # APR_HAVE_SHMEM_MMAP_ZERO
+set01(haveshmgetanon HAVE_SHM_GETANON) # APR_HAVE_SHMEM_SHMGET_ANON
+set01(haveshmget HAVE_SHM_GET) # APR_HAVE_SHMEM_SHMGET
+set01(havemmapanon HAVE_MMAP_ANON) # APR_HAVE_SHMEM_MMAP_ANON
+set01(havebeosarea HAVE_BEOS_AREA) # APR_HAVE_SHMEM_BEOS
+#####
+set01(usemmaptmp USE_SHMEM_MMAP_TMP) # APR_USE_SHMEM_MMAP_TMP
+set01(usemmapshm USE_SHMEM_MMAP_SHM) # APR_USE_SHMEM_MMAP_SHM
+set01(usemmapzero USE_SHMEM_MMAP_ZERO) # APR_USE_SHMEM_MMAP_ZERO
+set01(useshmgetanon USE_SHMEM_SHMGET_ANON) # APR_USE_SHMEM_SHMGET_ANON
+set01(useshmget USE_SHMEM_SHMGET) # APR_USE_SHMEM_SHMGET
+set01(usemmapanon USE_SHMEM_MMAP_ANON) # APR_USE_SHMEM_MMAP_ANON
+set01(usebeosarea USE_SHMEM_BEOS) # APR_USE_SHMEM_BEOS
+#####
+set01(flockser USE_FLOCK_SERIALIZE) # APR_USE_FLOCK_SERIALIZE
+set01(sysvser USE_SYSVSEM_SERIALIZE) # APR_USE_SYSVSEM_SERIALIZE
+set01(posixser USE_POSIXSEM_SERIALIZE) # APR_USE_POSIXSEM_SERIALIZE
+set01(fcntlser USE_FCNTL_SERIALIZE) # APR_USE_FCNTL_SERIALIZE
+set01(procpthreadser USE_PROC_PTHREAD_SERIALIZE) # APR_USE_PROC_PTHREAD_SERIALIZE
+set01(pthreadser HAVE_PTHREAD_H) # APR_USE_PTHREAD_SERIALIZE #TODO: maybe more to do to determine?
+#####
+set(HAS_FLOCK_SER HAVE_FLOCK AND HAVE_LOCK_EX)
+set(HAS_SYSV_SER HAVE_SEMGET AND HAVE_SEMCTL AND HAVE_SEM_UNDO)
+set(HAS_POSIX_SER HAVE_SEMAPHORE_H AND HAVE_SEM_CLOSE AND HAVE_SEM_UNLINK AND HAVE_SEM_POST AND HAVE_SEM_WAIT)
+set(HAS_FCNTL_SER HAVE_FCNTL_H AND HAVE_F_SETLK)
+set(HAS_PROC_PTHREAD_SER HAVE_PTHREAD_H AND HAVE_PTHREAD_PROCESS_SHARED AND HAVE_PTHREAD_MUTEXATTR_SETPSHARED AND EXISTS /dev/zero)
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set01(hasflockser FALSE) # APR_HAS_FLOCK_SERIALIZE
+else()
+  set01(hasflockser HAS_FLOCK_SER) # APR_HAS_FLOCK_SERIALIZE
+endif()
+set01(hassysvser HAS_SYSV_SER) # APR_HAS_SYSVSEM_SERIALIZE
+set01(hasposixser HAS_POSIX_SER) # APR_HAS_POSIXSEM_SERIALIZE
+set01(hasfcntlser HAS_FCNTL_SER) # APR_HAS_FCNTL_SERIALIZE
+set01(hasprocpthreadser HAS_PROC_PTHREAD_SER) # APR_HAS_PROC_PTHREAD_SERIALIZE
+#####
+set01(proclockglobal FALSE) # APR_PROCESS_LOCK_IS_GLOBAL #TODO: determine
+#####
+set01(have_corkable_tcp HAVE_TCP_CORK) # APR_HAVE_CORKABLE_TCP
+set01(have_getrlimit HAVE_GETRLIMIT) # APR_HAVE_GETRLIMIT
+set01(have_in_addr HAVE_IN_ADDR) # APR_HAVE_IN_ADDR
+set01(have_inet_addr HAVE_INET_ADDR) # APR_HAVE_INET_ADDR
+set01(have_inet_network HAVE_INET_NETWORK) # APR_HAVE_INET_NETWORK
+set(HAVE_IPV6 HAVE_SOCKADDR_IN6 AND HAVE_GETADDRINFO AND HAVE_GETNAMEINFO AND HAVE_GAI_ADDRCONFIG)
+set01(have_ipv6 HAVE_IPV6) # APR_HAVE_IPV6
+set01(have_memmove HAVE_MEMMOVE) # APR_HAVE_MEMMOVE
+set01(have_setrlimit HAVE_SETRLIMIT) # APR_HAVE_SETRLIMIT
+set01(have_sigaction HAVE_SIGACTION) # APR_HAVE_SIGACTION
+set01(have_sigsuspend HAVE_SIGSUSPEND) # APR_HAVE_SIGSUSPEND
+set01(have_sigwait HAVE_SIGWAIT) # APR_HAVE_SIGWAIT
+set01(have_sa_storage HAVE_SA_STORAGE) # APR_HAVE_SA_STORAGE
+set01(have_strcasecmp HAVE_STRCASECMP) # APR_HAVE_STRCASECMP
+set01(have_strdup HAVE_STRDUP) # APR_HAVE_STRDUP
+set01(have_stricmp HAVE_STRICMP) # APR_HAVE_STRICMP
+set01(have_strncasecmp HAVE_STRNCASECMP) # APR_HAVE_STRNCASECMP
+set01(have_strnicmp HAVE_STRNICMP) # APR_HAVE_STRNICMP
+set01(have_strstr HAVE_STRSTR) # APR_HAVE_STRSTR
+set01(have_memchr HAVE_MEMCHR) # APR_HAVE_MEMCHR
+set01(struct_rlimit HAVE_STRUCT_RLIMIT) # APR_HAVE_STRUCT_RLIMIT
+set01(have_union_semun HAVE_UNION_SEMUN) # APR_HAVE_UNION_SEMUN
+set01(have_sctp HAVE_SCTP) # APR_HAVE_SCTP
+set01(have_iovec HAVE_SIZEOF_STRUCT_IOVEC) # APR_HAVE_IOVEC
+#####
+set(HAVE_SHAREDMEM USE_SHMEM_MMAP_TMP OR USE_SHMEM_MMAP_SHM OR USE_SHMEM_MMAP_ZERO OR USE_SHMEM_SHMGET OR
+  USE_SHMEM_MMAP_ANON OR USE_SHMEM_BEOS OR USE_SHMEM_OS2 OR USE_SHMEM_WIN32)
+set01(sharedmem HAVE_SHAREDMEM) # APR_HAS_SHARED_MEMORY
+set01(threads TRUE) # APR_HAS_THREADS #TODO: determine
+set01(sendfile TRUE) # APR_HAS_SENDFILE #TODO: determine
+set01(mmap TRUE) # APR_HAS_MMAP #TODO: determine
+set01(fork HAVE_FORK) # APR_HAS_FORK
+set01(rand TRUE) # APR_HAS_RANDOM #TODO: determine
+set01(oc TRUE) # APR_HAS_OTHER_CHILD #TODO: determine
+set01(aprdso DSO_USE_DLFCN OR DSO_USE_SHL OR DSO_USE_DYLD) # APR_HAS_DSO
+set01(acceptfilter HAVE_SO_ACCEPTFILTER) # APR_HAS_SO_ACCEPTFILTER
+set01(have_unicode_fs FALSE) # APR_HAS_UNICODE_FS #TODO: determine
+set01(have_proc_invoked FALSE) # APR_HAS_PROC_INVOKED #TODO: determine
+set01(apr_has_user TRUE) # APR_HAS_USER #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set01(aprlfs TRUE) # APR_HAS_LARGE_FILES #TODO: determine
+else()
+  set01(aprlfs FALSE) # APR_HAS_LARGE_FILES #TODO: determine
+endif()
+if(aprlfs)
+  add_definitions(-D_LARGEFILE64_SOURCE)
+endif()
+set01(apr_has_xthread_files FALSE) # APR_HAS_XTHREAD_FILES #TODO: determine
+set01(osuuid FALSE) # APR_HAS_OS_UUID #TODO: determine
+#####
+set01(apr_procattr_user_set_requires_password FALSE) # APR_PROCATTR_USER_SET_REQUIRES_PASSWORD #TODO: determine
+set01(file_as_socket TRUE) # APR_FILES_AS_SOCKETS #TODO: determine
+set01(apr_charset_ebcdic FALSE) # APR_CHARSET_EBCDIC #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set(apr_tcp_nopush_flag 0) # APR_TCP_NOPUSH_FLAG #TODO: determine
+else()
+  set(apr_tcp_nopush_flag TCP_CORK) # APR_TCP_NOPUSH_FLAG #TODO: determine
+endif()
+set01(tcp_nodelay_inherited TRUE) # APR_TCP_NODELAY_INHERITED #TODO: determine
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  set01(o_nonblock_inherited TRUE) # APR_O_NONBLOCK_INHERITED #TODO: determine
+else()
+  set01(o_nonblock_inherited FALSE) # APR_O_NONBLOCK_INHERITED #TODO: determine
+endif()
+#####
+if(SIZEOF_SHORT EQUAL 2)
+  set(short_value short)
+else()
+  set(short_value unknown)
+endif()
+if(SIZEOF_INT EQUAL 4)
+  set(int_value int)
+else()
+  set(int_value unknown)
+endif()
+set(voidp_size ${SIZEOF_VOIDP}) # APR_SIZEOF_VOIDP
+if(SIZEOF_INT EQUAL 8)
+  set(int64_literal "#define APR_INT64_C(val) (val)")
+  set(uint64_literal "#define APR_UINT64_C(val) (val##U)")
+  set(int64_t_fmt "#define APR_INT64_T_FMT \"d\"")
+  set(uint64_t_fmt "#define APR_UINT64_T_FMT \"u\"")
+  set(uint64_t_hex_fmt "#define APR_UINT64_T_HEX_FMT \"x\"")
+  set(long_value int)
+elseif(SIZEOF_LONG EQUAL 8)
+  set(int64_literal "#define APR_INT64_C(val) (val##L)")
+  set(uint64_literal "#define APR_UINT64_C(val) (val##UL)")
+  set(int64_t_fmt "#define APR_INT64_T_FMT \"ld\"")
+  set(uint64_t_fmt "#define APR_UINT64_T_FMT \"lu\"")
+  set(uint64_t_hex_fmt "#define APR_UINT64_T_HEX_FMT \"lx\"")
+  set(long_value long)
+elseif(SIZEOF_LONG_LONG EQUAL 8)
+  set(int64_literal "#define APR_INT64_C(val) (val##LL)")
+  set(uint64_literal "#define APR_UINT64_C(val) (val##ULL)")
+  # Linux, Solaris, FreeBSD all support ll with printf.
+  # BSD 4.4 originated 'q'. Solaris is more popular and
+  # doesn't support 'q'. Solaris wins. Exceptions can
+  # go to the OS-dependent section.
+  set(int64_t_fmt "#define APR_INT64_T_FMT \"lld\"")
+  set(uint64_t_fmt "#define APR_UINT64_T_FMT \"llu\"")
+  set(uint64_t_hex_fmt "#define APR_UINT64_T_HEX_FMT \"llx\"")
+  set(long_value "long long")
+elseif(SIZEOF_LONG_LONG EQUAL 8)
+  set(int64_literal "#define APR_INT64_C(val) (val##LL)")
+  set(uint64_literal "#define APR_UINT64_C(val) (val##ULL)")
+  set(int64_t_fmt "#define APR_INT64_T_FMT \"qd\"")
+  set(uint64_t_fmt "#define APR_UINT64_T_FMT \"qu\"")
+  set(uint64_t_hex_fmt "#define APR_UINT64_T_HEX_FMT \"qx\"")
+  set(long_value "__int64")
+else()
+  message(FATAL_ERROR "could not detect a 64-bit integer type")
+endif()
+if(HAVE_INT64_C_DEFINED)
+  set(int64_literal "#define APR_INT64_C(val) INT64_C(val)")
+  set(uint64_literal "#define APR_UINT64_C(val) UINT64_C(val)")
+endif()
+#####
+set01(bigendian WORDS_BIGENDIAN) # APR_IS_BIGENDIAN
+#####
+set(apr_thread_func) # APR_THREAD_FUNC # TODO: handle case where it should be set to __stdcall
+###
+if(${CMAKE_SYSTEM_NAME} STREQUAL SOME_PLATFORM) # TODO: handle other cases
+  # where SOME_PLATFORM matches results from CMakeDetermineSystem.cmake:
+  # AIX BSD/OS FreeBSD HP-UX IRIX Linux GNU/kFreeBSD NetBSD OpenBSD OSF1
+  # SCO_SV UnixWare UNIX_SV Xenix SunOS Tru64 ULTRIX CYGWIN_NT-5.1 Darwin
+else()
+  set(ssize_t_fmt "#define APR_SSIZE_T_FMT \"ld\"")
+  set(size_t_fmt "#define APR_SIZE_T_FMT \"lu\"")
+endif()
+if(HAVE_SIZEOF_OFF_T)
+  if(SIZEOF_OFF_T EQUAL SIZEOF_LONG)
+    set(off_t_fmt "#define APR_OFF_T_FMT \"ld\"")
+  elseif(SIZEOF_OFF_T EQUAL SIZEOF_INT)
+    set(off_t_fmt "#define APR_OFF_T_FMT \"d\"")
+  elseif(SIZEOF_OFF_T EQUAL SIZEOF_LONG_LONG)
+    set(off_t_fmt "#define APR_OFF_T_FMT APR_INT64_T_FMT")
+  else()
+    message(FATAL_ERROR "could not determine the size of off_t")
+  endif()
+else()
+  message(FATAL_ERROR "could not determine APR_OFF_T_FMT")
+endif()
+if(HAVE_SIZEOF_PID_T)
+  if(SIZEOF_PID_T EQUAL SIZEOF_SHORT)
+    set(pid_t_fmt "#define APR_PID_T_FMT \"hd\"")
+  elseif(SIZEOF_PID_T EQUAL SIZEOF_INT)
+    set(pid_t_fmt "#define APR_PID_T_FMT \"d\"")
+  elseif(SIZEOF_PID_T EQUAL SIZEOF_LONG)
+    set(pid_t_fmt "#define APR_PID_T_FMT \"ld\"")
+  elseif(SIZEOF_PID_T EQUAL SIZEOF_LONG_LONG)
+    set(pid_t_fmt "#define APR_PID_T_FMT APR_INT64_T_FMT")
+  else()
+    message(FATAL_ERROR "could not determine the proper size for pid_t")
+  endif()
+else()
+  message(FATAL_ERROR "could not determine APR_PID_T_FMT")
+endif()
+#####
+set01(proc_mutex_is_global FALSE) # APR_PROC_MUTEX_IS_GLOBAL #TODO: determine
+if(MINGW OR OS2) #TODO: verify OS2 is a cmake variable
+  set(eolstr \\r\\n)
+  #set(shlibpath_var) #TODO: handle cases where it isn't LD_LIBRARY_PATH
+else()
+  set(eolstr \\n) # APR_EOL_STR
+  set(shlibpath_var LD_LIBRARY_PATH) # APR_DSOPATH
+endif()
+configure_file(${CMAKE_SOURCE_DIR}/include/apr.h.in apr.h)
+##########
+set(CMAKE_REQUIRED_LIBRARIES)
+set(CMAKE_REQUIRED_DEFINITIONS)
+add_definitions(-DHAVE_CONFIG_H)
+if(UNIX)
+  add_definitions(-DCMAKE_UNIX)
+endif()
+if(${CMAKE_SYSTEM_NAME} STREQUAL SunOS)
+  string(REGEX REPLACE "([0-9]+)\\.([0-9]+)" "\\2" SOL_VER ${CMAKE_SYSTEM_VERSION})
+  add_definitions(-DSOLARIS2=${SOL_VER})
+endif()
diff --git a/include/apr_general.h b/include/apr_general.h
index c7389ec..0b32945 100644
--- a/include/apr_general.h
+++ b/include/apr_general.h
@@ -76,7 +76,7 @@ typedef int               apr_signum_t;
  * @return offset
  */
 
-#if defined(CRAY) || (defined(__arm) && !(defined(LINUX) || defined(__FreeBSD__)))
+#if defined(CRAY) || (defined(__arm) && !(defined(__linux) || defined(__FreeBSD__)))
 #ifdef __STDC__
 #define APR_OFFSET(p_type,field) _Offsetof(p_type,field)
 #else
diff --git a/include/arch/unix/apr_private.cmake.in b/include/arch/unix/apr_private.cmake.in
new file mode 100644
index 0000000..abd7f30
--- /dev/null
+++ b/include/arch/unix/apr_private.cmake.in
@@ -0,0 +1,999 @@
+/* include/arch/unix/apr_private.in.  Copied, modified from source tar.gz.  */
+
+#ifndef APR_PRIVATE_H
+#define APR_PRIVATE_H
+
+
+/* Define if building universal (internal helper macro) */
+#@DEFINE_AC_APPLE_UNIVERSAL_BUILD@ AC_APPLE_UNIVERSAL_BUILD
+
+/* Define if apr_allocator should use mmap */
+#@DEFINE_APR_ALLOCATOR_USES_MMAP@ APR_ALLOCATOR_USES_MMAP
+
+/* Define as function which can be used for conversion of strings to
+   apr_int64_t */
+#@DEFINE_APR_INT64_STRFN@ APR_INT64_STRFN @APR_INT64_STRFN@
+
+/* Define as function used for conversion of strings to apr_off_t */
+#@DEFINE_APR_OFF_T_STRFN@ APR_OFF_T_STRFN @APR_OFF_T_STRFN@
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#@DEFINE_CRAY_STACKSEG_END@ CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#@DEFINE_C_ALLOCA@ C_ALLOCA
+
+/* Define to path of random device */
+#@DEFINE_DEV_RANDOM@ DEV_RANDOM "@DEV_RANDOM@"
+
+/* Define if struct dirent has an inode member */
+#@DEFINE_DIRENT_INODE@ DIRENT_INODE @DIRENT_INODE@
+
+/* Define if struct dirent has a d_type member */
+#@DEFINE_DIRENT_TYPE@ DIRENT_TYPE @DIRENT_TYPE@
+
+/* Define if DSO support uses dlfcn.h */
+#@DEFINE_DSO_USE_DLFCN@ DSO_USE_DLFCN
+
+/* Define if DSO support uses dyld.h */
+#@DEFINE_DSO_USE_DYLD@ DSO_USE_DYLD
+
+/* Define if DSO support uses shl_load */
+#@DEFINE_DSO_USE_SHL@ DSO_USE_SHL
+
+/* Define to list of paths to EGD sockets */
+#@DEFINE_EGD_DEFAULT_SOCKET@ EGD_DEFAULT_SOCKET
+
+/* Define if fcntl locks affect threads within the process */
+#@DEFINE_FCNTL_IS_GLOBAL@ FCNTL_IS_GLOBAL
+
+/* Define if fcntl returns EACCES when F_SETLK is already held */
+#@DEFINE_FCNTL_TRYACQUIRE_EACCES@ FCNTL_TRYACQUIRE_EACCES
+
+/* Define if flock locks affect threads within the process */
+#@DEFINE_FLOCK_IS_GLOBAL@ FLOCK_IS_GLOBAL
+
+/* Define if gethostbyaddr is thread safe */
+#@DEFINE_GETHOSTBYADDR_IS_THREAD_SAFE@ GETHOSTBYADDR_IS_THREAD_SAFE
+
+/* Define if gethostbyname is thread safe */
+#@DEFINE_GETHOSTBYNAME_IS_THREAD_SAFE@ GETHOSTBYNAME_IS_THREAD_SAFE
+
+/* Define if gethostbyname_r has the glibc style */
+#@DEFINE_GETHOSTBYNAME_R_GLIBC2@ GETHOSTBYNAME_R_GLIBC2
+
+/* Define if gethostbyname_r has the hostent_data for the third argument */
+#@DEFINE_GETHOSTBYNAME_R_HOSTENT_DATA@ GETHOSTBYNAME_R_HOSTENT_DATA
+
+/* Define if getservbyname is thread safe */
+#@DEFINE_GETSERVBYNAME_IS_THREAD_SAFE@ GETSERVBYNAME_IS_THREAD_SAFE
+
+/* Define if getservbyname_r has the glibc style */
+#@DEFINE_GETSERVBYNAME_R_GLIBC2@ GETSERVBYNAME_R_GLIBC2
+
+/* Define if getservbyname_r has the OSF/1 style */
+#@DEFINE_GETSERVBYNAME_R_OSF1@ GETSERVBYNAME_R_OSF1
+
+/* Define if getservbyname_r has the Solaris style */
+#@DEFINE_GETSERVBYNAME_R_SOLARIS@ GETSERVBYNAME_R_SOLARIS
+
+/* Define if accept4 function is supported */
+#@DEFINE_HAVE_ACCEPT4@ HAVE_ACCEPT4
+
+/* Define if async i/o supports message q's */
+#@DEFINE_HAVE_AIO_MSGQ@ HAVE_AIO_MSGQ
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#@DEFINE_HAVE_ALLOCA@ HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#@DEFINE_HAVE_ALLOCA_H@ HAVE_ALLOCA_H
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#@DEFINE_HAVE_ARPA_INET_H@ HAVE_ARPA_INET_H
+
+/* Define if compiler provides atomic builtins */
+#@DEFINE_HAVE_ATOMIC_BUILTINS@ HAVE_ATOMIC_BUILTINS
+
+/* Define if BONE_VERSION is defined in sys/socket.h */
+#@DEFINE_HAVE_BONE_VERSION@ HAVE_BONE_VERSION
+
+/* Define to 1 if you have the <ByteOrder.h> header file. */
+#@DEFINE_HAVE_BYTEORDER_H@ HAVE_BYTEORDER_H
+
+/* Define to 1 if you have the `calloc' function. */
+#@DEFINE_HAVE_CALLOC@ HAVE_CALLOC
+
+/* Define to 1 if you have the <conio.h> header file. */
+#@DEFINE_HAVE_CONIO_H@ HAVE_CONIO_H
+
+/* Define to 1 if you have the `create_area' function. */
+#@DEFINE_HAVE_CREATE_AREA@ HAVE_CREATE_AREA
+
+/* Define to 1 if you have the `create_sem' function. */
+#@DEFINE_HAVE_CREATE_SEM@ HAVE_CREATE_SEM
+
+/* Define to 1 if you have the <crypt.h> header file. */
+#@DEFINE_HAVE_CRYPT_H@ HAVE_CRYPT_H
+
+/* Define to 1 if you have the <ctype.h> header file. */
+#@DEFINE_HAVE_CTYPE_H@ HAVE_CTYPE_H
+
+/* Define to 1 if you have the declaration of `sys_siglist', and to 0 if you
+   don't. */
+#define HAVE_DECL_SYS_SIGLIST @HAVE_DECL_SYS_SIGLIST@
+
+/* Define to 1 if you have the <dirent.h> header file. */
+#@DEFINE_HAVE_DIRENT_H@ HAVE_DIRENT_H
+
+/* Define to 1 if you have the <dir.h> header file. */
+#@DEFINE_HAVE_DIR_H@ HAVE_DIR_H
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+#@DEFINE_HAVE_DLFCN_H@ HAVE_DLFCN_H
+
+/* Define to 1 if you have the <dl.h> header file. */
+#@DEFINE_HAVE_DL_H@ HAVE_DL_H
+
+/* Define if dup3 function is supported */
+#@DEFINE_HAVE_DUP3@ HAVE_DUP3
+
+/* Define if EGD is supported */
+#@DEFINE_HAVE_EGD@ HAVE_EGD
+
+/* Define if the epoll interface is supported */
+#@DEFINE_HAVE_EPOLL@ HAVE_EPOLL
+
+/* Define if epoll_create1 function is supported */
+#@DEFINE_HAVE_EPOLL_CREATE1@ HAVE_EPOLL_CREATE1
+
+/* Define to 1 if you have the <errno.h> header file. */
+#@DEFINE_HAVE_ERRNO_H@ HAVE_ERRNO_H
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#@DEFINE_HAVE_FCNTL_H@ HAVE_FCNTL_H
+
+/* Define to 1 if you have the `fdatasync' function. */
+#@DEFINE_HAVE_FDATASYNC@ HAVE_FDATASYNC
+
+/* Define to 1 if you have the `flock' function. */
+#@DEFINE_HAVE_FLOCK@ HAVE_FLOCK
+
+/* Define to 1 if you have the `fork' function. */
+#@DEFINE_HAVE_FORK@ HAVE_FORK
+
+/* Define if F_SETLK is defined in fcntl.h */
+#@DEFINE_HAVE_F_SETLK@ HAVE_F_SETLK
+
+/* Define if getaddrinfo accepts the AI_ADDRCONFIG flag */
+#@DEFINE_HAVE_GAI_ADDRCONFIG@ HAVE_GAI_ADDRCONFIG
+
+/* Define to 1 if you have the `gai_strerror' function. */
+#@DEFINE_HAVE_GAI_STRERROR@ HAVE_GAI_STRERROR
+
+/* Define if getaddrinfo exists and works well enough for APR */
+#@DEFINE_HAVE_GETADDRINFO@ HAVE_GETADDRINFO
+
+/* Define to 1 if you have the `getenv' function. */
+#@DEFINE_HAVE_GETENV@ HAVE_GETENV
+
+/* Define to 1 if you have the `getgrgid_r' function. */
+#@DEFINE_HAVE_GETGRGID_R@ HAVE_GETGRGID_R
+
+/* Define to 1 if you have the `getgrnam_r' function. */
+#@DEFINE_HAVE_GETGRNAM_R@ HAVE_GETGRNAM_R
+
+/* Define to 1 if you have the `gethostbyaddr_r' function. */
+#@DEFINE_HAVE_GETHOSTBYADDR_R@ HAVE_GETHOSTBYADDR_R
+
+/* Define to 1 if you have the `gethostbyname_r' function. */
+#@DEFINE_HAVE_GETHOSTBYNAME_R@ HAVE_GETHOSTBYNAME_R
+
+/* Define to 1 if you have the `getifaddrs' function. */
+#@DEFINE_HAVE_GETIFADDRS@ HAVE_GETIFADDRS
+
+/* Define if getnameinfo exists */
+#@DEFINE_HAVE_GETNAMEINFO@ HAVE_GETNAMEINFO
+
+/* Define to 1 if you have the `getpass' function. */
+#@DEFINE_HAVE_GETPASS@ HAVE_GETPASS
+
+/* Define to 1 if you have the `getpassphrase' function. */
+#@DEFINE_HAVE_GETPASSPHRASE@ HAVE_GETPASSPHRASE
+
+/* Define to 1 if you have the `getpwnam_r' function. */
+#@DEFINE_HAVE_GETPWNAM_R@ HAVE_GETPWNAM_R
+
+/* Define to 1 if you have the `getpwuid_r' function. */
+#@DEFINE_HAVE_GETPWUID_R@ HAVE_GETPWUID_R
+
+/* Define to 1 if you have the `getrlimit' function. */
+#@DEFINE_HAVE_GETRLIMIT@ HAVE_GETRLIMIT
+
+/* Define to 1 if you have the `getservbyname_r' function. */
+#@DEFINE_HAVE_GETSERVBYNAME_R@ HAVE_GETSERVBYNAME_R
+
+/* Define to 1 if you have the `gmtime_r' function. */
+#@DEFINE_HAVE_GMTIME_R@ HAVE_GMTIME_R
+
+/* Define to 1 if you have the <grp.h> header file. */
+#@DEFINE_HAVE_GRP_H@ HAVE_GRP_H
+
+/* Define if hstrerror is present */
+#@DEFINE_HAVE_HSTRERROR@ HAVE_HSTRERROR
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#@DEFINE_HAVE_INTTYPES_H@ HAVE_INTTYPES_H
+
+/* Define to 1 if you have the <io.h> header file. */
+#@DEFINE_HAVE_IO_H@ HAVE_IO_H
+
+/* Define to 1 if you have the `isinf' function. */
+#@DEFINE_HAVE_ISINF@ HAVE_ISINF
+
+/* Define to 1 if you have the `isnan' function. */
+#@DEFINE_HAVE_ISNAN@ HAVE_ISNAN
+
+/* Define to 1 if you have the <kernel/OS.h> header file. */
+#@DEFINE_HAVE_KERNEL_OS_H@ HAVE_KERNEL_OS_H
+
+/* Define to 1 if you have the `kqueue' function. */
+#@DEFINE_HAVE_KQUEUE@ HAVE_KQUEUE
+
+/* Define to 1 if you have the <langinfo.h> header file. */
+#@DEFINE_HAVE_LANGINFO_H@ HAVE_LANGINFO_H
+
+/* Define to 1 if you have the `bsd' library (-lbsd). */
+#@DEFINE_HAVE_LIBBSD@ HAVE_LIBBSD
+
+/* Define to 1 if you have the `sendfile' library (-lsendfile). */
+#@DEFINE_HAVE_LIBSENDFILE@ HAVE_LIBSENDFILE
+
+/* Define to 1 if you have the `truerand' library (-ltruerand). */
+#@DEFINE_HAVE_LIBTRUERAND@ HAVE_LIBTRUERAND
+
+/* Define to 1 if you have the <limits.h> header file. */
+#@DEFINE_HAVE_LIMITS_H@ HAVE_LIMITS_H
+
+/* Define to 1 if you have the `localtime_r' function. */
+#@DEFINE_HAVE_LOCALTIME_R@ HAVE_LOCALTIME_R
+
+/* Define if LOCK_EX is defined in sys/file.h */
+#@DEFINE_HAVE_LOCK_EX@ HAVE_LOCK_EX
+
+/* Define to 1 if you have the <mach-o/dyld.h> header file. */
+#@DEFINE_HAVE_MACH_O_DYLD_H@ HAVE_MACH_O_DYLD_H
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#@DEFINE_HAVE_MALLOC_H@ HAVE_MALLOC_H
+
+/* Define if MAP_ANON is defined in sys/mman.h */
+#@DEFINE_HAVE_MAP_ANON@ HAVE_MAP_ANON
+
+/* Define to 1 if you have the `memchr' function. */
+#@DEFINE_HAVE_MEMCHR@ HAVE_MEMCHR
+
+/* Define to 1 if you have the `memmove' function. */
+#@DEFINE_HAVE_MEMMOVE@ HAVE_MEMMOVE
+
+/* Define to 1 if you have the <memory.h> header file. */
+#@DEFINE_HAVE_MEMORY_H@ HAVE_MEMORY_H
+
+/* Define to 1 if you have the `mkstemp' function. */
+#@DEFINE_HAVE_MKSTEMP@ HAVE_MKSTEMP
+
+/* Define to 1 if you have the `mkstemp64' function. */
+#@DEFINE_HAVE_MKSTEMP64@ HAVE_MKSTEMP64
+
+/* Define to 1 if you have the `mmap' function. */
+#@DEFINE_HAVE_MMAP@ HAVE_MMAP
+
+/* Define to 1 if you have the `mmap64' function. */
+#@DEFINE_HAVE_MMAP64@ HAVE_MMAP64
+
+/* Define to 1 if you have the `munmap' function. */
+#@DEFINE_HAVE_MUNMAP@ HAVE_MUNMAP
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#@DEFINE_HAVE_NETDB_H@ HAVE_NETDB_H
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#@DEFINE_HAVE_NETINET_IN_H@ HAVE_NETINET_IN_H
+
+/* Define to 1 if you have the <netinet/sctp.h> header file. */
+#@DEFINE_HAVE_NETINET_SCTP_H@ HAVE_NETINET_SCTP_H
+
+/* Define to 1 if you have the <netinet/sctp_uio.h> header file. */
+#@DEFINE_HAVE_NETINET_SCTP_UIO_H@ HAVE_NETINET_SCTP_UIO_H
+
+/* Defined if netinet/tcp.h is present */
+#@DEFINE_HAVE_NETINET_TCP_H@ HAVE_NETINET_TCP_H
+
+/* Define to 1 if you have the <net/errno.h> header file. */
+#@DEFINE_HAVE_NET_ERRNO_H@ HAVE_NET_ERRNO_H
+
+/* Define to 1 if you have the `nl_langinfo' function. */
+#@DEFINE_HAVE_NL_LANGINFO@ HAVE_NL_LANGINFO
+
+/* Define to 1 if you have the <os2.h> header file. */
+#@DEFINE_HAVE_OS2_H@ HAVE_OS2_H
+
+/* Define to 1 if you have the <osreldate.h> header file. */
+#@DEFINE_HAVE_OSRELDATE_H@ HAVE_OSRELDATE_H
+
+/* Define to 1 if you have the <OS.h> header file. */
+#@DEFINE_HAVE_OS_H@ HAVE_OS_H
+
+/* Define to 1 if you have the `poll' function. */
+#@DEFINE_HAVE_POLL@ HAVE_POLL
+
+/* Define if POLLIN is defined */
+#@DEFINE_HAVE_POLLIN@ HAVE_POLLIN
+
+/* Define to 1 if you have the <poll.h> header file. */
+#@DEFINE_HAVE_POLL_H@ HAVE_POLL_H
+
+/* Define to 1 if you have the `port_create' function. */
+#@DEFINE_HAVE_PORT_CREATE@ HAVE_PORT_CREATE
+
+/* Define to 1 if you have the <process.h> header file. */
+#@DEFINE_HAVE_PROCESS_H@ HAVE_PROCESS_H
+
+/* Define to 1 if you have the `pthread_attr_setguardsize' function. */
+#@DEFINE_HAVE_PTHREAD_ATTR_SETGUARDSIZE@ HAVE_PTHREAD_ATTR_SETGUARDSIZE
+
+/* Define to 1 if you have the <pthread.h> header file. */
+#@DEFINE_HAVE_PTHREAD_H@ HAVE_PTHREAD_H
+
+/* Define to 1 if you have the `pthread_key_delete' function. */
+#@DEFINE_HAVE_PTHREAD_KEY_DELETE@ HAVE_PTHREAD_KEY_DELETE
+
+/* Define to 1 if you have the `pthread_mutexattr_setpshared' function. */
+#@DEFINE_HAVE_PTHREAD_MUTEXATTR_SETPSHARED@ HAVE_PTHREAD_MUTEXATTR_SETPSHARED
+
+/* Define if recursive pthread mutexes are available */
+#@DEFINE_HAVE_PTHREAD_MUTEX_RECURSIVE@ HAVE_PTHREAD_MUTEX_RECURSIVE
+
+/* Define if cross-process robust mutexes are available */
+#@DEFINE_HAVE_PTHREAD_MUTEX_ROBUST@ HAVE_PTHREAD_MUTEX_ROBUST
+
+/* Define if PTHREAD_PROCESS_SHARED is defined in pthread.h */
+#@DEFINE_HAVE_PTHREAD_PROCESS_SHARED@ HAVE_PTHREAD_PROCESS_SHARED
+
+/* Define if pthread rwlocks are available */
+#@DEFINE_HAVE_PTHREAD_RWLOCKS@ HAVE_PTHREAD_RWLOCKS
+
+/* Define to 1 if you have the `pthread_rwlock_init' function. */
+#@DEFINE_HAVE_PTHREAD_RWLOCK_INIT@ HAVE_PTHREAD_RWLOCK_INIT
+
+/* Define to 1 if you have the `pthread_yield' function. */
+#@DEFINE_HAVE_PTHREAD_YIELD@ HAVE_PTHREAD_YIELD
+
+/* Define to 1 if you have the `putenv' function. */
+#@DEFINE_HAVE_PUTENV@ HAVE_PUTENV
+
+/* Define to 1 if you have the <pwd.h> header file. */
+#@DEFINE_HAVE_PWD_H@ HAVE_PWD_H
+
+/* Define to 1 if you have the `readdir64_r' function. */
+#@DEFINE_HAVE_READDIR64_R@ HAVE_READDIR64_R
+
+/* Define to 1 if you have the <sched.h> header file. */
+#@DEFINE_HAVE_SCHED_H@ HAVE_SCHED_H
+
+/* Define to 1 if you have the `sched_yield' function. */
+#@DEFINE_HAVE_SCHED_YIELD@ HAVE_SCHED_YIELD
+
+/* Define to 1 if you have the <semaphore.h> header file. */
+#@DEFINE_HAVE_SEMAPHORE_H@ HAVE_SEMAPHORE_H
+
+/* Define to 1 if you have the `semctl' function. */
+#@DEFINE_HAVE_SEMCTL@ HAVE_SEMCTL
+
+/* Define to 1 if you have the `semget' function. */
+#@DEFINE_HAVE_SEMGET@ HAVE_SEMGET
+
+/* Define to 1 if you have the `sem_close' function. */
+#@DEFINE_HAVE_SEM_CLOSE@ HAVE_SEM_CLOSE
+
+/* Define to 1 if you have the `sem_post' function. */
+#@DEFINE_HAVE_SEM_POST@ HAVE_SEM_POST
+
+/* Define if SEM_UNDO is defined in sys/sem.h */
+#@DEFINE_HAVE_SEM_UNDO@ HAVE_SEM_UNDO
+
+/* Define to 1 if you have the `sem_unlink' function. */
+#@DEFINE_HAVE_SEM_UNLINK@ HAVE_SEM_UNLINK
+
+/* Define to 1 if you have the `sem_wait' function. */
+#@DEFINE_HAVE_SEM_WAIT@ HAVE_SEM_WAIT
+
+/* Define to 1 if you have the `sendfile' function. */
+#@DEFINE_HAVE_SENDFILE@ HAVE_SENDFILE
+
+/* Define to 1 if you have the `sendfile64' function. */
+#@DEFINE_HAVE_SENDFILE64@ HAVE_SENDFILE64
+
+/* Define to 1 if you have the `sendfilev' function. */
+#@DEFINE_HAVE_SENDFILEV@ HAVE_SENDFILEV
+
+/* Define to 1 if you have the `sendfilev64' function. */
+#@DEFINE_HAVE_SENDFILEV64@ HAVE_SENDFILEV64
+
+/* Define to 1 if you have the `send_file' function. */
+#@DEFINE_HAVE_SEND_FILE@ HAVE_SEND_FILE
+
+/* Define to 1 if you have the `setenv' function. */
+#@DEFINE_HAVE_SETENV@ HAVE_SETENV
+
+/* Define to 1 if you have the `setrlimit' function. */
+#@DEFINE_HAVE_SETRLIMIT@ HAVE_SETRLIMIT
+
+/* Define to 1 if you have the `setsid' function. */
+#@DEFINE_HAVE_SETSID@ HAVE_SETSID
+
+/* Define to 1 if you have the `set_h_errno' function. */
+#@DEFINE_HAVE_SET_H_ERRNO@ HAVE_SET_H_ERRNO
+
+/* Define to 1 if you have the `shmat' function. */
+#@DEFINE_HAVE_SHMAT@ HAVE_SHMAT
+
+/* Define to 1 if you have the `shmctl' function. */
+#@DEFINE_HAVE_SHMCTL@ HAVE_SHMCTL
+
+/* Define to 1 if you have the `shmdt' function. */
+#@DEFINE_HAVE_SHMDT@ HAVE_SHMDT
+
+/* Define to 1 if you have the `shmget' function. */
+#@DEFINE_HAVE_SHMGET@ HAVE_SHMGET
+
+/* Define to 1 if you have the `shm_open' function. */
+#@DEFINE_HAVE_SHM_OPEN@ HAVE_SHM_OPEN
+
+/* Define to 1 if you have the `shm_unlink' function. */
+#@DEFINE_HAVE_SHM_UNLINK@ HAVE_SHM_UNLINK
+
+/* Define to 1 if you have the `sigaction' function. */
+#@DEFINE_HAVE_SIGACTION@ HAVE_SIGACTION
+
+/* Define to 1 if you have the <signal.h> header file. */
+#@DEFINE_HAVE_SIGNAL_H@ HAVE_SIGNAL_H
+
+/* Define to 1 if you have the `sigsuspend' function. */
+#@DEFINE_HAVE_SIGSUSPEND@ HAVE_SIGSUSPEND
+
+/* Define to 1 if you have the `sigwait' function. */
+#@DEFINE_HAVE_SIGWAIT@ HAVE_SIGWAIT
+
+/* Whether you have socklen_t */
+#@DEFINE_HAVE_SOCKLEN_T@ HAVE_SOCKLEN_T
+
+/* Define if the SOCK_CLOEXEC flag is supported */
+#@DEFINE_HAVE_SOCK_CLOEXEC@ HAVE_SOCK_CLOEXEC
+
+/* Define if SO_ACCEPTFILTER is defined in sys/socket.h */
+#@DEFINE_HAVE_SO_ACCEPTFILTER@ HAVE_SO_ACCEPTFILTER
+
+/* Define to 1 if you have the <stdarg.h> header file. */
+#@DEFINE_HAVE_STDARG_H@ HAVE_STDARG_H
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#@DEFINE_HAVE_STDDEF_H@ HAVE_STDDEF_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#@DEFINE_HAVE_STDINT_H@ HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdio.h> header file. */
+#@DEFINE_HAVE_STDIO_H@ HAVE_STDIO_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#@DEFINE_HAVE_STDLIB_H@ HAVE_STDLIB_H
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#@DEFINE_HAVE_STRCASECMP@ HAVE_STRCASECMP
+
+/* Define to 1 if you have the `strdup' function. */
+#@DEFINE_HAVE_STRDUP@ HAVE_STRDUP
+
+/* Define to 1 if you have the `strerror_r' function. */
+#@DEFINE_HAVE_STRERROR_R@ HAVE_STRERROR_R
+
+/* Define to 1 if you have the `stricmp' function. */
+#@DEFINE_HAVE_STRICMP@ HAVE_STRICMP
+
+/* Define to 1 if you have the <strings.h> header file. */
+#@DEFINE_HAVE_STRINGS_H@ HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#@DEFINE_HAVE_STRING_H@ HAVE_STRING_H
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#@DEFINE_HAVE_STRNCASECMP@ HAVE_STRNCASECMP
+
+/* Define to 1 if you have the `strnicmp' function. */
+#@DEFINE_HAVE_STRNICMP@ HAVE_STRNICMP
+
+/* Define to 1 if you have the `strstr' function. */
+#@DEFINE_HAVE_STRSTR@ HAVE_STRSTR
+
+/* Define if struct impreq was found */
+#@DEFINE_HAVE_STRUCT_IPMREQ@ HAVE_STRUCT_IPMREQ
+
+/* Define to 1 if `st_atimensec' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_ATIMENSEC@ HAVE_STRUCT_STAT_ST_ATIMENSEC
+
+/* Define to 1 if `st_atime_n' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_ATIME_N@ HAVE_STRUCT_STAT_ST_ATIME_N
+
+/* Define to 1 if `st_atim.tv_nsec' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC@ HAVE_STRUCT_STAT_ST_ATIM_TV_NSEC
+
+/* Define to 1 if `st_blocks' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_BLOCKS@ HAVE_STRUCT_STAT_ST_BLOCKS
+
+/* Define to 1 if `st_ctimensec' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_CTIMENSEC@ HAVE_STRUCT_STAT_ST_CTIMENSEC
+
+/* Define to 1 if `st_ctime_n' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_CTIME_N@ HAVE_STRUCT_STAT_ST_CTIME_N
+
+/* Define to 1 if `st_ctim.tv_nsec' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC@ HAVE_STRUCT_STAT_ST_CTIM_TV_NSEC
+
+/* Define to 1 if `st_mtimensec' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_MTIMENSEC@ HAVE_STRUCT_STAT_ST_MTIMENSEC
+
+/* Define to 1 if `st_mtime_n' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_MTIME_N@ HAVE_STRUCT_STAT_ST_MTIME_N
+
+/* Define to 1 if `st_mtim.tv_nsec' is a member of `struct stat'. */
+#@DEFINE_HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC@ HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC
+
+/* Define to 1 if `tm_gmtoff' is a member of `struct tm'. */
+#@DEFINE_HAVE_STRUCT_TM_TM_GMTOFF@ HAVE_STRUCT_TM_TM_GMTOFF
+
+/* Define to 1 if `__tm_gmtoff' is a member of `struct tm'. */
+#@DEFINE_HAVE_STRUCT_TM___TM_GMTOFF@ HAVE_STRUCT_TM___TM_GMTOFF
+
+/* Define to 1 if you have the <sysapi.h> header file. */
+#@DEFINE_HAVE_SYSAPI_H@ HAVE_SYSAPI_H
+
+/* Define to 1 if you have the <sysgtime.h> header file. */
+#@DEFINE_HAVE_SYSGTIME_H@ HAVE_SYSGTIME_H
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#@DEFINE_HAVE_SYS_FILE_H@ HAVE_SYS_FILE_H
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#@DEFINE_HAVE_SYS_IOCTL_H@ HAVE_SYS_IOCTL_H
+
+/* Define to 1 if you have the <sys/ipc.h> header file. */
+#@DEFINE_HAVE_SYS_IPC_H@ HAVE_SYS_IPC_H
+
+/* Define to 1 if you have the <sys/mman.h> header file. */
+#@DEFINE_HAVE_SYS_MMAN_H@ HAVE_SYS_MMAN_H
+
+/* Define to 1 if you have the <sys/mutex.h> header file. */
+#@DEFINE_HAVE_SYS_MUTEX_H@ HAVE_SYS_MUTEX_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#@DEFINE_HAVE_SYS_PARAM_H@ HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/poll.h> header file. */
+#@DEFINE_HAVE_SYS_POLL_H@ HAVE_SYS_POLL_H
+
+/* Define to 1 if you have the <sys/resource.h> header file. */
+#@DEFINE_HAVE_SYS_RESOURCE_H@ HAVE_SYS_RESOURCE_H
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#@DEFINE_HAVE_SYS_SELECT_H@ HAVE_SYS_SELECT_H
+
+/* Define to 1 if you have the <sys/sem.h> header file. */
+#@DEFINE_HAVE_SYS_SEM_H@ HAVE_SYS_SEM_H
+
+/* Define to 1 if you have the <sys/sendfile.h> header file. */
+#@DEFINE_HAVE_SYS_SENDFILE_H@ HAVE_SYS_SENDFILE_H
+
+/* Define to 1 if you have the <sys/shm.h> header file. */
+#@DEFINE_HAVE_SYS_SHM_H@ HAVE_SYS_SHM_H
+
+/* Define to 1 if you have the <sys/signal.h> header file. */
+#@DEFINE_HAVE_SYS_SIGNAL_H@ HAVE_SYS_SIGNAL_H
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#@DEFINE_HAVE_SYS_SOCKET_H@ HAVE_SYS_SOCKET_H
+
+/* Define to 1 if you have the <sys/sockio.h> header file. */
+#@DEFINE_HAVE_SYS_SOCKIO_H@ HAVE_SYS_SOCKIO_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#@DEFINE_HAVE_SYS_STAT_H@ HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/sysctl.h> header file. */
+#@DEFINE_HAVE_SYS_SYSCTL_H@ HAVE_SYS_SYSCTL_H
+
+/* Define to 1 if you have the <sys/syslimits.h> header file. */
+#@DEFINE_HAVE_SYS_SYSLIMITS_H@ HAVE_SYS_SYSLIMITS_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#@DEFINE_HAVE_SYS_TIME_H@ HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#@DEFINE_HAVE_SYS_TYPES_H@ HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have the <sys/uio.h> header file. */
+#@DEFINE_HAVE_SYS_UIO_H@ HAVE_SYS_UIO_H
+
+/* Define to 1 if you have the <sys/un.h> header file. */
+#@DEFINE_HAVE_SYS_UN_H@ HAVE_SYS_UN_H
+
+/* Define to 1 if you have the <sys/uuid.h> header file. */
+#@DEFINE_HAVE_SYS_UUID_H@ HAVE_SYS_UUID_H
+
+/* Define to 1 if you have the <sys/wait.h> header file. */
+#@DEFINE_HAVE_SYS_WAIT_H@ HAVE_SYS_WAIT_H
+
+/* Define if TCP_CORK is defined in netinet/tcp.h */
+#@DEFINE_HAVE_TCP_CORK@ HAVE_TCP_CORK
+
+/* Define if TCP_NODELAY and TCP_CORK can be enabled at the same time */
+#@DEFINE_HAVE_TCP_NODELAY_WITH_CORK@ HAVE_TCP_NODELAY_WITH_CORK
+
+/* Define if TCP_NOPUSH is defined in netinet/tcp.h */
+#@DEFINE_HAVE_TCP_NOPUSH@ HAVE_TCP_NOPUSH
+
+/* Define to 1 if you have the <termios.h> header file. */
+#@DEFINE_HAVE_TERMIOS_H@ HAVE_TERMIOS_H
+
+/* Define to 1 if you have the <time.h> header file. */
+#@DEFINE_HAVE_TIME_H@ HAVE_TIME_H
+
+/* Define to 1 if you have the <tpfeq.h> header file. */
+#@DEFINE_HAVE_TPFEQ_H@ HAVE_TPFEQ_H
+
+/* Define to 1 if you have the <tpfio.h> header file. */
+#@DEFINE_HAVE_TPFIO_H@ HAVE_TPFIO_H
+
+/* Define if truerand is supported */
+#@DEFINE_HAVE_TRUERAND@ HAVE_TRUERAND
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#@DEFINE_HAVE_UNISTD_H@ HAVE_UNISTD_H
+
+/* Define to 1 if you have the <unix.h> header file. */
+#@DEFINE_HAVE_UNIX_H@ HAVE_UNIX_H
+
+/* Define to 1 if you have the `unsetenv' function. */
+#@DEFINE_HAVE_UNSETENV@ HAVE_UNSETENV
+
+/* Define to 1 if you have the `utime' function. */
+#@DEFINE_HAVE_UTIME@ HAVE_UTIME
+
+/* Define to 1 if you have the `utimes' function. */
+#@DEFINE_HAVE_UTIMES@ HAVE_UTIMES
+
+/* Define to 1 if you have the `uuid_create' function. */
+#@DEFINE_HAVE_UUID_CREATE@ HAVE_UUID_CREATE
+
+/* Define to 1 if you have the `uuid_generate' function. */
+#@DEFINE_HAVE_UUID_GENERATE@ HAVE_UUID_GENERATE
+
+/* Define to 1 if you have the <uuid.h> header file. */
+#@DEFINE_HAVE_UUID_H@ HAVE_UUID_H
+
+/* Define to 1 if you have the <uuid/uuid.h> header file. */
+#@DEFINE_HAVE_UUID_UUID_H@ HAVE_UUID_UUID_H
+
+/* Define if C compiler supports VLA */
+#@DEFINE_HAVE_VLA@ HAVE_VLA
+
+/* Define to 1 if you have the `waitpid' function. */
+#@DEFINE_HAVE_WAITPID@ HAVE_WAITPID
+
+/* Define to 1 if you have the <windows.h> header file. */
+#@DEFINE_HAVE_WINDOWS_H@ HAVE_WINDOWS_H
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+#@DEFINE_HAVE_WINSOCK2_H@ HAVE_WINSOCK2_H
+
+/* Define to 1 if you have the `writev' function. */
+#@DEFINE_HAVE_WRITEV@ HAVE_WRITEV
+
+/* Define for z/OS pthread API nuances */
+#@DEFINE_HAVE_ZOS_PTHREADS@ HAVE_ZOS_PTHREADS
+
+/* Define to the sub-directory in which libtool stores uninstalled libraries.
+   */
+#cmakedefine LT_OBJDIR "@LT_OBJDIR@"
+
+/* Define if EAI_ error codes from getaddrinfo are negative */
+#@DEFINE_NEGATIVE_EAI@ NEGATIVE_EAI
+
+/* Define to the address where bug reports for this package should be sent. */
+#cmakedefine PACKAGE_BUGREPORT "@PACKAGE_BUGREPORT@"
+
+/* Define to the full name of this package. */
+#cmakedefine PACKAGE_NAME "@PACKAGE_NAME@"
+
+/* Define to the full name and version of this package. */
+#cmakedefine PACKAGE_STRING "@PACKAGE_STRING@"
+
+/* Define to the one symbol short name of this package. */
+#cmakedefine PACKAGE_TARNAME "@PACKAGE_TARNAME@"
+
+/* Define to the home page for this package. */
+#cmakedefine PACKAGE_URL "@PACKAGE_URL@"
+
+/* Define to the version of this package. */
+#cmakedefine PACKAGE_VERSION "@PACKAGE_VERSION@"
+
+/* Define if POSIX semaphores affect threads within the process */
+#@DEFINE_POSIXSEM_IS_GLOBAL@ POSIXSEM_IS_GLOBAL
+
+/* Define on PowerPC 405 where errata 77 applies */
+#@DEFINE_PPC405_ERRATA@ PPC405_ERRATA
+
+/* Define if pthread_attr_getdetachstate() has one arg */
+#@DEFINE_PTHREAD_ATTR_GETDETACHSTATE_TAKES_ONE_ARG@ PTHREAD_ATTR_GETDETACHSTATE_TAKES_ONE_ARG
+
+/* Define if pthread_getspecific() has two args */
+#@DEFINE_PTHREAD_GETSPECIFIC_TAKES_TWO_ARGS@ PTHREAD_GETSPECIFIC_TAKES_TWO_ARGS
+
+/* Define if readdir is thread safe */
+#@DEFINE_READDIR_IS_THREAD_SAFE@ READDIR_IS_THREAD_SAFE
+
+/* Define to 1 if the `setpgrp' function takes no argument. */
+#@DEFINE_SETPGRP_VOID@ SETPGRP_VOID
+
+/* */
+#@DEFINE_SIGWAIT_TAKES_ONE_ARG@ SIGWAIT_TAKES_ONE_ARG
+
+/* The size of `char', as computed by sizeof. */
+@SIZEOF_CHAR_CODE@
+
+/* The size of ino_t */
+@SIZEOF_INO_T_CODE@
+
+/* The size of `int', as computed by sizeof. */
+@SIZEOF_INT_CODE@
+
+/* The size of `long', as computed by sizeof. */
+@SIZEOF_LONG_CODE@
+
+/* The size of `long long', as computed by sizeof. */
+@SIZEOF_LONG_LONG_CODE@
+
+/* The size of off_t */
+@SIZEOF_OFF_T_CODE@
+
+/* The size of pid_t */
+@SIZEOF_PID_T_CODE@
+
+/* The size of `short', as computed by sizeof. */
+@SIZEOF_SHORT_CODE@
+
+/* The size of size_t */
+@SIZEOF_SIZE_T_CODE@
+
+/* The size of ssize_t */
+@SIZEOF_SSIZE_T_CODE@
+
+/* The size of struct iovec */
+@SIZEOF_STRUCT_IOVEC_CODE@
+
+/* The size of `void*', as computed by sizeof. */
+@SIZEOF_VOIDP_CODE@
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+#@DEFINE_STACK_DIRECTION@ STACK_DIRECTION
+
+/* Define to 1 if you have the ANSI C header files. */
+#@DEFINE_STDC_HEADERS@ STDC_HEADERS
+
+/* Define if strerror returns int */
+#@DEFINE_STRERROR_R_RC_INT@ STRERROR_R_RC_INT
+
+/* Define if SysV semaphores affect threads within the process */
+#@DEFINE_SYSVSEM_IS_GLOBAL@ SYSVSEM_IS_GLOBAL
+
+/* Define if use of generic atomics is requested */
+#@DEFINE_USE_ATOMICS_GENERIC@ USE_ATOMICS_GENERIC
+
+/* Define if BeOS Semaphores will be used */
+#@DEFINE_USE_BEOSSEM@ USE_BEOSSEM
+
+/* Define if SVR4-style fcntl() will be used */
+#@DEFINE_USE_FCNTL_SERIALIZE@ USE_FCNTL_SERIALIZE
+
+/* Define if 4.2BSD-style flock() will be used */
+#@DEFINE_USE_FLOCK_SERIALIZE@ USE_FLOCK_SERIALIZE
+
+/* Define if BeOS areas will be used */
+#@DEFINE_USE_SHMEM_BEOS@ USE_SHMEM_BEOS
+
+/* Define if BeOS areas will be used */
+#@DEFINE_USE_SHMEM_BEOS_ANON@ USE_SHMEM_BEOS_ANON
+
+/* Define if 4.4BSD-style mmap() via MAP_ANON will be used */
+#@DEFINE_USE_SHMEM_MMAP_ANON@ USE_SHMEM_MMAP_ANON
+
+/* Define if mmap() via POSIX.1 shm_open() on temporary file will be used */
+#@DEFINE_USE_SHMEM_MMAP_SHM@ USE_SHMEM_MMAP_SHM
+
+/* Define if Classical mmap() on temporary file will be used */
+#@DEFINE_USE_SHMEM_MMAP_TMP@ USE_SHMEM_MMAP_TMP
+
+/* Define if SVR4-style mmap() on /dev/zero will be used */
+#@DEFINE_USE_SHMEM_MMAP_ZERO@ USE_SHMEM_MMAP_ZERO
+
+/* Define if OS/2 DosAllocSharedMem() will be used */
+#@DEFINE_USE_SHMEM_OS2@ USE_SHMEM_OS2
+
+/* Define if OS/2 DosAllocSharedMem() will be used */
+#@DEFINE_USE_SHMEM_OS2_ANON@ USE_SHMEM_OS2_ANON
+
+/* Define if SysV IPC shmget() will be used */
+#@DEFINE_USE_SHMEM_SHMGET@ USE_SHMEM_SHMGET
+
+/* Define if SysV IPC shmget() will be used */
+#@DEFINE_USE_SHMEM_SHMGET_ANON@ USE_SHMEM_SHMGET_ANON
+
+/* Define if Windows shared memory will be used */
+#@DEFINE_USE_SHMEM_WIN32@ USE_SHMEM_WIN32
+
+/* Define if Windows CreateFileMapping() will be used */
+#@DEFINE_USE_SHMEM_WIN32_ANON@ USE_SHMEM_WIN32_ANON
+
+/* Enable extensions on AIX 3, Interix.  */
+#ifndef _ALL_SOURCE
+#@DEFINE__ALL_SOURCE@ _ALL_SOURCE
+#endif
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+#@DEFINE__GNU_SOURCE@ _GNU_SOURCE
+#endif
+/* Enable threading extensions on Solaris.  */
+#ifndef _POSIX_PTHREAD_SEMANTICS
+#@DEFINE__POSIX_PTHREAD_SEMANTICS@ _POSIX_PTHREAD_SEMANTICS
+#endif
+/* Enable extensions on HP NonStop.  */
+#ifndef _TANDEM_SOURCE
+#@DEFINE__TANDEM_SOURCE@ _TANDEM_SOURCE
+#endif
+/* Enable general extensions on Solaris.  */
+#ifndef __EXTENSIONS__
+#@DEFINE___EXTENSIONS__@ __EXTENSIONS__
+#endif
+
+
+/* Define if SysV IPC semget() will be used */
+#@DEFINE_USE_SYSVSEM_SERIALIZE@ USE_SYSVSEM_SERIALIZE
+
+/* Define if apr_wait_for_io_or_timeout() uses poll(2) */
+#@DEFINE_WAITIO_USES_POLL@ WAITIO_USES_POLL
+
+/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most
+   significant byte first (like Motorola and SPARC, unlike Intel). */
+#if defined AC_APPLE_UNIVERSAL_BUILD
+# if defined __BIG_ENDIAN__
+#  define WORDS_BIGENDIAN 1
+# endif
+#else
+# ifndef WORDS_BIGENDIAN
+#@DEFINE_WORDS_BIGENDIAN@ WORDS_BIGENDIAN
+# endif
+#endif
+
+/* Define to 1 if on MINIX. */
+#@DEFINE__MINIX@ _MINIX
+
+/* Define to 2 if the system does not provide POSIX.1 features except with
+   this defined. */
+#@DEFINE__POSIX_1_SOURCE@ _POSIX_1_SOURCE
+
+/* Define to 1 if you need to in order for `stat' and other things to work. */
+#@DEFINE__POSIX_SOURCE@ _POSIX_SOURCE
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#@DEFINE_const@ const
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+#cmakedefine gid_t @gid_t@
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#cmakedefine inline @inline@
+#endif
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#cmakedefine off_t @off_t@
+
+/* Define to `int' if <sys/types.h> does not define. */
+#cmakedefine pid_t @pid_t@
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#cmakedefine size_t @size_t@
+
+/* Define to `int' if <sys/types.h> does not define. */
+#cmakedefine ssize_t @ssize_t@
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+#cmakedefine uid_t @uid_t@
+
+
+/* switch this on if we have a BeOS version below BONE */
+#if defined(BEOS) && !defined(HAVE_BONE_VERSION)
+#define BEOS_R5 1
+#else
+#define BEOS_BONE 1
+#endif
+
+/*
+ * Darwin 10's default compiler (gcc42) builds for both 64 and
+ * 32 bit architectures unless specifically told not to.
+ * In those cases, we need to override types depending on how
+ * we're being built at compile time.
+ * NOTE: This is an ugly work-around for Darwin's
+ * concept of universal binaries, a single package
+ * (executable, lib, etc...) which contains both 32
+ * and 64 bit versions. The issue is that if APR is
+ * built universally, if something else is compiled
+ * against it, some bit sizes will depend on whether
+ * it is 32 or 64 bit. This is determined by the __LP64__
+ * flag. Since we need to support both, we have to
+ * handle OS X unqiuely.
+ */
+#ifdef DARWIN_10
+
+#cmakedefine APR_OFF_T_STRFN @APR_OFF_T_STRFN@
+#cmakedefine APR_INT64_STRFN @APR_INT64_STRFN@
+#cmakedefine SIZEOF_LONG @SIZEOF_LONG@
+#cmakedefine SIZEOF_SIZE_T @SIZEOF_SIZE_T@
+#cmakedefine SIZEOF_SSIZE_T @SIZEOF_SSIZE_T@
+#cmakedefine SIZEOF_VOIDP @SIZEOF_VOIDP@
+#cmakedefine SIZEOF_STRUCT_IOVEC @SIZEOF_STRUCT_IOVEC@
+
+#ifdef __LP64__
+ #cmakedefine APR_INT64_STRFN @APR_INT64_STRFN@
+ #cmakedefine SIZEOF_LONG @SIZEOF_LONG@
+ #cmakedefine SIZEOF_SIZE_T @SIZEOF_SIZE_T@
+ #cmakedefine SIZEOF_SSIZE_T @SIZEOF_SSIZE_T@
+ #cmakedefine SIZEOF_VOIDP @SIZEOF_VOIDP@
+ #cmakedefine SIZEOF_STRUCT_IOVEC @SIZEOF_STRUCT_IOVEC@
+#else
+ #cmakedefine APR_INT64_STRFN @APR_INT64_STRFN@
+ #cmakedefine SIZEOF_LONG @SIZEOF_LONG@
+ #cmakedefine SIZEOF_SIZE_T @SIZEOF_SIZE_T@
+ #cmakedefine SIZEOF_SSIZE_T @SIZEOF_SSIZE_T@
+ #cmakedefine SIZEOF_VOIDP @SIZEOF_VOIDP@
+ #cmakedefine SIZEOF_STRUCT_IOVEC @SIZEOF_STRUCT_IOVEC@
+#endif
+
+#undef APR_OFF_T_STRFN
+#define APR_OFF_T_STRFN @APR_INT64_STRFN@
+
+
+#@DEFINE_SETPGRP_VOID@ SETPGRP_VOID
+#ifdef __DARWIN_UNIX03
+ #define SETPGRP_VOID 1
+#else
+/* #undef SETPGRP_VOID */
+#endif
+
+#endif /* DARWIN_10 */
+
+/*
+ * Include common private declarations.
+ */
+#include "../apr_private_common.h"
+#endif /* APR_PRIVATE_H */
+
diff --git a/test/sendfile.c b/test/sendfile.c
deleted file mode 100644
index f92b305..0000000
--- a/test/sendfile.c
+++ /dev/null
@@ -1,770 +0,0 @@
-/* Licensed to the Apache Software Foundation (ASF) under one or more
- * contributor license agreements.  See the NOTICE file distributed with
- * this work for additional information regarding copyright ownership.
- * The ASF licenses this file to You under the Apache License, Version 2.0
- * (the "License"); you may not use this file except in compliance with
- * the License.  You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-#include <assert.h>
-#include <errno.h>
-#include <signal.h>
-#include <stdlib.h>
-#include <string.h>
-#include "apr_network_io.h"
-#include "apr_errno.h"
-#include "apr_general.h"
-#include "apr_poll.h"
-#include "apr_thread_proc.h"
-
-#include "testutil.h"
-
-#if !APR_HAS_SENDFILE
-int main(void)
-{
-    fprintf(stderr, 
-            "This program won't work on this platform because there is no "
-            "support for sendfile().\n");
-    return 0;
-}
-#else /* !APR_HAS_SENDFILE */
-
-#define FILE_LENGTH    200000
-
-#define FILE_DATA_CHAR '0'
-
-#define HDR1           "1234567890ABCD\n"
-#define HDR2           "EFGH\n"
-#define HDR3_LEN       80000
-#define HDR3_CHAR      '^'
-#define TRL1           "IJKLMNOPQRSTUVWXYZ\n"
-#define TRL2           "!@#$%&*()\n"
-#define TRL3_LEN       90000
-#define TRL3_CHAR      '@'
-
-#define TESTSF_PORT    8021
-
-#define TESTFILE       "testsf.dat"
-
-typedef enum {BLK, NONBLK, TIMEOUT} client_socket_mode_t;
-
-static void aprerr(const char *fn, apr_status_t rv)
-{
-    char buf[120];
-
-    fprintf(stderr, "%s->%d/%s\n",
-            fn, rv, apr_strerror(rv, buf, sizeof buf));
-    exit(1);
-}
-
-static void apr_setup(apr_pool_t *p, apr_socket_t **sock, int *family)
-{
-    apr_status_t rv;
-
-    *sock = NULL;
-    rv = apr_socket_create(sock, *family, SOCK_STREAM, 0, p);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_create()", rv);
-    }
-
-    if (*family == APR_UNSPEC) {
-        apr_sockaddr_t *localsa;
-
-        rv = apr_socket_addr_get(&localsa, APR_LOCAL, *sock);
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_socket_addr_get()", rv);
-        }
-        *family = localsa->family;
-    }
-}
-
-static void create_testfile(apr_pool_t *p, const char *fname)
-{
-    apr_file_t *f = NULL;
-    apr_status_t rv;
-    char buf[120];
-    int i;
-    apr_finfo_t finfo;
-
-    printf("Creating a test file...\n");
-    rv = apr_file_open(&f, fname, 
-                 APR_FOPEN_CREATE | APR_FOPEN_WRITE | APR_FOPEN_TRUNCATE | APR_FOPEN_BUFFERED,
-                 APR_UREAD | APR_UWRITE, p);
-    if (rv) {
-        aprerr("apr_file_open()", rv);
-    }
-    
-    buf[0] = FILE_DATA_CHAR;
-    buf[1] = '\0';
-    for (i = 0; i < FILE_LENGTH; i++) {
-        /* exercise apr_file_putc() and apr_file_puts() on buffered files */
-        if ((i % 2) == 0) {
-            rv = apr_file_putc(buf[0], f);
-            if (rv) {
-                aprerr("apr_file_putc()", rv);
-            }
-        }
-        else {
-            rv = apr_file_puts(buf, f);
-            if (rv) {
-                aprerr("apr_file_puts()", rv);
-            }
-        }
-    }
-
-    rv = apr_file_close(f);
-    if (rv) {
-        aprerr("apr_file_close()", rv);
-    }
-
-    rv = apr_stat(&finfo, fname, APR_FINFO_NORM, p);
-    if (rv != APR_SUCCESS && ! APR_STATUS_IS_INCOMPLETE(rv)) {
-        aprerr("apr_stat()", rv);
-    }
-
-    if (finfo.size != FILE_LENGTH) {
-        fprintf(stderr, 
-                "test file %s should be %ld-bytes long\n"
-                "instead it is %ld-bytes long\n",
-                fname,
-                (long int)FILE_LENGTH,
-                (long int)finfo.size);
-        exit(1);
-    }
-}
-
-static void spawn_server(apr_pool_t *p, apr_proc_t *out_proc)
-{
-    apr_proc_t proc = {0};
-    apr_procattr_t *procattr;
-    apr_status_t rv;
-    const char *args[3];
-
-    rv = apr_procattr_create(&procattr, p);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_procattr_create()", rv);
-    }
-
-    rv = apr_procattr_io_set(procattr, APR_CHILD_BLOCK, APR_CHILD_BLOCK,
-                             APR_CHILD_BLOCK);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_procattr_io_set()", rv);
-    }
-
-    rv = apr_procattr_cmdtype_set(procattr, APR_PROGRAM_ENV);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_procattr_cmdtype_set()", rv);
-    }
-
-    rv = apr_procattr_error_check_set(procattr, 1);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_procattr_error_check_set()", rv);
-    }
-
-    args[0] = "sendfile" EXTENSION;
-    args[1] = "server";
-    args[2] = NULL;
-    rv = apr_proc_create(&proc, TESTBINPATH "sendfile" EXTENSION, args, NULL, procattr, p);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_proc_create()", rv);
-    }
-
-    *out_proc = proc;
-}
-
-static int client(apr_pool_t *p, client_socket_mode_t socket_mode,
-                  const char *host, int start_server)
-{
-    apr_status_t rv, tmprv;
-    apr_socket_t *sock;
-    char buf[120];
-    apr_file_t *f = NULL;
-    apr_size_t len;
-    apr_size_t expected_len;
-    apr_off_t current_file_offset;
-    apr_hdtr_t hdtr;
-    struct iovec headers[3];
-    struct iovec trailers[3];
-    apr_size_t bytes_read;
-    apr_pollset_t *pset;
-    apr_int32_t nsocks;
-    int connect_tries = 1;
-    int i;
-    int family;
-    apr_sockaddr_t *destsa;
-    apr_proc_t server;
-    apr_interval_time_t connect_retry_interval = apr_time_from_msec(50);
-
-    if (start_server) {
-        spawn_server(p, &server);
-        connect_tries = 5; /* give it a chance to start up */
-    }
-
-    create_testfile(p, TESTFILE);
-
-    rv = apr_file_open(&f, TESTFILE, APR_FOPEN_READ, 0, p);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_file_open()", rv);
-    }
-
-    if (!host) {
-        host = "127.0.0.1";
-    }
-    family = APR_INET;
-    rv = apr_sockaddr_info_get(&destsa, host, family, TESTSF_PORT, 0, p);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_sockaddr_info_get()", rv);
-    }
-
-    while (connect_tries--) {
-        apr_setup(p, &sock, &family);
-        rv = apr_socket_connect(sock, destsa);
-        if (connect_tries && APR_STATUS_IS_ECONNREFUSED(rv)) {
-            apr_status_t tmprv = apr_socket_close(sock);
-            if (tmprv != APR_SUCCESS) {
-                aprerr("apr_socket_close()", tmprv);
-            }
-            apr_sleep(connect_retry_interval);
-            connect_retry_interval *= 2;
-        }
-        else {
-            break;
-        }
-    }
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_connect()", rv);
-    }
-
-    switch(socket_mode) {
-    case BLK:
-        /* leave it blocking */
-        break;
-    case NONBLK:
-        /* set it non-blocking */
-        rv = apr_socket_opt_set(sock, APR_SO_NONBLOCK, 1);
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_socket_opt_set(APR_SO_NONBLOCK)", rv);
-        }
-        break;
-    case TIMEOUT:
-        /* set a timeout */
-        rv = apr_socket_timeout_set(sock, 100 * APR_USEC_PER_SEC);
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_socket_opt_set(APR_SO_NONBLOCK)", rv);
-            exit(1);
-        }
-        break;
-    default:
-        assert(1 != 1);
-    }
-
-    printf("Sending the file...\n");
-
-    hdtr.headers = headers;
-    hdtr.numheaders = 3;
-    hdtr.headers[0].iov_base = HDR1;
-    hdtr.headers[0].iov_len  = strlen(hdtr.headers[0].iov_base);
-    hdtr.headers[1].iov_base = HDR2;
-    hdtr.headers[1].iov_len  = strlen(hdtr.headers[1].iov_base);
-    hdtr.headers[2].iov_base = malloc(HDR3_LEN);
-    assert(hdtr.headers[2].iov_base);
-    memset(hdtr.headers[2].iov_base, HDR3_CHAR, HDR3_LEN);
-    hdtr.headers[2].iov_len  = HDR3_LEN;
-
-    hdtr.trailers = trailers;
-    hdtr.numtrailers = 3;
-    hdtr.trailers[0].iov_base = TRL1;
-    hdtr.trailers[0].iov_len  = strlen(hdtr.trailers[0].iov_base);
-    hdtr.trailers[1].iov_base = TRL2;
-    hdtr.trailers[1].iov_len  = strlen(hdtr.trailers[1].iov_base);
-    hdtr.trailers[2].iov_base = malloc(TRL3_LEN);
-    memset(hdtr.trailers[2].iov_base, TRL3_CHAR, TRL3_LEN);
-    assert(hdtr.trailers[2].iov_base);
-    hdtr.trailers[2].iov_len  = TRL3_LEN;
-
-    expected_len = 
-        strlen(HDR1) + strlen(HDR2) + HDR3_LEN +
-        strlen(TRL1) + strlen(TRL2) + TRL3_LEN +
-        FILE_LENGTH;
-    
-    if (socket_mode == BLK) {
-        current_file_offset = 0;
-        len = FILE_LENGTH;
-        rv = apr_socket_sendfile(sock, f, &hdtr, &current_file_offset, &len, 0);
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_socket_sendfile()", rv);
-        }
-        
-        printf("apr_socket_sendfile() updated offset with %ld\n",
-               (long int)current_file_offset);
-        
-        printf("apr_socket_sendfile() updated len with %ld\n",
-               (long int)len);
-        
-        printf("bytes really sent: %" APR_SIZE_T_FMT "\n",
-               expected_len);
-
-        if (len != expected_len) {
-            fprintf(stderr, "apr_socket_sendfile() didn't report the correct "
-                    "number of bytes sent!\n");
-            exit(1);
-        }
-    }
-    else {
-        /* non-blocking... wooooooo */
-        apr_size_t total_bytes_sent;
-        apr_pollfd_t pfd;
-
-        pset = NULL;
-        rv = apr_pollset_create(&pset, 1, p, 0);
-        assert(!rv);
-        pfd.p = p;
-        pfd.desc_type = APR_POLL_SOCKET;
-        pfd.reqevents = APR_POLLOUT;
-        pfd.rtnevents = 0;
-        pfd.desc.s = sock;
-        pfd.client_data = NULL;
-
-        rv = apr_pollset_add(pset, &pfd);        
-        assert(!rv);
-
-        total_bytes_sent = 0;
-        current_file_offset = 0;
-        len = FILE_LENGTH;
-        do {
-            apr_size_t tmplen;
-
-            tmplen = len; /* bytes remaining to send from the file */
-            printf("Calling apr_socket_sendfile()...\n");
-            printf("Headers (%d):\n", hdtr.numheaders);
-            for (i = 0; i < hdtr.numheaders; i++) {
-                printf("\t%ld bytes (%c)\n",
-                       (long)hdtr.headers[i].iov_len,
-                       *(char *)hdtr.headers[i].iov_base);
-            }
-            printf("File: %ld bytes from offset %ld\n",
-                   (long)tmplen, (long)current_file_offset);
-            printf("Trailers (%d):\n", hdtr.numtrailers);
-            for (i = 0; i < hdtr.numtrailers; i++) {
-                printf("\t%ld bytes\n",
-                       (long)hdtr.trailers[i].iov_len);
-            }
-
-            rv = apr_socket_sendfile(sock, f, &hdtr, &current_file_offset, &tmplen, 0);
-            printf("apr_socket_sendfile()->%d, sent %ld bytes\n", rv, (long)tmplen);
-            if (rv) {
-                if (APR_STATUS_IS_EAGAIN(rv)) {
-                    assert(tmplen == 0);
-                    nsocks = 1;
-                    tmprv = apr_pollset_poll(pset, -1, &nsocks, NULL);
-                    assert(!tmprv);
-                    assert(nsocks == 1);
-                    /* continue; */
-                }
-            }
-
-            total_bytes_sent += tmplen;
-
-            /* Adjust hdtr to compensate for partially-written
-             * data.
-             */
-
-            /* First, skip over any header data which might have
-             * been written.
-             */
-            while (tmplen && hdtr.numheaders) {
-                if (tmplen >= hdtr.headers[0].iov_len) {
-                    tmplen -= hdtr.headers[0].iov_len;
-                    --hdtr.numheaders;
-                    ++hdtr.headers;
-                }
-                else {
-                    hdtr.headers[0].iov_len -= tmplen;
-                    hdtr.headers[0].iov_base = 
-			(char*) hdtr.headers[0].iov_base + tmplen;
-                    tmplen = 0;
-                }
-            }
-
-            /* Now, skip over any file data which might have been
-             * written.
-             */
-
-            if (tmplen <= len) {
-                current_file_offset += tmplen;
-                len -= tmplen;
-                tmplen = 0;
-            }
-            else {
-                tmplen -= len;
-                len = 0;
-                current_file_offset = 0;
-            }
-
-            /* Last, skip over any trailer data which might have
-             * been written.
-             */
-
-            while (tmplen && hdtr.numtrailers) {
-                if (tmplen >= hdtr.trailers[0].iov_len) {
-                    tmplen -= hdtr.trailers[0].iov_len;
-                    --hdtr.numtrailers;
-                    ++hdtr.trailers;
-                }
-                else {
-                    hdtr.trailers[0].iov_len -= tmplen;
-                    hdtr.trailers[0].iov_base = 
-			(char *)hdtr.trailers[0].iov_base + tmplen;
-                    tmplen = 0;
-                }
-            }
-
-        } while (total_bytes_sent < expected_len &&
-                 (rv == APR_SUCCESS || 
-                 (APR_STATUS_IS_EAGAIN(rv) && socket_mode != TIMEOUT)));
-        if (total_bytes_sent != expected_len) {
-            fprintf(stderr,
-                    "client problem: sent %ld of %ld bytes\n",
-                    (long)total_bytes_sent, (long)expected_len);
-            exit(1);
-        }
-
-        if (rv) {
-            fprintf(stderr,
-                    "client problem: rv %d\n",
-                    rv);
-            exit(1);
-        }
-    }
-    
-    current_file_offset = 0;
-    rv = apr_file_seek(f, APR_CUR, &current_file_offset);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_file_seek()", rv);
-    }
-
-    printf("After apr_socket_sendfile(), the kernel file pointer is "
-           "at offset %ld.\n",
-           (long int)current_file_offset);
-
-    rv = apr_socket_shutdown(sock, APR_SHUTDOWN_WRITE);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_shutdown()", rv);
-    }
-
-    /* in case this is the non-blocking test, set socket timeout;
-     * we're just waiting for EOF */
-
-    rv = apr_socket_timeout_set(sock, apr_time_from_sec(3));
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_timeout_set()", rv);
-    }
-    
-    bytes_read = 1;
-    rv = apr_socket_recv(sock, buf, &bytes_read);
-    if (rv != APR_EOF) {
-        aprerr("apr_socket_recv() (expected APR_EOF)", rv);
-    }
-    if (bytes_read != 0) {
-        fprintf(stderr, "We expected to get 0 bytes read with APR_EOF\n"
-                "but instead we read %ld bytes.\n",
-                (long int)bytes_read);
-        exit(1);
-    }
-
-    printf("client: apr_socket_sendfile() worked as expected!\n");
-
-    rv = apr_file_remove(TESTFILE, p);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_file_remove()", rv);
-    }
-
-    if (start_server) {
-        apr_exit_why_e exitwhy;
-        apr_size_t nbytes;
-        char responsebuf[1024];
-        int exitcode;
-
-        rv = apr_file_pipe_timeout_set(server.out, apr_time_from_sec(2));
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_file_pipe_timeout_set()", rv);
-        }
-        nbytes = sizeof(responsebuf);
-        rv = apr_file_read(server.out, responsebuf, &nbytes);
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_file_read() messages from server", rv);
-        }
-        printf("%.*s", (int)nbytes, responsebuf);
-        rv = apr_proc_wait(&server, &exitcode, &exitwhy, APR_WAIT);
-        if (rv != APR_CHILD_DONE) {
-            aprerr("apr_proc_wait() (expected APR_CHILD_DONE)", rv);
-        }
-        if (exitcode != 0) {
-            fprintf(stderr, "sendfile server returned %d\n", exitcode);
-            exit(1);
-        }
-    }
-
-    return 0;
-}
-
-static int server(apr_pool_t *p)
-{
-    apr_status_t rv;
-    apr_socket_t *sock;
-    char buf[120];
-    int i;
-    apr_socket_t *newsock = NULL;
-    apr_size_t bytes_read;
-    apr_sockaddr_t *localsa;
-    int family;
-
-    family = APR_INET;
-    apr_setup(p, &sock, &family);
-
-    rv = apr_socket_opt_set(sock, APR_SO_REUSEADDR, 1);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_opt_set()", rv);
-    }
-
-    rv = apr_sockaddr_info_get(&localsa, NULL, family, TESTSF_PORT, 0, p);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_sockaddr_info_get()", rv);
-    }
-
-    rv = apr_socket_bind(sock, localsa);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_bind()", rv);
-    }
-
-    rv = apr_socket_listen(sock, 5);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_listen()", rv);
-    }
-
-    printf("Waiting for a client to connect...\n");
-
-    rv = apr_socket_accept(&newsock, sock, p);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_accept()", rv);
-    }
-
-    printf("Processing a client...\n");
-
-    assert(sizeof buf > strlen(HDR1));
-    bytes_read = strlen(HDR1);
-    rv = apr_socket_recv(newsock, buf, &bytes_read);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_recv()", rv);
-    }
-    if (bytes_read != strlen(HDR1)) {
-        fprintf(stderr, "wrong data read (1)\n");
-        exit(1);
-    }
-    if (memcmp(buf, HDR1, strlen(HDR1))) {
-        fprintf(stderr, "wrong data read (2)\n");
-        fprintf(stderr, "received: `%.*s'\nexpected: `%s'\n",
-                (int)bytes_read, buf, HDR1);
-        exit(1);
-    }
-        
-    assert(sizeof buf > strlen(HDR2));
-    bytes_read = strlen(HDR2);
-    rv = apr_socket_recv(newsock, buf, &bytes_read);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_recv()", rv);
-    }
-    if (bytes_read != strlen(HDR2)) {
-        fprintf(stderr, "wrong data read (3)\n");
-        exit(1);
-    }
-    if (memcmp(buf, HDR2, strlen(HDR2))) {
-        fprintf(stderr, "wrong data read (4)\n");
-        fprintf(stderr, "received: `%.*s'\nexpected: `%s'\n",
-                (int)bytes_read, buf, HDR2);
-        exit(1);
-    }
-
-    for (i = 0; i < HDR3_LEN; i++) {
-        bytes_read = 1;
-        rv = apr_socket_recv(newsock, buf, &bytes_read);
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_socket_recv()", rv);
-        }
-        if (bytes_read != 1) {
-            fprintf(stderr, "apr_socket_recv()->%ld bytes instead of 1\n",
-                    (long int)bytes_read);
-            exit(1);
-        }
-        if (buf[0] != HDR3_CHAR) {
-            fprintf(stderr,
-                    "problem with data read (byte %d of hdr 3):\n",
-                    i);
-            fprintf(stderr, "read `%c' (0x%x) from client; expected "
-                    "`%c'\n",
-                    buf[0], buf[0], HDR3_CHAR);
-            exit(1);
-        }
-    }
-        
-    for (i = 0; i < FILE_LENGTH; i++) {
-        bytes_read = 1;
-        rv = apr_socket_recv(newsock, buf, &bytes_read);
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_socket_recv()", rv);
-        }
-        if (bytes_read != 1) {
-            fprintf(stderr, "apr_socket_recv()->%ld bytes instead of 1\n",
-                    (long int)bytes_read);
-            exit(1);
-        }
-        if (buf[0] != FILE_DATA_CHAR) {
-            fprintf(stderr,
-                    "problem with data read (byte %d of file):\n",
-                    i);
-            fprintf(stderr, "read `%c' (0x%x) from client; expected "
-                    "`%c'\n",
-                    buf[0], buf[0], FILE_DATA_CHAR);
-            exit(1);
-        }
-    }
-        
-    assert(sizeof buf > strlen(TRL1));
-    bytes_read = strlen(TRL1);
-    rv = apr_socket_recv(newsock, buf, &bytes_read);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_recv()", rv);
-    }
-    if (bytes_read != strlen(TRL1)) {
-        fprintf(stderr, "wrong data read (5)\n");
-        exit(1);
-    }
-    if (memcmp(buf, TRL1, strlen(TRL1))) {
-        fprintf(stderr, "wrong data read (6)\n");
-        fprintf(stderr, "received: `%.*s'\nexpected: `%s'\n",
-                (int)bytes_read, buf, TRL1);
-        exit(1);
-    }
-        
-    assert(sizeof buf > strlen(TRL2));
-    bytes_read = strlen(TRL2);
-    rv = apr_socket_recv(newsock, buf, &bytes_read);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_socket_recv()", rv);
-    }
-    if (bytes_read != strlen(TRL2)) {
-        fprintf(stderr, "wrong data read (7)\n");
-        exit(1);
-    }
-    if (memcmp(buf, TRL2, strlen(TRL2))) {
-        fprintf(stderr, "wrong data read (8)\n");
-        fprintf(stderr, "received: `%.*s'\nexpected: `%s'\n",
-                (int)bytes_read, buf, TRL2);
-        exit(1);
-    }
-
-    for (i = 0; i < TRL3_LEN; i++) {
-        bytes_read = 1;
-        rv = apr_socket_recv(newsock, buf, &bytes_read);
-        if (rv != APR_SUCCESS) {
-            aprerr("apr_socket_recv()", rv);
-        }
-        if (bytes_read != 1) {
-            fprintf(stderr, "apr_socket_recv()->%ld bytes instead of 1\n",
-                    (long int)bytes_read);
-            exit(1);
-        }
-        if (buf[0] != TRL3_CHAR) {
-            fprintf(stderr,
-                    "problem with data read (byte %d of trl 3):\n",
-                    i);
-            fprintf(stderr, "read `%c' (0x%x) from client; expected "
-                    "`%c'\n",
-                    buf[0], buf[0], TRL3_CHAR);
-            exit(1);
-        }
-    }
-        
-    bytes_read = 1;
-    rv = apr_socket_recv(newsock, buf, &bytes_read);
-    if (rv != APR_EOF) {
-        aprerr("apr_socket_recv() (expected APR_EOF)", rv);
-    }
-    if (bytes_read != 0) {
-        fprintf(stderr, "We expected to get 0 bytes read with APR_EOF\n"
-                "but instead we read %ld bytes (%c).\n",
-                (long int)bytes_read, buf[0]);
-        exit(1);
-    }
-
-    printf("server: apr_socket_sendfile() worked as expected!\n");
-
-    return 0;
-}
-
-int main(int argc, char *argv[])
-{
-    apr_pool_t *p;
-    apr_status_t rv;
-
-#ifdef SIGPIPE
-    signal(SIGPIPE, SIG_IGN);
-#endif
-
-    rv = apr_initialize();
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_initialize()", rv);
-    }
-
-    atexit(apr_terminate);
-
-    rv = apr_pool_create(&p, NULL);
-    if (rv != APR_SUCCESS) {
-        aprerr("apr_pool_create()", rv);
-    }
-
-    if (argc >= 2 && !strcmp(argv[1], "client")) {
-        const char *host = NULL;
-        int mode = BLK;
-        int start_server = 0;
-        int i;
-
-        for (i = 2; i < argc; i++) {
-            if (!strcmp(argv[i], "blocking")) {
-                mode = BLK;
-            }
-            else if (!strcmp(argv[i], "timeout")) {
-                mode = TIMEOUT;
-            }
-            else if (!strcmp(argv[i], "nonblocking")) {
-                mode = NONBLK;
-            }
-            else if (!strcmp(argv[i], "startserver")) {
-                start_server = 1;
-            }
-            else {
-                host = argv[i];
-            }	
-        }
-        return client(p, mode, host, start_server);
-    }
-    else if (argc == 2 && !strcmp(argv[1], "server")) {
-        return server(p);
-    }
-
-    fprintf(stderr, 
-            "Usage: %s client {blocking|nonblocking|timeout} [startserver] [server-host]\n"
-            "       %s server\n",
-            argv[0], argv[0]);
-    return -1;
-}
-
-#endif /* !APR_HAS_SENDFILE */
diff --git a/test/sendfiletest.c b/test/sendfiletest.c
new file mode 100644
index 0000000..6653b72
--- /dev/null
+++ b/test/sendfiletest.c
@@ -0,0 +1,770 @@
+/* Licensed to the Apache Software Foundation (ASF) under one or more
+ * contributor license agreements.  See the NOTICE file distributed with
+ * this work for additional information regarding copyright ownership.
+ * The ASF licenses this file to You under the Apache License, Version 2.0
+ * (the "License"); you may not use this file except in compliance with
+ * the License.  You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <string.h>
+#include "apr_network_io.h"
+#include "apr_errno.h"
+#include "apr_general.h"
+#include "apr_poll.h"
+#include "apr_thread_proc.h"
+
+#include "testutil.h"
+
+#if !APR_HAS_SENDFILE
+int main(void)
+{
+    fprintf(stderr, 
+            "This program won't work on this platform because there is no "
+            "support for sendfile().\n");
+    return 0;
+}
+#else /* !APR_HAS_SENDFILE */
+
+#define FILE_LENGTH    200000
+
+#define FILE_DATA_CHAR '0'
+
+#define HDR1           "1234567890ABCD\n"
+#define HDR2           "EFGH\n"
+#define HDR3_LEN       80000
+#define HDR3_CHAR      '^'
+#define TRL1           "IJKLMNOPQRSTUVWXYZ\n"
+#define TRL2           "!@#$%&*()\n"
+#define TRL3_LEN       90000
+#define TRL3_CHAR      '@'
+
+#define TESTSF_PORT    8021
+
+#define TESTFILE       "testsf.dat"
+
+typedef enum {BLK, NONBLK, TIMEOUT} client_socket_mode_t;
+
+static void aprerr(const char *fn, apr_status_t rv)
+{
+    char buf[120];
+
+    fprintf(stderr, "%s->%d/%s\n",
+            fn, rv, apr_strerror(rv, buf, sizeof buf));
+    exit(1);
+}
+
+static void apr_setup(apr_pool_t *p, apr_socket_t **sock, int *family)
+{
+    apr_status_t rv;
+
+    *sock = NULL;
+    rv = apr_socket_create(sock, *family, SOCK_STREAM, 0, p);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_create()", rv);
+    }
+
+    if (*family == APR_UNSPEC) {
+        apr_sockaddr_t *localsa;
+
+        rv = apr_socket_addr_get(&localsa, APR_LOCAL, *sock);
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_socket_addr_get()", rv);
+        }
+        *family = localsa->family;
+    }
+}
+
+static void create_testfile(apr_pool_t *p, const char *fname)
+{
+    apr_file_t *f = NULL;
+    apr_status_t rv;
+    char buf[120];
+    int i;
+    apr_finfo_t finfo;
+
+    printf("Creating a test file...\n");
+    rv = apr_file_open(&f, fname, 
+                 APR_FOPEN_CREATE | APR_FOPEN_WRITE | APR_FOPEN_TRUNCATE | APR_FOPEN_BUFFERED,
+                 APR_UREAD | APR_UWRITE, p);
+    if (rv) {
+        aprerr("apr_file_open()", rv);
+    }
+    
+    buf[0] = FILE_DATA_CHAR;
+    buf[1] = '\0';
+    for (i = 0; i < FILE_LENGTH; i++) {
+        /* exercise apr_file_putc() and apr_file_puts() on buffered files */
+        if ((i % 2) == 0) {
+            rv = apr_file_putc(buf[0], f);
+            if (rv) {
+                aprerr("apr_file_putc()", rv);
+            }
+        }
+        else {
+            rv = apr_file_puts(buf, f);
+            if (rv) {
+                aprerr("apr_file_puts()", rv);
+            }
+        }
+    }
+
+    rv = apr_file_close(f);
+    if (rv) {
+        aprerr("apr_file_close()", rv);
+    }
+
+    rv = apr_stat(&finfo, fname, APR_FINFO_NORM, p);
+    if (rv != APR_SUCCESS && ! APR_STATUS_IS_INCOMPLETE(rv)) {
+        aprerr("apr_stat()", rv);
+    }
+
+    if (finfo.size != FILE_LENGTH) {
+        fprintf(stderr, 
+                "test file %s should be %ld-bytes long\n"
+                "instead it is %ld-bytes long\n",
+                fname,
+                (long int)FILE_LENGTH,
+                (long int)finfo.size);
+        exit(1);
+    }
+}
+
+static void spawn_server(apr_pool_t *p, apr_proc_t *out_proc)
+{
+    apr_proc_t proc = {0};
+    apr_procattr_t *procattr;
+    apr_status_t rv;
+    const char *args[3];
+
+    rv = apr_procattr_create(&procattr, p);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_procattr_create()", rv);
+    }
+
+    rv = apr_procattr_io_set(procattr, APR_CHILD_BLOCK, APR_CHILD_BLOCK,
+                             APR_CHILD_BLOCK);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_procattr_io_set()", rv);
+    }
+
+    rv = apr_procattr_cmdtype_set(procattr, APR_PROGRAM_ENV);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_procattr_cmdtype_set()", rv);
+    }
+
+    rv = apr_procattr_error_check_set(procattr, 1);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_procattr_error_check_set()", rv);
+    }
+
+    args[0] = "sendfiletest" EXTENSION;
+    args[1] = "server";
+    args[2] = NULL;
+    rv = apr_proc_create(&proc, TESTBINPATH "sendfiletest" EXTENSION, args, NULL, procattr, p);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_proc_create()", rv);
+    }
+
+    *out_proc = proc;
+}
+
+static int client(apr_pool_t *p, client_socket_mode_t socket_mode,
+                  const char *host, int start_server)
+{
+    apr_status_t rv, tmprv;
+    apr_socket_t *sock;
+    char buf[120];
+    apr_file_t *f = NULL;
+    apr_size_t len;
+    apr_size_t expected_len;
+    apr_off_t current_file_offset;
+    apr_hdtr_t hdtr;
+    struct iovec headers[3];
+    struct iovec trailers[3];
+    apr_size_t bytes_read;
+    apr_pollset_t *pset;
+    apr_int32_t nsocks;
+    int connect_tries = 1;
+    int i;
+    int family;
+    apr_sockaddr_t *destsa;
+    apr_proc_t server;
+    apr_interval_time_t connect_retry_interval = apr_time_from_msec(50);
+
+    if (start_server) {
+        spawn_server(p, &server);
+        connect_tries = 5; /* give it a chance to start up */
+    }
+
+    create_testfile(p, TESTFILE);
+
+    rv = apr_file_open(&f, TESTFILE, APR_FOPEN_READ, 0, p);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_file_open()", rv);
+    }
+
+    if (!host) {
+        host = "127.0.0.1";
+    }
+    family = APR_INET;
+    rv = apr_sockaddr_info_get(&destsa, host, family, TESTSF_PORT, 0, p);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_sockaddr_info_get()", rv);
+    }
+
+    while (connect_tries--) {
+        apr_setup(p, &sock, &family);
+        rv = apr_socket_connect(sock, destsa);
+        if (connect_tries && APR_STATUS_IS_ECONNREFUSED(rv)) {
+            apr_status_t tmprv = apr_socket_close(sock);
+            if (tmprv != APR_SUCCESS) {
+                aprerr("apr_socket_close()", tmprv);
+            }
+            apr_sleep(connect_retry_interval);
+            connect_retry_interval *= 2;
+        }
+        else {
+            break;
+        }
+    }
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_connect()", rv);
+    }
+
+    switch(socket_mode) {
+    case BLK:
+        /* leave it blocking */
+        break;
+    case NONBLK:
+        /* set it non-blocking */
+        rv = apr_socket_opt_set(sock, APR_SO_NONBLOCK, 1);
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_socket_opt_set(APR_SO_NONBLOCK)", rv);
+        }
+        break;
+    case TIMEOUT:
+        /* set a timeout */
+        rv = apr_socket_timeout_set(sock, 100 * APR_USEC_PER_SEC);
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_socket_opt_set(APR_SO_NONBLOCK)", rv);
+            exit(1);
+        }
+        break;
+    default:
+        assert(1 != 1);
+    }
+
+    printf("Sending the file...\n");
+
+    hdtr.headers = headers;
+    hdtr.numheaders = 3;
+    hdtr.headers[0].iov_base = HDR1;
+    hdtr.headers[0].iov_len  = strlen(hdtr.headers[0].iov_base);
+    hdtr.headers[1].iov_base = HDR2;
+    hdtr.headers[1].iov_len  = strlen(hdtr.headers[1].iov_base);
+    hdtr.headers[2].iov_base = malloc(HDR3_LEN);
+    assert(hdtr.headers[2].iov_base);
+    memset(hdtr.headers[2].iov_base, HDR3_CHAR, HDR3_LEN);
+    hdtr.headers[2].iov_len  = HDR3_LEN;
+
+    hdtr.trailers = trailers;
+    hdtr.numtrailers = 3;
+    hdtr.trailers[0].iov_base = TRL1;
+    hdtr.trailers[0].iov_len  = strlen(hdtr.trailers[0].iov_base);
+    hdtr.trailers[1].iov_base = TRL2;
+    hdtr.trailers[1].iov_len  = strlen(hdtr.trailers[1].iov_base);
+    hdtr.trailers[2].iov_base = malloc(TRL3_LEN);
+    memset(hdtr.trailers[2].iov_base, TRL3_CHAR, TRL3_LEN);
+    assert(hdtr.trailers[2].iov_base);
+    hdtr.trailers[2].iov_len  = TRL3_LEN;
+
+    expected_len = 
+        strlen(HDR1) + strlen(HDR2) + HDR3_LEN +
+        strlen(TRL1) + strlen(TRL2) + TRL3_LEN +
+        FILE_LENGTH;
+    
+    if (socket_mode == BLK) {
+        current_file_offset = 0;
+        len = FILE_LENGTH;
+        rv = apr_socket_sendfile(sock, f, &hdtr, &current_file_offset, &len, 0);
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_socket_sendfile()", rv);
+        }
+        
+        printf("apr_socket_sendfile() updated offset with %ld\n",
+               (long int)current_file_offset);
+        
+        printf("apr_socket_sendfile() updated len with %ld\n",
+               (long int)len);
+        
+        printf("bytes really sent: %" APR_SIZE_T_FMT "\n",
+               expected_len);
+
+        if (len != expected_len) {
+            fprintf(stderr, "apr_socket_sendfile() didn't report the correct "
+                    "number of bytes sent!\n");
+            exit(1);
+        }
+    }
+    else {
+        /* non-blocking... wooooooo */
+        apr_size_t total_bytes_sent;
+        apr_pollfd_t pfd;
+
+        pset = NULL;
+        rv = apr_pollset_create(&pset, 1, p, 0);
+        assert(!rv);
+        pfd.p = p;
+        pfd.desc_type = APR_POLL_SOCKET;
+        pfd.reqevents = APR_POLLOUT;
+        pfd.rtnevents = 0;
+        pfd.desc.s = sock;
+        pfd.client_data = NULL;
+
+        rv = apr_pollset_add(pset, &pfd);        
+        assert(!rv);
+
+        total_bytes_sent = 0;
+        current_file_offset = 0;
+        len = FILE_LENGTH;
+        do {
+            apr_size_t tmplen;
+
+            tmplen = len; /* bytes remaining to send from the file */
+            printf("Calling apr_socket_sendfile()...\n");
+            printf("Headers (%d):\n", hdtr.numheaders);
+            for (i = 0; i < hdtr.numheaders; i++) {
+                printf("\t%ld bytes (%c)\n",
+                       (long)hdtr.headers[i].iov_len,
+                       *(char *)hdtr.headers[i].iov_base);
+            }
+            printf("File: %ld bytes from offset %ld\n",
+                   (long)tmplen, (long)current_file_offset);
+            printf("Trailers (%d):\n", hdtr.numtrailers);
+            for (i = 0; i < hdtr.numtrailers; i++) {
+                printf("\t%ld bytes\n",
+                       (long)hdtr.trailers[i].iov_len);
+            }
+
+            rv = apr_socket_sendfile(sock, f, &hdtr, &current_file_offset, &tmplen, 0);
+            printf("apr_socket_sendfile()->%d, sent %ld bytes\n", rv, (long)tmplen);
+            if (rv) {
+                if (APR_STATUS_IS_EAGAIN(rv)) {
+                    assert(tmplen == 0);
+                    nsocks = 1;
+                    tmprv = apr_pollset_poll(pset, -1, &nsocks, NULL);
+                    assert(!tmprv);
+                    assert(nsocks == 1);
+                    /* continue; */
+                }
+            }
+
+            total_bytes_sent += tmplen;
+
+            /* Adjust hdtr to compensate for partially-written
+             * data.
+             */
+
+            /* First, skip over any header data which might have
+             * been written.
+             */
+            while (tmplen && hdtr.numheaders) {
+                if (tmplen >= hdtr.headers[0].iov_len) {
+                    tmplen -= hdtr.headers[0].iov_len;
+                    --hdtr.numheaders;
+                    ++hdtr.headers;
+                }
+                else {
+                    hdtr.headers[0].iov_len -= tmplen;
+                    hdtr.headers[0].iov_base = 
+			(char*) hdtr.headers[0].iov_base + tmplen;
+                    tmplen = 0;
+                }
+            }
+
+            /* Now, skip over any file data which might have been
+             * written.
+             */
+
+            if (tmplen <= len) {
+                current_file_offset += tmplen;
+                len -= tmplen;
+                tmplen = 0;
+            }
+            else {
+                tmplen -= len;
+                len = 0;
+                current_file_offset = 0;
+            }
+
+            /* Last, skip over any trailer data which might have
+             * been written.
+             */
+
+            while (tmplen && hdtr.numtrailers) {
+                if (tmplen >= hdtr.trailers[0].iov_len) {
+                    tmplen -= hdtr.trailers[0].iov_len;
+                    --hdtr.numtrailers;
+                    ++hdtr.trailers;
+                }
+                else {
+                    hdtr.trailers[0].iov_len -= tmplen;
+                    hdtr.trailers[0].iov_base = 
+			(char *)hdtr.trailers[0].iov_base + tmplen;
+                    tmplen = 0;
+                }
+            }
+
+        } while (total_bytes_sent < expected_len &&
+                 (rv == APR_SUCCESS || 
+                 (APR_STATUS_IS_EAGAIN(rv) && socket_mode != TIMEOUT)));
+        if (total_bytes_sent != expected_len) {
+            fprintf(stderr,
+                    "client problem: sent %ld of %ld bytes\n",
+                    (long)total_bytes_sent, (long)expected_len);
+            exit(1);
+        }
+
+        if (rv) {
+            fprintf(stderr,
+                    "client problem: rv %d\n",
+                    rv);
+            exit(1);
+        }
+    }
+    
+    current_file_offset = 0;
+    rv = apr_file_seek(f, APR_CUR, &current_file_offset);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_file_seek()", rv);
+    }
+
+    printf("After apr_socket_sendfile(), the kernel file pointer is "
+           "at offset %ld.\n",
+           (long int)current_file_offset);
+
+    rv = apr_socket_shutdown(sock, APR_SHUTDOWN_WRITE);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_shutdown()", rv);
+    }
+
+    /* in case this is the non-blocking test, set socket timeout;
+     * we're just waiting for EOF */
+
+    rv = apr_socket_timeout_set(sock, apr_time_from_sec(3));
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_timeout_set()", rv);
+    }
+    
+    bytes_read = 1;
+    rv = apr_socket_recv(sock, buf, &bytes_read);
+    if (rv != APR_EOF) {
+        aprerr("apr_socket_recv() (expected APR_EOF)", rv);
+    }
+    if (bytes_read != 0) {
+        fprintf(stderr, "We expected to get 0 bytes read with APR_EOF\n"
+                "but instead we read %ld bytes.\n",
+                (long int)bytes_read);
+        exit(1);
+    }
+
+    printf("client: apr_socket_sendfile() worked as expected!\n");
+
+    rv = apr_file_remove(TESTFILE, p);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_file_remove()", rv);
+    }
+
+    if (start_server) {
+        apr_exit_why_e exitwhy;
+        apr_size_t nbytes;
+        char responsebuf[1024];
+        int exitcode;
+
+        rv = apr_file_pipe_timeout_set(server.out, apr_time_from_sec(2));
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_file_pipe_timeout_set()", rv);
+        }
+        nbytes = sizeof(responsebuf);
+        rv = apr_file_read(server.out, responsebuf, &nbytes);
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_file_read() messages from server", rv);
+        }
+        printf("%.*s", (int)nbytes, responsebuf);
+        rv = apr_proc_wait(&server, &exitcode, &exitwhy, APR_WAIT);
+        if (rv != APR_CHILD_DONE) {
+            aprerr("apr_proc_wait() (expected APR_CHILD_DONE)", rv);
+        }
+        if (exitcode != 0) {
+            fprintf(stderr, "sendfiletest server returned %d\n", exitcode);
+            exit(1);
+        }
+    }
+
+    return 0;
+}
+
+static int server(apr_pool_t *p)
+{
+    apr_status_t rv;
+    apr_socket_t *sock;
+    char buf[120];
+    int i;
+    apr_socket_t *newsock = NULL;
+    apr_size_t bytes_read;
+    apr_sockaddr_t *localsa;
+    int family;
+
+    family = APR_INET;
+    apr_setup(p, &sock, &family);
+
+    rv = apr_socket_opt_set(sock, APR_SO_REUSEADDR, 1);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_opt_set()", rv);
+    }
+
+    rv = apr_sockaddr_info_get(&localsa, NULL, family, TESTSF_PORT, 0, p);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_sockaddr_info_get()", rv);
+    }
+
+    rv = apr_socket_bind(sock, localsa);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_bind()", rv);
+    }
+
+    rv = apr_socket_listen(sock, 5);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_listen()", rv);
+    }
+
+    printf("Waiting for a client to connect...\n");
+
+    rv = apr_socket_accept(&newsock, sock, p);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_accept()", rv);
+    }
+
+    printf("Processing a client...\n");
+
+    assert(sizeof buf > strlen(HDR1));
+    bytes_read = strlen(HDR1);
+    rv = apr_socket_recv(newsock, buf, &bytes_read);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_recv()", rv);
+    }
+    if (bytes_read != strlen(HDR1)) {
+        fprintf(stderr, "wrong data read (1)\n");
+        exit(1);
+    }
+    if (memcmp(buf, HDR1, strlen(HDR1))) {
+        fprintf(stderr, "wrong data read (2)\n");
+        fprintf(stderr, "received: `%.*s'\nexpected: `%s'\n",
+                (int)bytes_read, buf, HDR1);
+        exit(1);
+    }
+        
+    assert(sizeof buf > strlen(HDR2));
+    bytes_read = strlen(HDR2);
+    rv = apr_socket_recv(newsock, buf, &bytes_read);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_recv()", rv);
+    }
+    if (bytes_read != strlen(HDR2)) {
+        fprintf(stderr, "wrong data read (3)\n");
+        exit(1);
+    }
+    if (memcmp(buf, HDR2, strlen(HDR2))) {
+        fprintf(stderr, "wrong data read (4)\n");
+        fprintf(stderr, "received: `%.*s'\nexpected: `%s'\n",
+                (int)bytes_read, buf, HDR2);
+        exit(1);
+    }
+
+    for (i = 0; i < HDR3_LEN; i++) {
+        bytes_read = 1;
+        rv = apr_socket_recv(newsock, buf, &bytes_read);
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_socket_recv()", rv);
+        }
+        if (bytes_read != 1) {
+            fprintf(stderr, "apr_socket_recv()->%ld bytes instead of 1\n",
+                    (long int)bytes_read);
+            exit(1);
+        }
+        if (buf[0] != HDR3_CHAR) {
+            fprintf(stderr,
+                    "problem with data read (byte %d of hdr 3):\n",
+                    i);
+            fprintf(stderr, "read `%c' (0x%x) from client; expected "
+                    "`%c'\n",
+                    buf[0], buf[0], HDR3_CHAR);
+            exit(1);
+        }
+    }
+        
+    for (i = 0; i < FILE_LENGTH; i++) {
+        bytes_read = 1;
+        rv = apr_socket_recv(newsock, buf, &bytes_read);
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_socket_recv()", rv);
+        }
+        if (bytes_read != 1) {
+            fprintf(stderr, "apr_socket_recv()->%ld bytes instead of 1\n",
+                    (long int)bytes_read);
+            exit(1);
+        }
+        if (buf[0] != FILE_DATA_CHAR) {
+            fprintf(stderr,
+                    "problem with data read (byte %d of file):\n",
+                    i);
+            fprintf(stderr, "read `%c' (0x%x) from client; expected "
+                    "`%c'\n",
+                    buf[0], buf[0], FILE_DATA_CHAR);
+            exit(1);
+        }
+    }
+        
+    assert(sizeof buf > strlen(TRL1));
+    bytes_read = strlen(TRL1);
+    rv = apr_socket_recv(newsock, buf, &bytes_read);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_recv()", rv);
+    }
+    if (bytes_read != strlen(TRL1)) {
+        fprintf(stderr, "wrong data read (5)\n");
+        exit(1);
+    }
+    if (memcmp(buf, TRL1, strlen(TRL1))) {
+        fprintf(stderr, "wrong data read (6)\n");
+        fprintf(stderr, "received: `%.*s'\nexpected: `%s'\n",
+                (int)bytes_read, buf, TRL1);
+        exit(1);
+    }
+        
+    assert(sizeof buf > strlen(TRL2));
+    bytes_read = strlen(TRL2);
+    rv = apr_socket_recv(newsock, buf, &bytes_read);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_socket_recv()", rv);
+    }
+    if (bytes_read != strlen(TRL2)) {
+        fprintf(stderr, "wrong data read (7)\n");
+        exit(1);
+    }
+    if (memcmp(buf, TRL2, strlen(TRL2))) {
+        fprintf(stderr, "wrong data read (8)\n");
+        fprintf(stderr, "received: `%.*s'\nexpected: `%s'\n",
+                (int)bytes_read, buf, TRL2);
+        exit(1);
+    }
+
+    for (i = 0; i < TRL3_LEN; i++) {
+        bytes_read = 1;
+        rv = apr_socket_recv(newsock, buf, &bytes_read);
+        if (rv != APR_SUCCESS) {
+            aprerr("apr_socket_recv()", rv);
+        }
+        if (bytes_read != 1) {
+            fprintf(stderr, "apr_socket_recv()->%ld bytes instead of 1\n",
+                    (long int)bytes_read);
+            exit(1);
+        }
+        if (buf[0] != TRL3_CHAR) {
+            fprintf(stderr,
+                    "problem with data read (byte %d of trl 3):\n",
+                    i);
+            fprintf(stderr, "read `%c' (0x%x) from client; expected "
+                    "`%c'\n",
+                    buf[0], buf[0], TRL3_CHAR);
+            exit(1);
+        }
+    }
+        
+    bytes_read = 1;
+    rv = apr_socket_recv(newsock, buf, &bytes_read);
+    if (rv != APR_EOF) {
+        aprerr("apr_socket_recv() (expected APR_EOF)", rv);
+    }
+    if (bytes_read != 0) {
+        fprintf(stderr, "We expected to get 0 bytes read with APR_EOF\n"
+                "but instead we read %ld bytes (%c).\n",
+                (long int)bytes_read, buf[0]);
+        exit(1);
+    }
+
+    printf("server: apr_socket_sendfile() worked as expected!\n");
+
+    return 0;
+}
+
+int main(int argc, char *argv[])
+{
+    apr_pool_t *p;
+    apr_status_t rv;
+
+#ifdef SIGPIPE
+    signal(SIGPIPE, SIG_IGN);
+#endif
+
+    rv = apr_initialize();
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_initialize()", rv);
+    }
+
+    atexit(apr_terminate);
+
+    rv = apr_pool_create(&p, NULL);
+    if (rv != APR_SUCCESS) {
+        aprerr("apr_pool_create()", rv);
+    }
+
+    if (argc >= 2 && !strcmp(argv[1], "client")) {
+        const char *host = NULL;
+        int mode = BLK;
+        int start_server = 0;
+        int i;
+
+        for (i = 2; i < argc; i++) {
+            if (!strcmp(argv[i], "blocking")) {
+                mode = BLK;
+            }
+            else if (!strcmp(argv[i], "timeout")) {
+                mode = TIMEOUT;
+            }
+            else if (!strcmp(argv[i], "nonblocking")) {
+                mode = NONBLK;
+            }
+            else if (!strcmp(argv[i], "startserver")) {
+                start_server = 1;
+            }
+            else {
+                host = argv[i];
+            }	
+        }
+        return client(p, mode, host, start_server);
+    }
+    else if (argc == 2 && !strcmp(argv[1], "server")) {
+        return server(p);
+    }
+
+    fprintf(stderr, 
+            "Usage: %s client {blocking|nonblocking|timeout} [startserver] [server-host]\n"
+            "       %s server\n",
+            argv[0], argv[0]);
+    return -1;
+}
+
+#endif /* !APR_HAS_SENDFILE */
diff --git a/test/testapp.c b/test/testapp.c
index 77607aa..83e3fe8 100644
--- a/test/testapp.c
+++ b/test/testapp.c
@@ -7,4 +7,5 @@ int main(int argc, const char * const * argv, const char * const *env)
 
 
     apr_terminate();
+    return 0;
 }
diff --git a/test/testdso.c b/test/testdso.c
index 0d9f27b..4611680 100644
--- a/test/testdso.c
+++ b/test/testdso.c
@@ -35,6 +35,9 @@
 # define MOD_NAME "mod_test.so"
 #elif defined(WIN32)
 # define MOD_NAME TESTBINPATH "mod_test.dll"
+#elif defined(CMAKE_UNIX)
+# define MOD_NAME "libmod_test.so"
+# define LIB_NAME "libmod_test.so"
 #elif defined(DARWIN)
 # define MOD_NAME ".libs/mod_test.so" 
 # define LIB_NAME ".libs/libmod_test.dylib" 
diff --git a/test/testsockets.c b/test/testsockets.c
index 2a7499a..78c796d 100644
--- a/test/testsockets.c
+++ b/test/testsockets.c
@@ -228,8 +228,10 @@ abts_suite *testsockets(abts_suite *suite)
     abts_run_test(suite, tcp6_socket, NULL);
     abts_run_test(suite, udp6_socket, NULL);
 
+#if !defined __sun
     abts_run_test(suite, sendto_receivefrom6, NULL);
 #endif
+#endif
 
     abts_run_test(suite, socket_userdata, NULL);
     
