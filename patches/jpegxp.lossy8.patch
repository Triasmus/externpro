diff --git a/jconfig.doc b/jconfig.h
similarity index 92%
rename from jconfig.doc
rename to jconfig.h
index c18d1c0..1eb07bb 100644
--- a/jconfig.doc
+++ b/jconfig.h
@@ -1,5 +1,5 @@
 /*
- * jconfig.doc
+ * jconfig.h
  *
  * Copyright (C) 1991-1994, Thomas G. Lane.
  * This file is part of the Independent JPEG Group's software.
@@ -7,14 +7,6 @@
  *
  * This file documents the configuration options that are required to
  * customize the JPEG software for a particular system.
- *
- * The actual configuration options for a particular installation are stored
- * in jconfig.h.  On many machines, jconfig.h can be generated automatically
- * or copied from one of the "canned" jconfig files that we supply.  But if
- * you need to generate a jconfig.h file by hand, this file tells you how.
- *
- * DO NOT EDIT THIS FILE --- IT WON'T ACCOMPLISH ANYTHING.
- * EDIT A COPY NAMED JCONFIG.H.
  */
 
 
diff --git a/jmorecfg.h b/jmorecfg.h
index 54a7d1c..c26132e 100644
--- a/jmorecfg.h
+++ b/jmorecfg.h
@@ -10,6 +10,8 @@
  * optimizations.  Most users will not need to touch this file.
  */
 
+#ifndef JMORECFG_H
+#define JMORECFG_H
 
 /*
  * Define BITS_IN_JSAMPLE as either
@@ -20,8 +22,9 @@
  * We do not support run-time selection of data precision, sorry.
  */
 
-#define BITS_IN_JSAMPLE  8	/* use 8 or 12 */
-
+#define BITS_IN_JSAMPLE     8
+#define BITS_IN_JSAMPLE12  12
+#define BITS_IN_JSAMPLE16  16
 
 /*
  * Maximum number of components (color channels) allowed in JPEG image.
@@ -43,51 +46,36 @@
  * but it had better be at least 16.
  */
 
+#if !defined HAVE_UNSIGNED_CHAR || !defined HAVE_UNSIGNED_SHORT
+# error "jmorecfg.h needs mods to support a lack of unsigned types"
+#endif
+
 /* Representation of a single sample (pixel element value).
  * We frequently allocate large arrays of these, so it's important to keep
  * them small.  But if you have memory to burn and access to char or short
  * arrays is very slow on your hardware, you might want to change these.
  */
 
-#if BITS_IN_JSAMPLE == 8
-/* JSAMPLE should be the smallest type that will hold the values 0..255.
+#define GETJSAMPLE(value)  ((int) (value))
+
+/* 8-bit
+ * JSAMPLE should be the smallest type that will hold the values 0..255.
  * You can use a signed char by having GETJSAMPLE mask it with 0xFF.
  */
-
-#ifdef HAVE_UNSIGNED_CHAR
-
 typedef unsigned char JSAMPLE;
-#define GETJSAMPLE(value)  ((int) (value))
-
-#else /* not HAVE_UNSIGNED_CHAR */
-
-typedef char JSAMPLE;
-#ifdef CHAR_IS_UNSIGNED
-#define GETJSAMPLE(value)  ((int) (value))
-#else
-#define GETJSAMPLE(value)  ((int) (value) & 0xFF)
-#endif /* CHAR_IS_UNSIGNED */
-
-#endif /* HAVE_UNSIGNED_CHAR */
 
 #define MAXJSAMPLE	255
 #define CENTERJSAMPLE	128
 
-#endif /* BITS_IN_JSAMPLE == 8 */
-
-
-#if BITS_IN_JSAMPLE == 12
-/* JSAMPLE should be the smallest type that will hold the values 0..4095.
- * On nearly all machines "short" will do nicely.
+/* 12-, 10-, and 14-, and 16-bit
+ * JSAMPLEXP should be the smallest type that will hold the values 0..4095
+ * (12-bit), 0..1023 (10-bit), 0..16383 (14-bit), 0..65535 (16-bit).
+ * On nearly all machines "unsigned short" will do nicely.
  */
+typedef unsigned short JSAMPLEXP;
 
-typedef short JSAMPLE;
-#define GETJSAMPLE(value)  ((int) (value))
-
-#define MAXJSAMPLE	4095
-#define CENTERJSAMPLE	2048
-
-#endif /* BITS_IN_JSAMPLE == 12 */
+#define MAXJSAMPLE12	4095
+#define CENTERJSAMPLE12	2048
 
 
 /* Representation of a DCT frequency coefficient.
@@ -99,6 +87,13 @@ typedef short JSAMPLE;
 typedef short JCOEF;
 
 
+/* Representation of a spatial difference value.
+ * This should be a signed value of at least 16 bits; int is usually OK.
+ */
+
+typedef int JDIFF;
+
+
 /* Compressed datastreams are represented as arrays of JOCTET.
  * These must be EXACTLY 8 bits wide, at least once they are written to
  * external storage.  Note that when using the stdio data source/destination
@@ -233,6 +228,7 @@ typedef int boolean;
 #define TRUE	1
 #endif
 
+#endif /* JMORECFG_H */
 
 /*
  * The remaining options affect code selection within the JPEG library,
@@ -269,14 +265,16 @@ typedef int boolean;
 #undef  C_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
 #define C_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
 #define C_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
+#undef C_LOSSLESS_SUPPORTED	        /* Lossless JPEG? */
 #define ENTROPY_OPT_SUPPORTED	    /* Optimization of entropy coding parms? */
 /* Note: if you selected 12-bit data precision, it is dangerous to turn off
  * ENTROPY_OPT_SUPPORTED.  The standard Huffman tables are only good for 8-bit
  * precision, so jchuff.c normally uses entropy optimization to compute
  * usable tables for higher precision.  If you don't want to do optimization,
  * you'll have to supply different default Huffman tables.
- * The exact same statements apply for progressive JPEG: the default tables
- * don't work for progressive mode.  (This may get fixed, however.)
+ * The exact same statements apply for progressive and lossless JPEG:
+ * the default tables don't work for progressive mode or lossless mode.
+ * (This may get fixed, however.)
  */
 #define INPUT_SMOOTHING_SUPPORTED   /* Input image smoothing option? */
 
@@ -285,6 +283,7 @@ typedef int boolean;
 #undef  D_ARITH_CODING_SUPPORTED    /* Arithmetic coding back end? */
 #define D_MULTISCAN_FILES_SUPPORTED /* Multiple-scan JPEG files? */
 #define D_PROGRESSIVE_SUPPORTED	    /* Progressive JPEG? (Requires MULTISCAN)*/
+#define D_LOSSLESS_SUPPORTED	    /* Lossless JPEG? */
 #define SAVE_MARKERS_SUPPORTED	    /* jpeg_save_markers() needed? */
 #define BLOCK_SMOOTHING_SUPPORTED   /* Block smoothing? (Progressive only) */
 #define IDCT_SCALING_SUPPORTED	    /* Output rescaling via IDCT? */
diff --git a/jpeglib.h b/jpeglib.h
index d1be8dd..acdbcc0 100644
--- a/jpeglib.h
+++ b/jpeglib.h
@@ -56,6 +56,7 @@
 #ifndef D_MAX_BLOCKS_IN_MCU
 #define D_MAX_BLOCKS_IN_MCU   10 /* decompressor's limit on blocks per MCU */
 #endif
+/* renamed to C_MAX_DATA_UNITS_IN_MCU, D_MAX_DATA_UNITS_IN_MCU in lossless */
 
 
 /* Data structures for images (arrays of samples and of DCT coefficients).
@@ -67,6 +68,10 @@ typedef JSAMPLE FAR *JSAMPROW;	/* ptr to one image row of pixel samples. */
 typedef JSAMPROW *JSAMPARRAY;	/* ptr to some rows (a 2-D sample array) */
 typedef JSAMPARRAY *JSAMPIMAGE;	/* a 3-D sample array: top index is color */
 
+typedef JSAMPLEXP FAR *JSAMPROWXP;	/* ptr to one image row of pixel samples. */
+typedef JSAMPROWXP *JSAMPARRAYXP;	/* ptr to some rows (a 2-D sample array) */
+typedef JSAMPARRAYXP *JSAMPIMAGEXP;	/* a 3-D sample array: top index is color */
+
 typedef JCOEF JBLOCK[DCTSIZE2];	/* one block of coefficients */
 typedef JBLOCK FAR *JBLOCKROW;	/* pointer to one row of coefficient blocks */
 typedef JBLOCKROW *JBLOCKARRAY;		/* a 2-D array of coefficient blocks */
@@ -74,6 +79,10 @@ typedef JBLOCKARRAY *JBLOCKIMAGE;	/* a 3-D array of coefficient blocks */
 
 typedef JCOEF FAR *JCOEFPTR;	/* useful in a couple of places */
 
+typedef JDIFF FAR *JDIFFROW;	/* pointer to one row of difference values */
+typedef JDIFFROW *JDIFFARRAY;	/* ptr to some rows (a 2-D diff array) */
+typedef JDIFFARRAY *JDIFFIMAGE;	/* a 3-D diff array: top index is color */
+
 
 /* Types for JPEG compression parameters and working tables. */
 
@@ -136,15 +145,15 @@ typedef struct {
    * Any dummy blocks added to complete an MCU are not counted; therefore
    * these values do not depend on whether a scan is interleaved or not.
    */
-  JDIMENSION width_in_blocks;
-  JDIMENSION height_in_blocks;
+  JDIMENSION width_in_blocks;  /* renamed width_in_data_units in lossless */
+  JDIMENSION height_in_blocks; /* renamed height_in_data_units in lossless */
   /* Size of a DCT block in samples.  Always DCTSIZE for compression.
    * For decompression this is the size of the output from one DCT block,
    * reflecting any scaling we choose to apply during the IDCT step.
    * Values of 1,2,4,8 are likely to be supported.  Note that different
    * components may receive different IDCT scalings.
    */
-  int DCT_scaled_size;
+  int DCT_scaled_size; /* renamed codec_data_unit in lossless */
   /* The downsampled dimensions are the component's actual, unpadded number
    * of samples at the main buffer (preprocessing/compression interface), thus
    * downsampled_width = ceil(image_width * Hi/Hmax)
@@ -163,7 +172,7 @@ typedef struct {
   /* The decompressor output side may not use these variables. */
   int MCU_width;		/* number of blocks per MCU, horizontally */
   int MCU_height;		/* number of blocks per MCU, vertically */
-  int MCU_blocks;		/* MCU_width * MCU_height */
+  int MCU_blocks;		/* MCU_width * MCU_height -- MCU_data_units in lossless */
   int MCU_sample_width;		/* MCU width in samples, MCU_width*DCT_scaled_size */
   int last_col_width;		/* # of non-dummy blocks across in last MCU */
   int last_row_height;		/* # of non-dummy blocks down in last MCU */
@@ -184,8 +193,10 @@ typedef struct {
 typedef struct {
   int comps_in_scan;		/* number of components encoded in this scan */
   int component_index[MAX_COMPS_IN_SCAN]; /* their SOF/comp_info[] indexes */
-  int Ss, Se;			/* progressive JPEG spectral selection parms */
-  int Ah, Al;			/* progressive JPEG successive approx. parms */
+  int Ss, Se;			/* progressive JPEG spectral selection parms
+				   lossless JPEG predictor select parm (Ss) */
+  int Ah, Al;			/* progressive JPEG successive approx. parms
+				   lossless JPEG point transform parm (Al) */
 } jpeg_scan_info;
 
 /* The decompressor can save APPn and COM markers in a list of these: */
@@ -576,6 +587,7 @@ struct jpeg_decompress_struct {
   int max_v_samp_factor;	/* largest v_samp_factor */
 
   int min_DCT_scaled_size;	/* smallest DCT_scaled_size of any component */
+                            /* renamed min_codec_data_unit in lossless */
 
   JDIMENSION total_iMCU_rows;	/* # of iMCU rows in image */
   /* The coefficient controller's input and output progress is measured in
@@ -600,12 +612,12 @@ struct jpeg_decompress_struct {
   JDIMENSION MCUs_per_row;	/* # of MCUs across the image */
   JDIMENSION MCU_rows_in_scan;	/* # of MCU rows in the image */
 
-  int blocks_in_MCU;		/* # of DCT blocks per MCU */
+  int blocks_in_MCU; /* # of DCT blocks per MCU (data_units_in_MCU in lossless) */
   int MCU_membership[D_MAX_BLOCKS_IN_MCU];
   /* MCU_membership[i] is index in cur_comp_info of component owning */
   /* i'th block in an MCU */
 
-  int Ss, Se, Ah, Al;		/* progressive JPEG parameters for scan */
+  int Ss, Se, Ah, Al;		/* progressive/lossless JPEG parms for scan */
 
   /* This field is shared between entropy decoder and marker parser.
    * It is either zero or the code of a JPEG marker that has been
@@ -753,6 +765,14 @@ typedef struct jvirt_sarray_control * jvirt_sarray_ptr;
 typedef struct jvirt_barray_control * jvirt_barray_ptr;
 
 
+#ifdef C_LOSSLESS_SUPPORTED
+#define NEED_DARRAY
+#else
+#ifdef D_LOSSLESS_SUPPORTED
+#define NEED_DARRAY
+#endif
+#endif
+
 struct jpeg_memory_mgr {
   /* Method pointers */
   JMETHOD(void *, alloc_small, (j_common_ptr cinfo, int pool_id,
@@ -762,9 +782,17 @@ struct jpeg_memory_mgr {
   JMETHOD(JSAMPARRAY, alloc_sarray, (j_common_ptr cinfo, int pool_id,
 				     JDIMENSION samplesperrow,
 				     JDIMENSION numrows));
+  JMETHOD(JSAMPARRAYXP, alloc_sarray_xp, (j_common_ptr cinfo, int pool_id,
+				     JDIMENSION samplesperrow,
+				     JDIMENSION numrows));
   JMETHOD(JBLOCKARRAY, alloc_barray, (j_common_ptr cinfo, int pool_id,
 				      JDIMENSION blocksperrow,
 				      JDIMENSION numrows));
+#ifdef NEED_DARRAY
+  JMETHOD(JDIFFARRAY, alloc_darray, (j_common_ptr cinfo, int pool_id,
+				     JDIMENSION diffsperrow,
+				     JDIMENSION numrows));
+#endif
   JMETHOD(jvirt_sarray_ptr, request_virt_sarray, (j_common_ptr cinfo,
 						  int pool_id,
 						  boolean pre_zero,
@@ -778,11 +806,17 @@ struct jpeg_memory_mgr {
 						  JDIMENSION numrows,
 						  JDIMENSION maxaccess));
   JMETHOD(void, realize_virt_arrays, (j_common_ptr cinfo));
+  JMETHOD(void, realize_virt_arrays_xp, (j_common_ptr cinfo));
   JMETHOD(JSAMPARRAY, access_virt_sarray, (j_common_ptr cinfo,
 					   jvirt_sarray_ptr ptr,
 					   JDIMENSION start_row,
 					   JDIMENSION num_rows,
 					   boolean writable));
+  JMETHOD(JSAMPARRAYXP, access_virt_sarray_xp, (j_common_ptr cinfo,
+					   jvirt_sarray_ptr ptr,
+					   JDIMENSION start_row,
+					   JDIMENSION num_rows,
+					   boolean writable));
   JMETHOD(JBLOCKARRAY, access_virt_barray, (j_common_ptr cinfo,
 					    jvirt_barray_ptr ptr,
 					    JDIMENSION start_row,
@@ -1089,7 +1123,9 @@ struct jpeg_color_quantizer { long dummy; };
  */
 
 #ifdef JPEG_INTERNALS
+#ifndef XJPEGLIB_H
 #include "jpegint.h"		/* fetch private declarations */
+#endif
 #include "jerror.h"		/* fetch error codes too */
 #endif
 
